<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ICU Note Maker</title>
    <style>
        :root {
            --primary: #3b82f6;
            --secondary: #06b6d4;
            --success: #10b981;
            --danger: #ef4444;
            --warning: #f59e0b;
            --dark-bg: #1e293b;
            --card-bg: #2d3748;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #475569;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, var(--dark-bg) 0%, #0f172a 100%);
            color: var(--text-primary);
            padding: 2rem;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 2rem;
            font-size: 2.5rem;
            text-shadow: 0 0 20px rgba(59, 130, 246, 0.5);
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .section {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 2px solid var(--border);
        }

        .section h2 {
            color: var(--secondary);
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        textarea {
            width: 100%;
            min-height: 300px;
            background: var(--dark-bg);
            color: var(--text-primary);
            border: 1px solid var(--border);
            border-radius: 0.375rem;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .button-group {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: linear-gradient(135deg, var(--warning), #ea580c);
        }

        button.success {
            background: linear-gradient(135deg, var(--success), #059669);
        }

        .output-section {
            background: var(--card-bg);
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 2px solid var(--success);
            margin-top: 2rem;
        }

        .output-section h2 {
            color: var(--success);
            margin-bottom: 1rem;
        }

        .note-output {
            background: var(--dark-bg);
            padding: 1.5rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
            max-height: 70vh;
            overflow-y: auto;
        }

        .status-message {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 0.375rem;
            border-left: 4px solid var(--primary);
            margin-top: 1rem;
            display: none;
        }

        .status-message.show {
            display: block;
        }

        .status-message.success {
            border-left-color: var(--success);
        }

        .status-message.error {
            border-left-color: var(--danger);
        }

        @media (max-width: 1024px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üè• ICU Note Maker</h1>

        <div class="main-grid">
            <!-- Input Section -->
            <div class="section">
                <h2>üìã Input Data</h2>
                <label style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.25rem; display: block;">
                    Paste VIOLIN Data (Vitals, I/Os, Labs, Medications):
                </label>
                <textarea id="violinInput" placeholder="Paste your VIOLIN data here...&#10;Include:&#10;- Vital signs&#10;- Intake/Output&#10;- Lab values&#10;- Medications&#10;- Diet orders"></textarea>
                
                <div class="button-group">
                    <button onclick="generateNote()">‚ö° Generate New Note</button>
                    <button class="secondary" onclick="clearAll()">üóëÔ∏è Clear All</button>
                </div>
            </div>

            <!-- Existing Note Section -->
            <div class="section">
                <h2>üìù Existing Note (Optional)</h2>
                <label style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 0.25rem; display: block;">
                    Paste existing note to update with new VIOLIN data:
                </label>
                <textarea id="existingNote" placeholder="Paste existing ICU note here to update with new data...&#10;&#10;(Leave blank to generate new note with placeholder text)"></textarea>
                
                <div class="button-group">
                    <button class="success" onclick="updateNote()">üîÑ Update Existing Note</button>
                </div>
            </div>
        </div>

        <!-- Status Message -->
        <div id="statusMessage" class="status-message"></div>

        <!-- Output Section -->
        <div class="output-section" id="outputSection" style="display: none;">
            <h2>‚ú® Generated ICU Note</h2>
            <div class="note-output" id="noteOutput"></div>
            <div class="button-group" style="margin-top: 1rem;">
                <button onclick="copyNote()">üìã Copy to Clipboard</button>
                <button class="secondary" onclick="downloadNote()">üíæ Download Note</button>
            </div>
        </div>
    </div>

    <script>
        // ===== MEDICATION ABBREVIATION DATABASE =====
        const MED_ABBREVIATIONS = {
            // Pain medications
            'hydromorphone': 'D', 'dilaudid': 'D', 'oxycodone': 'O', 'morphine': 'M',
            'fentanyl': 'F', 'fentanyl citrate': 'F', 'acetaminophen': 'T', 'tylenol': 'T',
            'ibuprofen': 'Ibu', 'ketorolac': 'Toradol', 'toradol': 'Toradol',
            'tramadol': 'Tramadol', 'hydrocodone': 'Norco', 'meperidine': 'Demerol',
            
            // Antibiotics
            'cefepime': 'Cefepime', 'vancomycin': 'Vanc', 'piperacillin-tazobactam': 'Pip-Tazo',
            'piperacillin': 'Pip', 'tazobactam': 'Tazo', 'meropenem': 'Mero',
            'imipenem': 'Imi', 'ceftriaxone': 'CTX', 'ceftazidime': 'Ceftaz',
            'cefazolin': 'Ancef', 'azithromycin': 'Azithro', 'levofloxacin': 'Levo',
            'ciprofloxacin': 'Cipro', 'metronidazole': 'Flagyl', 'daptomycin': 'Dapto',
            'micafungin': 'Mica', 'caspofungin': 'Caspo', 'fluconazole': 'Fluc',
            'sulfamethoxazole-trimethoprim': 'TMP-SMX', 'linezolid': 'Zyvox',
            'clindamycin': 'Clinda', 'ampicillin': 'Amp', 'amoxicillin': 'Amox',
            'gentamicin': 'Gent', 'tobramycin': 'Tobra', 'doxycycline': 'Doxy',
            
            // Pressors/Sedation
            'norepinephrine': 'Levo', 'epinephrine': 'Epi', 'vasopressin': 'Vaso',
            'phenylephrine': 'Neo', 'dopamine': 'Dopa', 'dobutamine': 'Dobu',
            'milrinone': 'Milrinone', 'propofol': 'Prop', 'midazolam': 'Versed',
            'dexmedetomidine': 'Prec', 'lorazepam': 'Ativan', 'diazepam': 'Valium',
            'ketamine': 'Ketamine',
            
            // Anticoagulation
            'heparin': 'Hep', 'enoxaparin': 'Lovenox', 'warfarin': 'Coumadin',
            'apixaban': 'Eliquis', 'rivaroxaban': 'Xarelto', 'dabigatran': 'Pradaxa',
            'aspirin': 'ASA', 'clopidogrel': 'Plavix', 'ticagrelor': 'Brilinta',
            
            // GI medications
            'ondansetron': 'Zofran', 'pantoprazole': 'Protonix', 'famotidine': 'Pepcid',
            'omeprazole': 'Prilosec', 'esomeprazole': 'Nexium', 'lansoprazole': 'Prevacid',
            'docusate': 'Colace', 'senna': 'Senna', 'bisacodyl': 'Dulcolax',
            'polyethylene glycol': 'Miralax', 'metoclopramide': 'Reglan',
            
            // Cardio/Pulm
            'metoprolol': 'Metop', 'carvedilol': 'Coreg', 'labetalol': 'Labetalol',
            'lisinopril': 'Lisinopril', 'enalapril': 'Enalapril', 'losartan': 'Losartan',
            'amlodipine': 'Norvasc', 'diltiazem': 'Cardizem', 'nicardipine': 'Cardene',
            'hydralazine': 'Hydral', 'furosemide': 'Lasix', 'bumetanide': 'Bumex',
            'torsemide': 'Torsemide', 'spironolactone': 'Spiro',
            'albuterol': 'Albuterol', 'ipratropium': 'Atrovent', 'duoneb': 'DuoNeb',
            'amiodarone': 'Amio', 'digoxin': 'Dig', 'rosuvastatin': 'Crestor',
            'atorvastatin': 'Lipitor', 'simvastatin': 'Zocor',
            
            // Neuro/Psych
            'levetiracetam': 'Keppra', 'phenytoin': 'Dilantin', 'valproic acid': 'Depakote',
            'gabapentin': 'Neurontin', 'pregabalin': 'Lyrica', 'haloperidol': 'Haldol',
            'quetiapine': 'Seroquel', 'olanzapine': 'Zyprexa', 'trazodone': 'Trazodone',
            'cyclobenzaprine': 'Flexeril', 'baclofen': 'Baclofen', 'methocarbamol': 'Robaxin', 'clobazam': 'Clobazam', 'brivaracetam': 'Brivaracetam', 'lacosamide': 'Lacosamide', 
            
            // Endocrine
            'insulin lispro': 'Lispro', 'insulin aspart': 'Aspart',
            'insulin regular': 'Reg insulin', 'insulin glargine': 'Lantus',
            'levothyroxine': 'Synthroid', 'hydrocortisone': 'Solu-Cortef',
            'dexamethasone': 'Decadron', 'methylprednisolone': 'Solumedrol',
            'prednisone': 'Pred',
            
            // Others
            'potassium chloride': 'KCl', 'magnesium sulfate': 'Mag',
            'calcium gluconate': 'Ca gluconate', 'albumin': 'Albumin'
        };

        // ===== DATA EXTRACTION FUNCTIONS =====
        
        function extractLabValues(text) {
            const data = {
                vitals: {},
                labs: {},
                weight: null,
                intake: null,
                output: null,
                o2therapy: null,
                ventSettings: {}
            };

            // Extract weight
            const weightMatch = text.match(/Weight Measured:\s*([\d.]+)\s*kg/i);
            if (weightMatch) {
                data.weight = parseFloat(weightMatch[1]);
            }

            // Extract intake and output from summary
            const intakeMatch = text.match(/Total\s+Summary[\s\S]*?Intake\s*mL\s+([\d,]+(?:\.\d+)?)/i);
            if (intakeMatch) {
                data.intake = parseFloat(intakeMatch[1].replace(/,/g, ''));
            }

            const outputMatch = text.match(/Total\s+Summary[\s\S]*?Output\s*mL\s+([\d,]+(?:\.\d+)?)/i);
            if (outputMatch) {
                data.output = parseFloat(outputMatch[1].replace(/,/g, ''));
            }

            // Helper: parse timestamp and pick latest
            function parseTS(dateStr, timeStr) {
                const [mo, day, yr] = dateStr.split('/').map(n => parseInt(n, 10));
                const [h, m, s] = timeStr.split(':').map(n => parseInt(n, 10));
                return new Date(2000 + yr, mo - 1, day, h, m, s);
            }

            function pickLatest(regex, text) {
                const arr = [];
                let mm;
                while ((mm = regex.exec(text)) !== null) {
                    arr.push({
                        val: mm[1].trim(),
                        ts: parseTS(mm[2], mm[3])
                    });
                }
                if (!arr.length) return null;
                arr.sort((a, b) => a.ts - b.ts);
                return arr[arr.length - 1].val;
            }

            // Extract Oxygen Therapy (latest)
            const o2Entries = [];
            const o2Regex = /Oxygen Therapy:\s*(.+?)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            let m;
            while ((m = o2Regex.exec(text)) !== null) {
                o2Entries.push({
                    desc: m[1].trim(),
                    ts: parseTS(m[2], m[3])
                });
            }

            if (o2Entries.length) {
                o2Entries.sort((a, b) => a.ts - b.ts);
                const latest = o2Entries[o2Entries.length - 1];
                const rawLower = latest.desc.toLowerCase();

                if (/room air/i.test(rawLower)) {
                    data.o2therapy = 'RA';
                } else if (/invasive mechanical ventilator/i.test(rawLower)) {
                    data.o2therapy = 'Vent';
                } else if (/non-invasive mechanical ventilator/i.test(rawLower) || /bipap|cpap/i.test(rawLower)) {
                    data.o2therapy = 'BiPAP/CPAP';
                } else if (/high[- ]?flow nasal cannula/i.test(rawLower)) {
                    data.o2therapy = 'HFNC';
                } else if (/nasal cannula/i.test(rawLower) && !/high[- ]?flow/i.test(rawLower)) {
                    // Extract liters
                    const literMatch = latest.desc.match(/(\d+)\s*L/i);
                    if (literMatch) {
                        data.o2therapy = `${literMatch[1]}L NC`;
                    } else {
                        data.o2therapy = 'NC';
                    }
                } else if (/non-?rebreather/i.test(rawLower)) {
                    data.o2therapy = 'NRB';
                } else {
                    data.o2therapy = 'O2';
                }
            }

            // Extract ventilator settings if on vent
            if (data.o2therapy === 'Vent') {
                data.ventSettings.mode = pickLatest(/Ventilator Mode:\s*([^(]+)\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
                data.ventSettings.rate = pickLatest(/Ventilator Frequency(?:,\s*Mandatory)?:\s*(\d+)\s*br\/min\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
                data.ventSettings.tv = pickLatest(/Tidal Volume(?:,\s*Delivered)?:\s*(\d+)\s*mL\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
                data.ventSettings.peep = pickLatest(/Positive End Expiratory Pressure:\s*(\d+)\s*cmH2O\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
                data.ventSettings.fio2 = pickLatest(/FIO2:\s*(\d+)\s*%\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
            }

            // Extract vitals (last 24 hours)
            const now = new Date();
            const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
            
            function isWithin24Hours(dateStr, timeStr) {
                const parts = dateStr.split('/');
                const timeParts = timeStr.split(':');
                const dt = new Date(2000 + parseInt(parts[2]), parseInt(parts[0]) - 1, parseInt(parts[1]), 
                                   parseInt(timeParts[0]), parseInt(timeParts[1]), parseInt(timeParts[2]));
                return dt >= twentyFourHoursAgo && dt <= now;
            }
            
            // Extract temperature
            const tempRegex = /Temperature.*?:\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const tempValues = [];
            let tempMatch;
            while ((tempMatch = tempRegex.exec(text)) !== null) {
                if (isWithin24Hours(tempMatch[2], tempMatch[3])) {
                    tempValues.push(parseFloat(tempMatch[1]));
                }
            }
            if (tempValues.length > 0) {
                data.vitals.temp = tempValues;
            }
            
            // Extract heart rate
            const hrRegex = /Heart Rate.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const hrValues = [];
            let hrMatch;
            while ((hrMatch = hrRegex.exec(text)) !== null) {
                if (isWithin24Hours(hrMatch[2], hrMatch[3])) {
                    hrValues.push(parseInt(hrMatch[1]));
                }
            }
            if (hrValues.length > 0) {
                data.vitals.hr = hrValues;
            }
            
            // Extract O2 saturation
            const o2SatRegex = /O2 Saturation.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const o2Values = [];
            let o2Match;
            while ((o2Match = o2SatRegex.exec(text)) !== null) {
                if (isWithin24Hours(o2Match[2], o2Match[3])) {
                    o2Values.push(parseInt(o2Match[1]));
                }
            }
            if (o2Values.length > 0) {
                data.vitals.o2sat = o2Values;
            }

            // Extract MAP
            const mapRegex = /Mean\s+(?:Arterial\s+)?Pressure.*?:\s*(\d+)\s*mmHg.*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const mapValues = [];
            let mapMatch;
            while ((mapMatch = mapRegex.exec(text)) !== null) {
                if (isWithin24Hours(mapMatch[2], mapMatch[3])) {
                    mapValues.push(parseInt(mapMatch[1]));
                }
            }
            if (mapValues.length > 0) {
                data.vitals.map = mapValues;
            }

            // Extract lab values (use latest value)
            function extractLatestLab(pattern, name) {
                const regex = new RegExp(pattern + '.*?[<>]?\\s*([\\d.]+).*?\\((\\d{2}/\\d{2}/\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2})\\)', 'gi');
                let latestVal = null;
                let latestTS = null;
                let match;
                
                while ((match = regex.exec(text)) !== null) {
                    const val = parseFloat(match[1]);
                    const ts = parseTS(match[2], match[3]);
                    if (!latestTS || ts > latestTS) {
                        latestVal = val;
                        latestTS = ts;
                    }
                }
                
                if (latestVal !== null) {
                    data.labs[name] = latestVal;
                }
            }

            // Extract all labs (latest value only)
            extractLatestLab('WBC:', 'wbc');
            extractLatestLab('Hgb:', 'hgb');
            extractLatestLab('Hct:', 'hct');
            extractLatestLab('Platelet Count:', 'plt');
            extractLatestLab('Sodium:', 'na');
            extractLatestLab('Potassium:', 'k');
            extractLatestLab('Chloride:', 'cl');
            extractLatestLab('CO2:', 'co2');
            extractLatestLab('BUN:', 'bun');
            extractLatestLab('Creatinine:', 'cr');
            extractLatestLab('Glucose:', 'glu');
            extractLatestLab('(?:Calcium, Ionized|Ionized Calcium):', 'ca');
            extractLatestLab('Magnesium Level:', 'mg');
            extractLatestLab('(?:Inorganic Phosphorus|Phosphorus):', 'phos');
            extractLatestLab('Prothrombin Time:', 'pt');
            extractLatestLab('INR:', 'inr');
            extractLatestLab('(?:APTT|PTT):', 'ptt');

            // Extract glucose values for range
            const gluRegex = /Glucose:.*?[<>]?\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const gluValues = [];
            let gluMatch;
            while ((gluMatch = gluRegex.exec(text)) !== null) {
                gluValues.push(parseFloat(gluMatch[1]));
            }
            if (gluValues.length > 0) {
                data.labs.gluMin = Math.min(...gluValues);
                data.labs.gluMax = Math.max(...gluValues);
            }

            return data;
        }

        function extractMedicationsBySystem(text) {
            const meds = {
                neuro: [],
                pulm: [],
                cv: [],
                gi_ppx: [],
                gi_bowel: [],
                renal: [],
                anticoag: [],
                antibiotics: [],
                endo: [],
                other: []
            };

            // Find medications section
            let medsMatch = text.match(/Medications.*?\(\d+\)\s*Active\s*\n([\s\S]*?)(?=\n\s*\n|DIET ORDER:|$)/i);

            if (!medsMatch) {
                medsMatch = text.match(/(?:Scheduled:|PRN:|Continuous:)([\s\S]*?)(?=\n\s*\n|DIET ORDER:|$)/i);
            }

            if (!medsMatch) {
                return meds;
            }

            const medText = medsMatch[1];

            // Check for hypoglycemia protocol (all required components)
            const hasGlucagon = /glucagon.*?1\s*mg.*?Subcutaneous/i.test(medText);
            const hasGlucose40Oral15g = /glucose\s+40%.*?Oral.*?15\s*g/i.test(medText);
            const hasGlucose40Oral30g = /glucose\s+40%.*?Oral.*?30\s*g/i.test(medText);
            const hasDextrose10_20g = /Dextrose\s+10%.*?20\s*g.*?IV\s+Bolus/i.test(medText);
            const hasDextrose10_10g = /Dextrose\s+10%.*?10\s*g.*?IV\s+Bolus/i.test(medText);
            const hasDextrose10_250mL = /Dextrose\s+10%.*?250\s*mL.*?IV\s+Piggyback/i.test(medText);
            const hasDextrose10_1000mL = /Dextrose\s+10%.*?1,?000\s*mL.*?IV\s+Piggyback/i.test(medText);

            const hasHypoglycemiaProtocol = hasGlucagon && hasGlucose40Oral15g && hasGlucose40Oral30g &&
                                           hasDextrose10_20g && hasDextrose10_10g && hasDextrose10_250mL && hasDextrose10_1000mL;

            const medLines = medText.split('\n').filter(line => line.trim());
            let currentType = null;

            for (const line of medLines) {
                const trimmed = line.trim();
                if (!trimmed) continue;

                if (trimmed.match(/^Scheduled:/i)) {
                    currentType = 'scheduled';
                    continue;
                }
                if (trimmed.match(/^PRN:/i)) {
                    currentType = 'prn';
                    continue;
                }
                if (trimmed.match(/^Continuous:/i)) {
                    currentType = 'continuous';
                    continue;
                }

                // Skip hypoglycemia protocol individual lines if we detected the full protocol
                if (hasHypoglycemiaProtocol) {
                    const lineLower = trimmed.toLowerCase();
                    if (lineLower.includes('glucagon') ||
                        (lineLower.includes('glucose') && lineLower.includes('40%') && lineLower.includes('oral')) ||
                        (lineLower.includes('dextrose') && lineLower.includes('10%'))) {
                        continue;
                    }
                }

                const med = parseMedicationLine(trimmed, currentType);
                if (med) {
                    categorizeMed(med, meds);
                }
            }

            // Add hypoglycemia protocol as single entry if detected
            if (hasHypoglycemiaProtocol) {
                meds.endo.push('Hypoglycemia Protocol');
            }

            return meds;
        }

        function parseMedicationLine(line, medType) {
            const lineLower = line.toLowerCase();

            if (!line || line.length < 3) return null;

            // Check for insulin sliding scale
            if (lineLower.includes('insulin') && (lineLower.includes('lispro') || lineLower.includes('aspart') || lineLower.includes('regular'))) {
                // Look for sliding scale pattern like "0-20 units" or "0-10 units"
                const slidingScaleMatch = line.match(/0\s*-\s*(\d+)\s*units?/i);
                if (slidingScaleMatch) {
                    const maxUnits = parseInt(slidingScaleMatch[1]);
                    // Extract frequency
                    let frequency = '';
                    const freqMatch = line.match(/every\s+(\d+)\s+hours?/i);
                    if (freqMatch) {
                        frequency = ` Q${freqMatch[1]}H`;
                    }

                    // Add PRN if this is a PRN medication
                    if (medType === 'prn' && !frequency.includes('PRN')) {
                        frequency = frequency ? `${frequency} PRN` : ' PRN';
                    }

                    if (maxUnits > 10) {
                        return { name: `ISS-R${frequency}`, category: 'endo', fullName: 'Insulin Sliding Scale - Resistant' };
                    } else {
                        return { name: `ISS-N${frequency}`, category: 'endo', fullName: 'Insulin Sliding Scale - Normal' };
                    }
                }
            }

            // Check for traditional sliding scale wording
            if (lineLower.includes('insulin') && (lineLower.includes('sliding scale') || lineLower.includes('scale'))) {
                const issName = medType === 'prn' ? 'ISS PRN' : 'ISS';
                return { name: issName, category: 'endo', fullName: line };
            }

            // Check for continuous infusions (pressors, sedation)
            if (medType === 'continuous' || lineLower.includes('gtt')) {
                const match = line.match(/^([A-Za-z\-\s]+?)(?:\s+\d+|\s+IV|\s+continuous)/i);
                
                if (match) {
                    const drugName = match[1].trim();
                    const abbrev = abbreviateMedication(drugName);
                    
                    // Extract rate
                    let rate = '';
                    const rateMatch = line.match(/(\d+(?:\.\d+)?)\s*(mcg|mg|units?)(?:\/min|\/hr|\/kg\/min)?/i);
                    if (rateMatch) {
                        rate = ` ${rateMatch[1]}${rateMatch[2]}`;
                    }
                    
                    return { name: `${abbrev}${rate} gtt`, category: null, fullName: drugName };
                }
            }

            // Check for IV fluids with rates >40 cc/hr
            const fluidRateMatch = line.match(/(\d+)\s*(?:mL|cc)\/?hr/i);
            if (fluidRateMatch) {
                const rate = parseInt(fluidRateMatch[1]);
                
                if (rate > 40) {
                    if (lineLower.includes('lactated') || lineLower.includes('ringer')) {
                        return { name: `LR@${rate}`, category: 'renal', fullName: 'Lactated Ringers' };
                    } else if (lineLower.includes('sodium chloride') || lineLower.includes('0.9%') || lineLower.includes('normal saline') || lineLower.includes('nacl')) {
                        return { name: `NS@${rate}`, category: 'renal', fullName: 'Normal Saline' };
                    } else if (lineLower.includes('d5')) {
                        return { name: `D5@${rate}`, category: 'renal', fullName: 'D5 solution' };
                    }
                }
            }

            // Parse standard medication
            let drugName = '';
            
            const patterns = [
                /^([A-Za-z]+(?:-[A-Za-z]+)*(?:\s+[A-Za-z]+(?:-[A-Za-z]+)*)*?)\s+\d+/,
                /^([A-Za-z]+(?:-[A-Za-z]+)*(?:\s+[A-Za-z]+)*?)\s+(?:IV|PO|SL)/i,
                /^([A-Za-z]+(?:-[A-Za-z]+)*(?:\s+[A-Za-z]+)*?)\s+\(/,
            ];
            
            for (const pattern of patterns) {
                const match = line.match(pattern);
                if (match) {
                    drugName = match[1].trim();
                    break;
                }
            }
            
            if (!drugName) {
                const words = line.split(/\s+/);
                if (words[0]) {
                    drugName = words[0];
                    if (words.length >= 2 && words[1].match(/^[A-Za-z\-]+$/)) {
                        drugName = `${words[0]} ${words[1]}`;
                    }
                }
            }
            
            if (!drugName) return null;
            
            // Extract dose (skip concentrations)
            let dose = '';
            const allDoses = [];
            // Updated regex to handle numbers with commas or spaces (e.g., "1,000mg" or "1 000mg")
            const doseRegex = /(\d+(?:[,\s]\d+)*(?:\.\d+)?)\s*(mcg|mg|g|units?)\b/gi;
            let doseMatch;

            while ((doseMatch = doseRegex.exec(line)) !== null) {
                const afterDose = line.substring(doseMatch.index + doseMatch[0].length, doseMatch.index + doseMatch[0].length + 10);

                if (!afterDose.match(/^\s*\/\s*(mL|kg|min|hr)/i)) {
                    // Clean up the number by removing commas and spaces
                    const cleanNumber = doseMatch[1].replace(/[,\s]/g, '');
                    const unit = doseMatch[2];

                    // Convert large mg doses to grams for readability (e.g., 1000mg -> 1g)
                    if (unit === 'mg' && parseInt(cleanNumber) >= 1000 && parseInt(cleanNumber) % 1000 === 0) {
                        allDoses.push((parseInt(cleanNumber) / 1000) + 'g');
                    } else {
                        allDoses.push(cleanNumber + unit);
                    }
                }
            }
            
            if (allDoses.length > 0) {
                dose = allDoses[allDoses.length - 1];
            }

            // Extract route
            let route = '';
            const routeMatch = line.match(/\b(PO|IV|IM|Subcutaneous|SubQ|SL|Sublingual|PR|Rectal|Topical|Transdermal|Inhalation|Nasal|Ophthalmic|Otic|Oral|Injectable|Intravenous|IV Bolus|IV Piggyback|Intramuscular)\b/i);
            if (routeMatch) {
                let routeRaw = routeMatch[1];
                // Standardize route abbreviations
                if (/^Subcutaneous$/i.test(routeRaw) || /^SubQ$/i.test(routeRaw)) {
                    route = 'SC';
                } else if (/^Sublingual$/i.test(routeRaw)) {
                    route = 'SL';
                } else if (/^Rectal$/i.test(routeRaw)) {
                    route = 'PR';
                } else if (/^Oral$/i.test(routeRaw)) {
                    route = 'PO';
                } else if (/^Injectable$/i.test(routeRaw)) {
                    route = 'INJ';
                } else if (/^Intravenous$/i.test(routeRaw)) {
                    route = 'IV';
                } else if (/^IV Bolus$/i.test(routeRaw)) {
                    route = 'IV';
                } else if (/^IV Piggyback$/i.test(routeRaw)) {
                    route = 'IV';
                } else if (/^Intramuscular$/i.test(routeRaw)) {
                    route = 'IM';
                } else {
                    route = routeRaw.toUpperCase();
                }
            }

            // Extract frequency
            let frequency = '';
            let freqMatch = line.match(/\b(Q\d+H?|BID|TID|QID|QD|QHS|PRN)\b/i);
            if (freqMatch) {
                frequency = freqMatch[1].toUpperCase();
            } else {
                if (line.match(/\bdaily\b/i) || line.match(/once\s+(a|per)?\s*day/i)) {
                    frequency = 'QD';
                } else if (line.match(/4\s+times?\s+(a|per)?\s*day/i)) {
                    frequency = 'QID';
                } else if (line.match(/3\s+times?\s+(a|per)?\s*day/i)) {
                    frequency = 'TID';
                } else if (line.match(/(?:2\s+times?|twice)\s+(a|per)?\s*day/i)) {
                    frequency = 'BID';
                } else {
                    const everyMatch = line.match(/every\s+(\d+)\s+(?:hours?|hr)/i);
                    if (everyMatch) {
                        frequency = `Q${everyMatch[1]}H`;
                    } else if (line.match(/as\s+needed|when\s+needed/i)) {
                        frequency = 'PRN';
                    } else if (line.match(/at\s+bedtime/i)) {
                        frequency = 'QHS';
                    }
                }
            }

            // Ensure PRN medications are labeled as PRN
            if (medType === 'prn') {
                // If frequency doesn't already contain PRN, add it
                if (!frequency || !frequency.includes('PRN')) {
                    frequency = frequency ? `${frequency} PRN` : 'PRN';
                }
            }

            // Build medication string
            const abbrev = abbreviateMedication(drugName);
            let medString = abbrev;
            if (dose) medString += ` ${dose}`;
            if (route) medString += ` ${route}`;
            if (frequency) medString += ` ${frequency}`;

            return { name: medString, fullName: drugName, category: null };
        }

        function abbreviateMedication(drugName) {
            const nameLower = drugName.toLowerCase().trim();
            
            for (let [key, abbrev] of Object.entries(MED_ABBREVIATIONS)) {
                if (nameLower === key || nameLower.includes(key) || key.includes(nameLower)) {
                    return abbrev;
                }
            }
            
            return drugName.charAt(0).toUpperCase() + drugName.slice(1);
        }

        function categorizeMed(med, meds) {
            if (med.category) {
                meds[med.category].push(med.name);
                return;
            }

            const nameLower = (med.fullName || med.name).toLowerCase();

            // Pain meds and sedation -> neuro
            if (/hydromorphone|dilaudid|oxycodone|morphine|fentanyl|acetaminophen|tylenol|propofol|midazolam|versed|dexmedetomidine|precedex|prec|lorazepam|ativan|diazepam|ketamine|levetiracetam|keppra|gabapentin|neurontin|pregabalin|lyrica|phenytoin|dilantin|valproic|depakote|haloperidol|haldol|quetiapine|seroquel|olanzapine|zyprexa|trazodone|cyclobenzaprine|flexeril|baclofen|methocarbamol|robaxin/i.test(nameLower)) {
                meds.neuro.push(med.name);
            }
            // Pulmonary
            else if (/albuterol|ipratropium|atrovent|duoneb|combivent/i.test(nameLower)) {
                meds.pulm.push(med.name);
            }
            // Cardiac (includes pressors)
            else if (/norepinephrine|levophed|levo gtt|epinephrine|epi gtt|vasopressin|vaso gtt|phenylephrine|neo gtt|dopamine|dopa gtt|dobutamine|dobu gtt|metoprolol|carvedilol|coreg|labetalol|furosemide|lasix|bumetanide|bumex|torsemide|amiodarone|diltiazem|cardizem|nicardipine|cardene|atorvastatin|lipitor|rosuvastatin|crestor|simvastatin|lisinopril|enalapril|losartan|amlodipine|norvasc|hydralazine|milrinone/i.test(nameLower)) {
                meds.cv.push(med.name);
            }
            // GI PPX (PPI, H2 blocker, antiemetics)
            else if (/ondansetron|zofran|pantoprazole|protonix|famotidine|pepcid|omeprazole|prilosec|esomeprazole|nexium|lansoprazole|prevacid|metoclopramide|reglan/i.test(nameLower)) {
                meds.gi_ppx.push(med.name);
            }
            // GI Bowel reg
            else if (/docusate|colace|senna|bisacodyl|dulcolax|polyethylene glycol|miralax/i.test(nameLower)) {
                meds.gi_bowel.push(med.name);
            }
            // Anticoagulation
            else if (/heparin|enoxaparin|lovenox|warfarin|coumadin|apixaban|eliquis|rivaroxaban|xarelto|dabigatran|pradaxa|aspirin|asa|clopidogrel|plavix|ticagrelor|brilinta/i.test(nameLower)) {
                meds.anticoag.push(med.name);
            }
            // Antibiotics/Antifungals
            else if (/vancomycin|vanc|cefepime|piperacillin|pip-tazo|zosyn|meropenem|mero|imipenem|ceftriaxone|rocephin|ceftazidime|ceftaz|cefazolin|ancef|azithromycin|azithro|levofloxacin|levaquin|ciprofloxacin|cipro|metronidazole|flagyl|daptomycin|dapto|linezolid|zyvox|micafungin|mycamine|fluconazole|diflucan|sulfamethoxazole|trimethoprim|bactrim|tmp-smx|clindamycin|cleocin|ampicillin|amoxicillin|gentamicin|gent|tobramycin|tobra|doxycycline|doxy/i.test(nameLower)) {
                meds.antibiotics.push(med.name);
            }
            // Endocrine (insulin, steroids)
            else if (/insulin|lispro|humalog|aspart|novolog|glargine|lantus|regular insulin|nph|iss|sliding scale|levothyroxine|synthroid|liothyronine|cytomel|hydrocortisone|solu-cortef|dexamethasone|decadron|methylprednisolone|solumedrol|prednisone/i.test(nameLower)) {
                meds.endo.push(med.name);
            }
            // IV fluids and electrolytes -> renal
            else if (/normal saline|ns@|lactated|lr@|d5|nacl|potassium|kcl|magnesium|calcium|phosphorus/i.test(nameLower)) {
                meds.renal.push(med.name);
            }
            // Everything else
            else {
                meds.other.push(med.name);
            }
        }

        function extractDietOrder(text) {
            const dietMatch = text.match(/DIET ORDER:?\s*([^\n]+)/i);
            if (dietMatch) {
                return dietMatch[1].trim();
            }
            
            const dietPatterns = [
                /\bNPO\b/i,
                /clear liquid diet/i,
                /full liquid diet/i,
                /regular diet/i,
                /cardiac diet/i,
                /diabetic diet/i,
                /tube feed/i,
                /enteral/i
            ];

            for (const pattern of dietPatterns) {
                const match = text.match(pattern);
                if (match) {
                    return match[0];
                }
            }

            return null;
        }




        function extractUrinaryStatus(text) {
    // Helper to parse timestamp
    function parseTS(dateStr, timeStr) {
        const [mo, day, yr] = dateStr.split('/').map(n => parseInt(n, 10));
        const [h, m, s] = timeStr.split(':').map(n => parseInt(n, 10));
        return new Date(2000 + yr, mo - 1, day, h, m, s);
    }

    const urineEntries = [];

    // Look for "Urinary Catheter Output" entries (foley)
    const catheterRegex = /Urinary Catheter Output:.*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    let match;
    while ((match = catheterRegex.exec(text)) !== null) {
        urineEntries.push({
            method: 'foley',
            ts: parseTS(match[1], match[2])
        });
    }

    // Look for "Urine Voided" entries
    const voidedRegex = /Urine Voided:.*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = voidedRegex.exec(text)) !== null) {
        urineEntries.push({
            method: 'void',
            ts: parseTS(match[1], match[2])
        });
    }

    // Look for straight catheter entries (if they exist in your system)
    const straightCathRegex = /Straight\s+Cath(?:eter)?.*?Output:.*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = straightCathRegex.exec(text)) !== null) {
        urineEntries.push({
            method: 'straight cath',
            ts: parseTS(match[1], match[2])
        });
    }

    // If we found entries, get the latest one
    if (urineEntries.length > 0) {
        urineEntries.sort((a, b) => a.ts - b.ts);
        const latest = urineEntries[urineEntries.length - 1].method;

        if (latest === 'foley') {
            return 'foley*';
        } else if (latest === 'straight cath') {
            return 'straight cath*';
        } else {
            return 'void';
        }
    }

    // Fallback to default
    return 'void';
}

        function extractUrineOutputSince7AM(text, weight) {
            // Helper to parse timestamp
            function parseTS(dateStr, timeStr) {
                const [mo, day, yr] = dateStr.split('/').map(n => parseInt(n, 10));
                const [h, m, s] = timeStr.split(':').map(n => parseInt(n, 10));
                return new Date(2000 + yr, mo - 1, day, h, m, s);
            }

            // Get current time
            const now = new Date();

            // Calculate 7 AM cutoff
            let cutoffTime = new Date(now);
            cutoffTime.setHours(7, 0, 0, 0);

            // If current time is before 7 AM, use 7 AM yesterday
            if (now.getHours() < 7) {
                cutoffTime.setDate(cutoffTime.getDate() - 1);
            }

            const urineOutputEntries = [];

            // Look for "Urinary Catheter Output" entries with volumes
            const catheterRegex = /Urinary Catheter Output:\s*([\d.]+)\s*(?:mL|cc)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            let match;
            while ((match = catheterRegex.exec(text)) !== null) {
                const volume = parseFloat(match[1]);
                const ts = parseTS(match[2], match[3]);
                if (ts >= cutoffTime) {
                    urineOutputEntries.push({ volume, ts });
                }
            }

            // Look for "Urine Voided" entries with volumes
            const voidedRegex = /Urine Voided:\s*([\d.]+)\s*(?:mL|cc)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            while ((match = voidedRegex.exec(text)) !== null) {
                const volume = parseFloat(match[1]);
                const ts = parseTS(match[2], match[3]);
                if (ts >= cutoffTime) {
                    urineOutputEntries.push({ volume, ts });
                }
            }

            // Look for straight catheter entries with volumes
            const straightCathRegex = /Straight\s+Cath(?:eter)?.*?Output:\s*([\d.]+)\s*(?:mL|cc)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            while ((match = straightCathRegex.exec(text)) !== null) {
                const volume = parseFloat(match[1]);
                const ts = parseTS(match[2], match[3]);
                if (ts >= cutoffTime) {
                    urineOutputEntries.push({ volume, ts });
                }
            }

            // Sum up all volumes
            const totalOutput = urineOutputEntries.reduce((sum, entry) => sum + entry.volume, 0);

            // Calculate hours since 7 AM
            const hoursSince7AM = (now - cutoffTime) / (1000 * 60 * 60);

            // Calculate cc/kg/hr if weight is available
            let ccKgHr = null;
            if (weight && hoursSince7AM > 0) {
                ccKgHr = totalOutput / hoursSince7AM / weight;
            }

            return {
                totalOutput,
                hoursSince7AM,
                ccKgHr,
                cutoffTime
            };
        }
        
        // ===== PARSE EXISTING NOTE =====
        
        function parseExistingNote(noteText) {
            const sections = {};
            
            // Extract each section's Dx, Exam, Plan, etc.
            const sectionRegex = /^([A-Z\/]+):\s*$/gm;
            const sectionNames = [];
            let match;
            
            while ((match = sectionRegex.exec(noteText)) !== null) {
                sectionNames.push({
                    name: match[1],
                    start: match.index
                });
            }
            
            // Extract content for each section
            for (let i = 0; i < sectionNames.length; i++) {
                const section = sectionNames[i];
                const nextSection = sectionNames[i + 1];
                const endIndex = nextSection ? nextSection.start : noteText.length;
                const content = noteText.substring(section.start, endIndex);

                sections[section.name] = {
                    dx: extractField(content, /Dx:\s*(.+?)(?=\n|$)/),
                    exam: extractField(content, /Exam:\s*(.+?)(?=\n[A-Z]|$)/s),
                    access: extractField(content, /Access:\s*(.+?)(?=\n|$)/),
                    o2method: extractField(content, /O2 method:\s*(.+?)(?=\n|$)/),
                    nutrition: extractField(content, /Nutrition:\s*(.+?)(?=\n|$)/),
                    bowel: extractField(content, /Bowel reg:\s*(.+?)(?=\n|$)/),
                    plan: extractField(content, /Plan:\s*([\s\S]*?)(?=\n\s*\n|$)/)
                };

                // Extract section-specific medication fields
                if (section.name === 'GI') {
                    sections[section.name].meds = extractField(content, /GI ppx:\s*(.+?)(?=\n|$)/);
                } else if (section.name === 'RENAL/FLUIDS') {
                    sections[section.name].meds = extractField(content, /IVF:\s*(.+?)(?=\n|$)/);
                } else if (section.name === 'HEME') {
                    sections[section.name].meds = extractField(content, /DVT ppx:\s*(.+?)(?=\n|$)/);
                } else {
                    sections[section.name].meds = extractField(content, /Meds:\s*(.+?)(?=\n|$)/);
                }
            }
            
            // Extract DISPO/PT content
            const dispoMatch = noteText.match(/DISPO\/PT:\s*([\s\S]*?)$/);
            if (dispoMatch) {
                sections['DISPO/PT'] = { content: dispoMatch[1].trim() };
            }
            
            return sections;
        }
        
        function extractField(text, regex) {
            const match = text.match(regex);
            return match ? match[1].trim() : null;
        }

        // ===== NOTE GENERATION =====

        function generateNote() {
            const violinInput = document.getElementById('violinInput').value;

            if (!violinInput.trim()) {
                showStatus('Please paste VIOLIN data first!', 'error');
                return;
            }

            showStatus('Processing data and generating note...', 'success');

            try {
                const labData = extractLabValues(violinInput);
                const meds = extractMedicationsBySystem(violinInput);
                const dietOrder = extractDietOrder(violinInput);
                const urinaryStatus = extractUrinaryStatus(violinInput);
                const urineOutputData = extractUrineOutputSince7AM(violinInput, labData.weight);

                // Generate new note with placeholder text
                const note = buildICUNote(labData, meds, dietOrder, urinaryStatus, urineOutputData, null, null);

                document.getElementById('noteOutput').textContent = note;
                document.getElementById('outputSection').style.display = 'block';
                document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });

                showStatus('‚ú® Note generated successfully!', 'success');
            } catch (error) {
                console.error('Error generating note:', error);
                showStatus('‚ùå Error generating note: ' + error.message, 'error');
            }
        }

        function updateNote() {
            const violinInput = document.getElementById('violinInput').value;
            const existingNote = document.getElementById('existingNote').value;

            if (!violinInput.trim()) {
                showStatus('Please paste VIOLIN data first!', 'error');
                return;
            }

            if (!existingNote.trim()) {
                showStatus('Please paste existing note to update!', 'error');
                return;
            }

            showStatus('Updating note with new data...', 'success');

            try {
                const labData = extractLabValues(violinInput);
                const meds = extractMedicationsBySystem(violinInput);
                const dietOrder = extractDietOrder(violinInput);
                const urinaryStatus = extractUrinaryStatus(violinInput);
                const urineOutputData = extractUrineOutputSince7AM(violinInput, labData.weight);

                // Parse existing note to extract preserved sections
                const existingSections = parseExistingNote(existingNote);

                // Extract previous lab values for comparison
                const previousLabs = extractPreviousLabs(existingNote);

                const note = buildICUNote(labData, meds, dietOrder, urinaryStatus, urineOutputData, existingSections, previousLabs);

                document.getElementById('noteOutput').textContent = note;
                document.getElementById('outputSection').style.display = 'block';
                document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });

                showStatus('‚ú® Note updated successfully!', 'success');
            } catch (error) {
                console.error('Error updating note:', error);
                showStatus('‚ùå Error updating note: ' + error.message, 'error');
            }
        }

        function extractPreviousLabs(noteText) {
            const prevLabs = {};

            // Extract Hgb/Hct
            const hgbMatch = noteText.match(/Hgb\s+([\d.]+)/);
            if (hgbMatch) prevLabs.hgb = parseFloat(hgbMatch[1]);

            const hctMatch = noteText.match(/Hct\s+([\d.]+)/);
            if (hctMatch) prevLabs.hct = parseFloat(hctMatch[1]);

            // Extract WBC
            const wbcMatch = noteText.match(/WBC\s+([\d.]+)/);
            if (wbcMatch) prevLabs.wbc = parseFloat(wbcMatch[1]);

            // Extract PLT
            const pltMatch = noteText.match(/PLT\s+([\d]+)/);
            if (pltMatch) prevLabs.plt = parseInt(pltMatch[1]);

            // Extract INR
            const inrMatch = noteText.match(/INR\s+([\d.]+)/);
            if (inrMatch) prevLabs.inr = parseFloat(inrMatch[1]);

            return prevLabs;
        }

        function buildICUNote(labData, meds, dietOrder, urinaryStatus, urineOutputData, existingSections, previousLabs) {
            let note = '';
            
            const formatMeds = (medList) => {
                if (!medList || medList.length === 0) return 'none';
                const uniqueMeds = [...new Set(medList)];
                return uniqueMeds.join(', ');
            };

            // NEURO
            note += 'NEURO:\n';
            note += `Dx: ${existingSections?.NEURO?.dx || 'No Active Issues'}\n`;
            note += `Exam: ${existingSections?.NEURO?.exam || 'GCS 15 (E4V5M6), pain well controlled, strength and sensation intact BUE+BLE, CN II-XII grossly intact, PERRLA, EOMI'}\n`;
            note += `Meds: ${existingSections?.NEURO?.meds || formatMeds(meds.neuro)}\n`;
            note += `Plan: \n${existingSections?.NEURO?.plan || ''}\n\n`;

            // PULM
            note += 'PULM:\n';
            note += `Dx: ${existingSections?.PULM?.dx || 'No Active Issues'}\n`;
            note += `Exam: ${existingSections?.PULM?.exam || 'CTAB, regular rate, Satting >95%'}\n`;
            
            // O2 method line - preserve existing if updating, otherwise use new VIOLIN data
            let o2Method = 'O2 method: ';
            if (existingSections?.PULM?.o2method) {
                // Preserve existing O2 method when updating
                o2Method += existingSections.PULM.o2method;
            } else if (labData.o2therapy) {
                // Use new VIOLIN data for new notes
                o2Method += labData.o2therapy;

                // Add vent settings if applicable
                if (labData.o2therapy === 'Vent' && labData.ventSettings.mode) {
                    const vs = labData.ventSettings;
                    o2Method += ` ${vs.mode}`;
                    if (vs.rate) o2Method += ` ${vs.rate}`;
                    if (vs.tv) o2Method += `/${vs.tv}`;
                    if (vs.fio2) o2Method += `/${vs.fio2}`;
                    if (vs.peep) o2Method += `/${vs.peep}`;
                }
            } else {
                o2Method += 'RA';
            }
            note += o2Method + '\n';
            
            note += `Meds: ${existingSections?.PULM?.meds || formatMeds(meds.pulm)}\n`;
            note += `Plan: \n${existingSections?.PULM?.plan || ''}\n\n`;

            // CV
            note += 'CV:\n';
            note += `Dx: ${existingSections?.CV?.dx || 'No Active Issues'}\n`;
            
            let cvExam = 'Exam: ';
            if (labData.vitals.map) {
                const minMAP = Math.min(...labData.vitals.map);
                if (minMAP < 65) {
                    cvExam += `MAP ${minMAP}*, `;
                } else {
                    cvExam += `MAP>${minMAP}, `;
                }
            } else {
                cvExam += 'MAP>65, ';
            }
            cvExam += 'RRR, no edema, 2+ BL PT/DP, Radial/Ulnar pulses';
            note += cvExam + '\n';
            
            note += `Access: ${existingSections?.CV?.access || 'PIVs'}\n`;
           note += `Meds: ${existingSections?.CV?.meds || formatMeds(meds.cv)}\n`;
            note += `Plan: \n${existingSections?.CV?.plan || ''}\n\n`;

            // GI
            note += 'GI:\n';
            note += `Dx: ${existingSections?.GI?.dx || 'No Active Issues'}\n`;
            note += `Exam: ${existingSections?.GI?.exam || 'abd soft, non tender non distended, incisions c/d/i, BM:'}\n`;

            // Preserve existing nutrition when updating, otherwise use new dietOrder
            let nutritionValue = 'diet order';
            if (existingSections?.GI?.nutrition) {
                // Always preserve existing nutrition when updating
                nutritionValue = existingSections.GI.nutrition;
            } else if (dietOrder) {
                // Use new diet order for new notes
                nutritionValue = dietOrder;
            }
            note += `Nutrition: ${nutritionValue}\n`;

            note += `GI ppx: ${existingSections?.GI?.meds ? existingSections.GI.meds : formatMeds(meds.gi_ppx)}\n`;
            note += `Bowel reg/meds: ${existingSections?.GI?.bowel || formatMeds(meds.gi_bowel)}\n`;
            note += `Plan: \n${existingSections?.GI?.plan || ''}\n\n`;

            // RENAL/FLUIDS
            note += 'RENAL/FLUIDS:\n';
            note += `Dx: ${existingSections?.['RENAL/FLUIDS']?.dx || 'No Active Issues'}\n`;

            let renalExam = `Exam: ${urinaryStatus}, `;

            // Use urine output since 7 AM if available
            if (urineOutputData && urineOutputData.totalOutput > 0 && urineOutputData.ccKgHr !== null) {
                renalExam += `UOP ${Math.round(urineOutputData.totalOutput)} cc`;
                const ccKgHr = urineOutputData.ccKgHr.toFixed(1);
                if (parseFloat(ccKgHr) < 0.5) {
                    renalExam += ` (${ccKgHr} cc/kg/hr)*, `;
                } else {
                    renalExam += ` (${ccKgHr} cc/kg/hr), `;
                }
            } else if (labData.output && labData.weight) {
                // Fallback to 24-hour total if urine output since 7 AM is not available
                renalExam += `UOP ${Math.round(labData.output)} cc/24 hrs`;
                const ccKgHr = (labData.output / 24 / labData.weight).toFixed(1);
                if (parseFloat(ccKgHr) < 0.5) {
                    renalExam += ` (${ccKgHr} cc/kg/hr)*, `;
                } else {
                    renalExam += ` (${ccKgHr} cc/kg/hr), `;
                }
            }
            
            if (labData.intake) {
                renalExam += `I: ${Math.round(labData.intake)}mL, `;
            }
            if (labData.output) {
                renalExam += `O: ${Math.round(labData.output)}mL, `;
            }
            if (labData.intake && labData.output) {
                const balance = labData.intake - labData.output;
                const sign = balance >= 0 ? '+' : '';
                if (Math.abs(balance) > 1000) {
                    renalExam += `Fluid Bal: ${sign}${Math.round(balance)}mL*`;
                } else {
                    renalExam += `Fluid Bal: ${sign}${Math.round(balance)}mL`;
                }
            }
            note += renalExam + '\n';
            
            // Electrolytes
            let electroLine = 'Electrolytes: ';
            if (labData.labs.na) {
                const na = labData.labs.na;
                electroLine += `Na ${na < 135 || na > 145 ? na + '*' : na}, `;
            }
            if (labData.labs.k) {
                const k = labData.labs.k;
                electroLine += `K ${k < 3.5 || k > 5.0 ? k + '*' : k}, `;
            }
            if (labData.labs.cl) {
                electroLine += `Cl ${labData.labs.cl}, `;
            }
            if (labData.labs.co2) {
                electroLine += `CO2 ${labData.labs.co2}, `;
            }
            if (labData.labs.bun) {
                const bun = labData.labs.bun;
                electroLine += `BUN ${bun > 24 ? bun + '*' : bun}, `;
            }
            if (labData.labs.cr) {
                const cr = labData.labs.cr;
                electroLine += `Cr ${cr > 1.2 ? cr + '*' : cr}, `;
            }
            if (labData.labs.ca) {
                const ca = labData.labs.ca;
                electroLine += `Ca ${ca < 8.5 || ca > 10.2 ? ca + '*' : ca}, `;
            }
            if (labData.labs.mg) {
                const mg = labData.labs.mg;
                electroLine += `Mg ${mg < 1.7 || mg > 2.2 ? mg + '*' : mg}, `;
            }
            if (labData.labs.phos) {
                const phos = labData.labs.phos;
                electroLine += `Phos ${phos < 2.5 || phos > 4.5 ? phos + '*' : phos}`;
            }
            note += electroLine + '\n';
            
            note += `Meds/IVF: ${existingSections?.['RENAL/FLUIDS']?.meds || formatMeds(meds.renal)}\n`;
            note += `Plan: \n${existingSections?.['RENAL/FLUIDS']?.plan || ''}\n\n`;

            // HEME
            note += 'HEME:\n';
            note += `Dx: ${existingSections?.HEME?.dx || 'No Active Issues'}\n`;
            
            let labsLine = 'Labs: ';
            if (labData.labs.hgb) {
                const hgb = labData.labs.hgb;
                let hgbStr = hgb < 7 ? `Hgb ${hgb}*` : `Hgb ${hgb}`;

                // Show previous value if abnormal
                if (hgb < 7 && previousLabs?.hgb) {
                    hgbStr += ` (${previousLabs.hgb})`;
                }
                labsLine += hgbStr + ', ';
            }

            if (labData.labs.hct) {
                const hct = labData.labs.hct;
                let hctStr = hct < 21 ? `Hct ${hct}*` : `Hct ${hct}`;
                if (previousLabs?.hct) {
                    hctStr += ` (prev ${previousLabs.hct})`;
                }
                labsLine += hctStr + ', ';
            }

            if (labData.labs.plt) {
                const plt = labData.labs.plt;
                let pltStr = plt < 150 || plt > 400 ? `PLT ${plt}*` : `PLT ${plt}`;
                // Show previous value if abnormal
                if ((plt < 150 || plt > 400) && previousLabs?.plt) {
                    pltStr += ` (${previousLabs.plt})`;
                }
                labsLine += pltStr + ', ';
            }

            if (labData.labs.inr) {
                const inr = labData.labs.inr;
                let inrStr = inr > 1.1 ? `INR ${inr}*` : `INR ${inr}`;
                // Show previous value if abnormal
                if (inr > 1.1 && previousLabs?.inr) {
                    inrStr += ` (${previousLabs.inr})`;
                }
                labsLine += inrStr + ', ';
            }
            if (labData.labs.pt) {
                const pt = labData.labs.pt;
                labsLine += `PT ${pt > 13.5 ? pt + '*' : pt}, `;
            }
            if (labData.labs.ptt) {
                const ptt = labData.labs.ptt;
                labsLine += `PTT ${ptt > 35 ? ptt + '*' : ptt}`;
            }
            note += labsLine + '\n';
            
            note += `DVT ppx: ${existingSections?.HEME?.meds || formatMeds(meds.anticoag)}\n`;
            note += `Plan: \n${existingSections?.HEME?.plan || ''}\n\n`;

            // INFECTION
            note += 'INFECTION:\n';
            note += `Dx: ${existingSections?.INFECTION?.dx || 'No Active Issues'}\n`;
            note += 'Cx: None\n';
            
            let infectionLine = 'Exam: ';
            if (labData.labs.wbc) {
                const wbc = labData.labs.wbc;
                let wbcStr = wbc < 4.5 || wbc > 11 ? `WBC ${wbc}*` : `WBC ${wbc}`;
                // Show previous value if abnormal
                if ((wbc < 4.5 || wbc > 11) && previousLabs?.wbc) {
                    wbcStr += ` (${previousLabs.wbc})`;
                }
                infectionLine += wbcStr + ', ';
            }
            
            if (labData.vitals.temp && labData.vitals.temp.length > 0) {
                const tmax = Math.max(...labData.vitals.temp);
                infectionLine += `Tmax ${tmax > 38 ? tmax + '¬∞C*' : tmax + '¬∞C'}`;
            } else {
                infectionLine += 'Tmax';
            }
            note += infectionLine + '\n';
            
            note += `Meds: ${existingSections?.INFECTION?.meds || formatMeds(meds.antibiotics)}\n`;
            note += `Plan: \n${existingSections?.INFECTION?.plan || ''}\n\n`;

            // ENDO
            note += 'ENDO:\n';
            note += `Dx: ${existingSections?.ENDO?.dx || 'No Active Issues'}\n`;
            
            let bgLine = 'BG: ';
            if (labData.labs.gluMin && labData.labs.gluMax) {
                const gluMin = labData.labs.gluMin;
                const gluMax = labData.labs.gluMax;
                if (gluMin < 70 || gluMax > 200) {
                    bgLine += `${Math.round(gluMin)}-${Math.round(gluMax)}*`;
                } else {
                    bgLine += `${Math.round(gluMin)}-${Math.round(gluMax)}`;
                }
            } else {
                bgLine += 'blood glucose range';
            }
            note += bgLine + '\n';
            
            note += `Meds/TDDI: ${existingSections?.ENDO?.meds || formatMeds(meds.endo)}\n`;
            note += `Plan: \n${existingSections?.ENDO?.plan || ''}\n\n`;

            // SKIN/OTHER
            note += 'SKIN/OTHER:\n';
            note += `Dx: ${existingSections?.['SKIN/OTHER']?.dx || 'No Active Issues'}\n`;
            note += `Meds: ${existingSections?.['SKIN/OTHER']?.meds || formatMeds(meds.other)}\n`;
            note += 'Labs: 11/11 q12\n';
            note += `Plan: \n${existingSections?.['SKIN/OTHER']?.plan || ''}\n\n`;

            // DISPO/PT
            note += 'DISPO/PT:\n';
            note += `${existingSections?.['DISPO/PT']?.content || 'ICU, PTOT OOB'}\n`;

            return note;
        }

        // ===== UTILITY FUNCTIONS =====

        function showStatus(message, type) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = 'status-message show ' + type;
            
            setTimeout(() => {
                statusEl.classList.remove('show');
            }, 5000);
        }

        function copyNote() {
            const noteText = document.getElementById('noteOutput').textContent;
            
            navigator.clipboard.writeText(noteText).then(() => {
                showStatus('‚úÖ Note copied to clipboard!', 'success');
            }).catch(err => {
                console.error('Failed to copy:', err);
                showStatus('‚ùå Failed to copy note', 'error');
            });
        }

        function downloadNote() {
            const noteText = document.getElementById('noteOutput').textContent;
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `ICU_Note_${timestamp}.txt`;
            
            const blob = new Blob([noteText], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();
            window.URL.revokeObjectURL(url);
            
            showStatus('‚úÖ Note downloaded!', 'success');
        }

        function clearAll() {
            document.getElementById('violinInput').value = '';
            document.getElementById('existingNote').value = '';
            document.getElementById('outputSection').style.display = 'none';
            showStatus('üóëÔ∏è All fields cleared', 'success');
        }
    </script>
</body>
</html>
