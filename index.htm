<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Ultimate Patient List</title>
    
    <!-- Check if running as extension -->
    <script>
    let IS_EXTENSION = false;
    try {
        IS_EXTENSION = typeof chrome !== 'undefined' && chrome.storage && chrome.storage.sync;
    } catch (e) {
        IS_EXTENSION = false;
    }
    </script>


	
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #06b6d4;
            --danger: #ef4444;
            --success: #10b981;
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --card-hover: #333333;
            --border: #444444;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-1: #00e5ff;
            --accent-2: #f26363;
            --accent-3: #79e89f;
            --accent-4: #ffffff;
            --accent-5: #ff8000;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-primary);
            font-family: monospace;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--card-bg);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .census {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        .census-number {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem 2rem 1rem;
        }

        /* File Input */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 0.75rem 1.5rem;
            background: var(--card-bg);
            border: 2px dashed var(--primary);
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }






const VIOLIN_DASHBOARD_CSS = `
.violin-dashboard-container {
    overflow-x: auto;
    border-radius: 12px;
    border: 1px solid var(--border);
    background: var(--dark-bg);
    margin: 1rem 0;
}

.violin-dashboard-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;
}

.violin-dashboard-table thead {
    background: linear-gradient(135deg, var(--primary), var(--primary-dark));
    position: sticky;
    top: 0;
    z-index: 10;
}

.violin-dashboard-table th {
    padding: 1rem;
    text-align: center;
    font-weight: 700;
    color: white;
    border-bottom: 2px solid var(--primary);
}

.violin-dashboard-table th:first-child {
    text-align: left;
}

.violin-dashboard-table td {
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    color: var(--text-primary);
}

.violin-dashboard-table tbody tr {
    transition: background-color 0.2s ease;
}

.violin-dashboard-table tbody tr:hover {
    background: rgba(59, 130, 246, 0.05);
}

.violin-section-header {
    background: rgba(59, 130, 246, 0.05);
    padding: 0.75rem 1rem;
    color: var(--primary);
    font-weight: 700;
    border-bottom: 1px solid var(--border);
}

.lab-value {
    text-align: center;
    font-weight: 600;
    color: #60a5fa;
}

.lab-value.abnormal {
    background: rgba(220, 38, 38, 0.15);
    color: #ff6b6b;
    padding: 0.5rem;
    border-radius: 6px;
    font-weight: 700;
    box-shadow: inset 0 0 8px rgba(220, 38, 38, 0.1);
}

.lab-value.warning {
    background: rgba(245, 158, 11, 0.15);
    color: #fcd34d;
    padding: 0.5rem;
    border-radius: 6px;
    font-weight: 700;
    box-shadow: inset 0 0 8px rgba(245, 158, 11, 0.1);
}

.lab-value.normal {
    color: #6ee7b7;
}

.lab-reference {
    color: var(--text-secondary);
    font-size: 0.8rem;
    text-align: center;
}

.lab-trend {
    text-align: center;
    font-weight: 700;
    font-size: 1.1rem;
}

.trend-up {
    color: #dc2626;
}

.trend-down {
    color: #10b981;
}

.trend-stable {
    color: #64748b;
}
`;




















		.help-collapsible summary {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
}

.section-header {
  color: #1e40af; /* your blue */
  font-weight: bold;
  font-size: 1rem;
}

.section-check {
  transform: scale(1.2);
  margin-left: 8px;
  accent-color: #1e40af;
}




		

        .controls .file-input-label {
            padding: 0.75rem 1rem;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls .file-input-wrapper:hover .file-input-label {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        /* Controls */
  /* Controls */
.controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);  
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

/* Navigation buttons */
.nav-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);  /* Changed to exact 4-column grid */
    gap: 0.75rem;
    margin: 1rem 0;
}

        /* Buttons */
        button {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Select */
        select {
            background: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: inherit;
        }

     

      /* Fixed hover rule - removes border-left-color override */
		.row-item:hover {
		    background: var(--card-hover);
		    transform: translateX(5px);
		    /* border-left-color: var(--primary); ‚Üê REMOVED THIS LINE */
		    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
		    border-left-width: 6px; /* Keep the width increase on hover */
		}

        /* Colored Text */
        .colored-text-1 { color: var(--accent-1); }
        .colored-text-2 { color: var(--accent-2); }
        .colored-text-3 { color: var(--accent-3); }
        .colored-text-4 { color: var(--accent-4); }
        .colored-text-5 { color: var(--accent-5); }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            border: none;
        }

        .fab:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            margin: 5% auto;
            padding: 1.5rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }


.modal-content.large-modal {
    max-width: 95%;
    width: 95%;
    max-height: 90vh;
}


		#helpModal input[type="checkbox"] {
    cursor: pointer;
    transform: scale(1.1);
    transition: transform 0.2s ease;
}

#helpModal input[type="checkbox"]:hover {
    transform: scale(1.2);
}

#helpModal label:hover {
    transform: translateX(2px);
}

		


        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }



		#cropInterface {
    text-align: center;
}

#cropCanvas {
    display: block;
    margin: 0 auto;
}

.crop-instructions {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin: 0.5rem 0;
}
		

        /* Details View */
        .details-view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
            z-index: 1500;
            overflow-y: auto;
	     padding: 0.5rem; 
        }

        .details-header {
            background: var(--card-bg);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .sticky-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .view-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .view-button {
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-button.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        #editForm {
   		 padding: 0.5rem;
    		max-width: none;
    		margin: 0;
   		 width: 100%;
        }



        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
        }

        label {
            display: block;
            margin-top: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
        }



        .delete-button {
            background: linear-gradient(135deg, var(--danger), #dc2626);
        }

        /* Chart Check Mode Specific */
        .chart-check-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .warning-messages {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid var(--danger);
        }

        .warning-message {
            color: var(--danger);
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Search Container */
        .search-wrapper {
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .search-wrapper.expanded {
            margin-bottom: 4rem;
        }

        .search-container {
            display: flex;
            gap: 0.5rem;
            background: var(--card-bg);
            padding: 0.75rem;
            border-radius: 0.5rem;
            opacity: 0;
            transform: translateY(-10px);
            visibility: hidden;
            transition: all 0.3s ease;
            position: absolute;
            width: 100%;
            z-index: 10;
        }

        .search-container.active {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }

        #searchInput {
            flex: 1;
            padding: 0.5rem;
            background: var(--dark-bg);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
        }















		






















/* Help Modal */
.help-modal {
    display: none;
    position: fixed;
    z-index: 2500;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    animation: fadeIn 0.3s ease;
}

.help-modal-content {
    background: var(--card-bg);
    margin: 5% auto;
    padding: 2rem;
    border-radius: 1rem;
    width: 90%;
    max-width: 900px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    animation: slideIn 0.3s ease;
    position: relative;
}

.help-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border);
}

.help-modal-title {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary);
    margin: 0;
}

.help-modal-close {
    background: var(--danger);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.help-modal-close:hover {
    transform: scale(1.1);
    background: #dc2626;
}

.help-modal-body {
    font-size: 1rem;
    line-height: 1.6;
    color: var(--text-primary);
}

.help-modal-body ul {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.help-modal-body li {
    margin: 0.5rem 0;
}

.help-modal-body strong {
    color: var(--accent-4);
}

.help-modal-body a {
    color: var(--primary);
    text-decoration: none;
}

.help-modal-body a:hover {
    text-decoration: underline;
}

/* Custom scrollbar for modal */
.help-modal-content::-webkit-scrollbar {
    width: 12px;
}

.help-modal-content::-webkit-scrollbar-track {
    background: var(--dark-bg);
    border-radius: 6px;
}

.help-modal-content::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 6px;
}

.help-modal-content::-webkit-scrollbar-thumb:hover {
    background: var(--primary-dark);
}


















		
















		

textarea, input[type="text"] {
    width: 100%;
    padding: 0.75rem;
    background: var(--card-bg);
    color: var(--text-primary);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    font-size: 1rem;
    font-family: inherit;
    margin: 0.5rem 0 1rem;
    resize: none;
    transition: all 0.3s ease;
    overflow-y: hidden;  /* ‚Üê CHANGED FROM auto TO hidden */
    text-align: left;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
}
	    
/* Desktop view selector improvements - add this before the mobile media query */
.view-selector {
    display: grid;
    gap: 0.5rem;
    margin-top: 1rem;
    max-width: 600px;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(1,1fr);
    justify-content: center;
}

.view-button {
    padding: 0.6rem 1rem;
    background: var(--card-bg);
    border: 2px solid var(--border);
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.85rem;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 40px;
    white-space: nowrap;
}

.view-button:hover {
    border-color: var(--primary);
    background: var(--card-hover);
}

.view-button.active {
    background: var(--primary);
    border-color: var(--primary);
    color: white;
}






/* Column Selector Styles - MUST BE BEFORE MEDIA QUERIES */
.column-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.5rem;
    padding: 0.5rem;
    background: var(--dark-bg);
    border-radius: 0.5rem;
    margin-top: 0.5rem;
}

.column-button {
    padding: 0.5rem;
    background: var(--card-bg);
    border: 2px solid var(--border);
    border-radius: 0.25rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    font-size: 0.9rem;
    color: var(--text-primary);
    font-family: inherit;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.column-button:hover {
    border-color: var(--primary);
    background: var(--card-hover);
}

.column-button.selected {
    background: var(--success);
    border-color: var(--success);
    color: white;
    font-weight: bold;
}

/* Orders section */
.orders-section {
    background: var(--card-bg);
    padding: 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 0.9rem;
    border: 1px solid var(--border);
}

/* Table view */
.data-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    font-size: 0.85em;
    overflow-x: auto;
    display: block;
}

.data-table th,
.data-table td {
    padding: 8px;
    border: 1px solid var(--border);
    text-align: left;
    white-space: nowrap;
}

.data-table th {
    background: var(--card-bg);
    color: var(--accent-4);
    position: sticky;
    left: 0;
    z-index: 1;
}

.data-table tr:nth-child(even) {
    background: var(--card-bg);
}

/* Import textarea */
.import-textarea {
    width: 100%;
    min-height: 300px;
    background: var(--card-bg);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 10px;
    font-family: 'Courier New', monospace;
    border-radius: 5px;
    font-size: 0.9em;
}

.hidden {
    display: none !important;
}






/* Chart Check Mode Split Layout */
.chart-check-layout {
    display: flex;
    gap: 1rem;
    height: calc(100vh - 200px);
}

.chart-check-left {
    flex: 2;
    overflow-y: auto;
    padding-right: 1rem;
}

.chart-check-right {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--card-bg);
    border-radius: 0.5rem;
    padding: 1rem;
    border: 2px solid var(--primary);
}

.chart-check-right h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
}

.chart-check-right textarea {
    flex: 1;
    resize: none;
    background: var(--dark-bg);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    padding: 0.75rem;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.9rem;
}









.help-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: var(--secondary);
    color: white;
    border: none;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 0.65rem;
    margin-left: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
    padding: 0;
    line-height: 1;
    font-family: monospace;
    vertical-align: middle;
}


		

.help-button:hover {
    background: var(--primary);
    transform: scale(1.05);
}








		








/* Mobile-specific help button adjustments */
@media (max-width: 768px) {
    .help-button {
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
        max-width: 20px;
        max-height: 20px;
        font-size: 0.7rem;
        margin-left: 4px;
    }
}



/* FIX: Force left alignment for details view form elements */
  #editForm label,
  #editForm input[type="text"],
  #editForm textarea,
  #editForm .violin-field,
  #editForm div[contenteditable="true"] {
    text-align: left !important;
  }
  
  /* Also ensure labels are properly left-aligned */
  .details-view label {
    text-align: left !important;
    display: block;
  }
  
  /* Fix chart check layout text alignment */
  .chart-check-left label,
  .chart-check-left input,
  .chart-check-left textarea,
  .chart-check-left .violin-field,
  .chart-check-right textarea {
    text-align: left !important;
  }









/* Chart Check Mode Colorful Borders */
.chart-check-left input[type="text"],
.chart-check-left textarea {
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.chart-check-left label:nth-of-type(1) + input,
.chart-check-left label:nth-of-type(1) + textarea {
    border-color: var(--accent-1);
    box-shadow: 0 0 0 1px rgba(0, 229, 255, 0.2);
}

.chart-check-left label:nth-of-type(2) + input,
.chart-check-left label:nth-of-type(2) + textarea {
    border-color: var(--accent-2);
    box-shadow: 0 0 0 1px rgba(242, 99, 99, 0.2);
}

.chart-check-left label:nth-of-type(3) + input,
.chart-check-left label:nth-of-type(3) + textarea {
    border-color: var(--accent-3);
    box-shadow: 0 0 0 1px rgba(121, 232, 159, 0.2);
}

.chart-check-left label:nth-of-type(4) + input,
.chart-check-left label:nth-of-type(4) + textarea {
    border-color: var(--accent-4);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);
}

.chart-check-left label:nth-of-type(5) + input,
.chart-check-left label:nth-of-type(5) + textarea {
    border-color: var(--accent-5);
    box-shadow: 0 0 0 1px rgba(255, 128, 0, 0.2);
}

.chart-check-left label:nth-of-type(6) + input,
.chart-check-left label:nth-of-type(6) + textarea {
    border-color: var(--primary);
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2);
}

.chart-check-left label:nth-of-type(7) + input,
.chart-check-left label:nth-of-type(7) + textarea {
    border-color: var(--secondary);
    box-shadow: 0 0 0 1px rgba(6, 182, 212, 0.2);
}

.chart-check-left label:nth-of-type(8) + input,
.chart-check-left label:nth-of-type(8) + textarea {
    border-color: var(--success);
    box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.2);
}

.chart-check-left input[type="text"]:focus,
.chart-check-left textarea:focus {
    box-shadow: 0 0 0 2px currentColor !important;
}

/* Right panel textarea gets a special color too */
.chart-check-right textarea {
    border-color: var(--primary) !important;
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3) !important;
}

.chart-check-right textarea:focus {
    box-shadow: 0 0 0 2px var(--primary) !important;
}








@media (max-width: 768px) {
    .chart-check-layout {
        flex-direction: column;
        height: auto;
    }
    
    .chart-check-left {
        padding-right: 0;
    }
    
    .chart-check-right {
        margin-top: 1rem;
        max-height: 300px;
    }
}



  


	    /* ===== TABLET AND MOBILE STYLES ===== */
@media (max-width: 768px) {
  /* MAIN PAGE BUTTON GRIDS ‚Äì 2-column snap grid */
  .controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    padding: 0.5rem;
    background: rgba(30, 30, 30, 0.2);
  }
  .controls > * {
    width: 100%;
  }
  .controls button,
  .controls .file-input-label,
  .controls select {
    padding: 0.4rem 0.3rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    justify-content: center;
  }




	.violin-button-container {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 0.25rem !important;
    margin: 0.5rem 0 !important;
    width: 100% !important;
  }
  
  .violin-button-container button {
    padding: 0.4rem 0.2rem !important;
    font-size: 0.7rem !important;
    margin: 0 !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }
	






  /* NAV BUTTONS ‚Äì leave as 2√ó2 */
  .nav-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.4rem;
    margin: 1rem 0;
    padding: 0.5rem;
    background: rgba(30, 30, 30, 0.3);
    border: 1px solid var(--border);
    border-radius: 0.5rem;
  }
	
input[type="text"],
input[type="number"],
input[type="email"],
input[type="tel"],
input[type="password"],
input[type="search"],
input,
textarea,
select,


  /* Universal mobile button styling */
  button,
  .file-input-label {
    padding: 0.7rem 0.5rem;
    font-size: 0.8rem;
    min-height: 44px;
    border-radius: 0.3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  select {
    min-height: 44px;
    padding: 0.7rem;
    font-size: 0.8rem;
  }

  /* MODAL BUTTON GRIDS */
  #entryTypeSelection .nav-buttons { grid-template-columns: 1fr; grid-template-rows: repeat(3,1fr); }
  .modal-content .nav-buttons   { grid-template-columns: 1fr; grid-template-rows: repeat(2,1fr); }
  #consultControls .nav-buttons   { grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr); }
  .chart-check-controls           { display: grid; grid-template-columns: 1fr; grid-template-rows: repeat(3,1fr); gap:0.4rem; margin:1rem 0; }

.details-header {
    padding: 0.75rem;
    position: sticky;  /* Changed from relative to sticky */
    top: 0;           /* Add this to ensure it sticks to top */
    z-index: 100;     /* Add this to ensure it stays above content */
    background: var(--card-bg);
    border-bottom: 1px solid var(--border);
  }

	
  .sticky-text {
    font-size: 1.2rem;
    margin-bottom: 0.5rem;
  }

/* MOBILE VIEW SELECTOR */
.view-selector {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.3rem;
  margin-top: 0.5rem;
  width: 100%;
  padding: 0.4rem;
  background: rgba(30, 30, 30, 0.2);

  /* remove any fixed height so it will shrink-wrap to its contents */
  height: auto;
  /* you can also drop grid-template-rows entirely‚Äîit defaults to one auto-sized row */
}

/* make the buttons small and equal-height */
.view-button {
  padding: 0.25rem;
  font-size: 0.7rem;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  display: flex;
  align-items: center;
  justify-content: center;

  border-radius: 0.25rem;
  box-sizing: border-box;

  /* fix the height to something compact */
  height: 30px;
  /* let width fill its grid cell evenly */
  width: 100%;
}


  /* REST OF MOBILE FORM & TABLE STYLES (unchanged) */
  #editForm {
    padding: 1rem 1rem 0;
    max-width: 100%;
    margin: 0;
  }



	textarea, input[type="text"] {
        font-size: 16px;
        padding: 0.75rem;
        margin: 0.25rem 0 0.75rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        overflow-y: hidden;  /* ‚Üê CHANGED FROM auto TO hidden */
    }

.violin-field {
    font-size: 16px !important;
  }
  
	

  label {
    margin-top: 0.5rem;
    font-size: 0.85rem;
  }
  label button {
    margin-top: 0.5rem;
    width: 100%;
    padding: 0.5rem;
    font-size: 0.8rem;
  }
  .modal-content {
    margin: 2% auto;
    width: 95%;
    padding: 1rem;
    max-height: 95vh;
  }
  .search-container {
    flex-direction: column;
    gap: 0.25rem;
  }
  #searchInput {
    margin-bottom: 0.25rem;
  }
  .column-selector {
    grid-template-columns: repeat(3,1fr);
    gap: 0.25rem;
  }
  .column-button {
    padding: 0.5rem 0.25rem;
    font-size: 0.8rem;
    min-height: 40px;
  }
 
  .fab {
    bottom: 1rem;
    right: 1rem;
    width: 50px;
    height: 50px;
    font-size: 1.5rem;
  }
  .header {
    padding: 0.75rem;
  }
  .census-number {
    font-size: 1.5rem;
  }
  .container {
    padding: 0 0.75rem 2rem;
  }
  .warning-messages {
    padding: 0.75rem;
    margin-bottom: 1rem;
    font-size: 0.9rem;
  }
  .warning-message {
    font-size: 0.95rem;
    margin-bottom: 0.25rem;
  }
  .orders-section {
    padding: 0.75rem;
    font-size: 0.85rem;
    margin-bottom: 0.75rem;
  }
  .data-table {
    font-size: 0.75rem;
    display: block;
    width: 100%;
    overflow-x: auto;
    white-space: nowrap;
  }
  .data-table th,
  .data-table td {
    padding: 0.5rem 0.25rem;
    min-width: 80px;
  }
  .import-textarea {
    min-height: 200px;
    font-size: 0.85rem;
  }
}






		


		/* Fishbone display container */
.fishbone-display {
    background: var(--card-bg);
    border: 2px solid var(--secondary);
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    font-family: monospace;
    font-size: 0.9rem;
    line-height: 1.6;
    white-space: pre-wrap;
    color: var(--text-primary);
}

.fishbone-display.hidden {
    display: none;
}

.fishbone-display h4 {
    color: var(--secondary);
    margin: 0 0 0.5rem 0;
    font-size: 1rem;
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .fishbone-display {
        /* Remove this line too: */
        /* max-height: 300px; */
        font-size: 0.85rem;
        padding: 0.75rem;
    }

	
}


		/* Mobile touch improvements */
#cropCanvas {
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

/* Improve button sizing for mobile */
@media (max-width: 768px) {
    #cameraEntrySection button {
        min-height: 44px;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
    }
    
    #cropInterface button {
        min-height: 44px;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
        margin: 0.25rem;
    }
}













/* Replace the existing .status-dot CSS (around line 2818 in your HTML) with this: */

.status-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    transition: all 0.3s ease;
    border: 2px solid currentColor;
    position: relative;
    cursor: pointer;
   
}












/* Force clean status dots - add this at the very end of your CSS */
.status-dot {
    box-shadow: none !important;
    border: none !important;
    outline: none !important;
    -webkit-box-shadow: none !important;
    -moz-box-shadow: none !important;
}

		



/* First three rows button styling */
.first-three-btn {
    transition: all 0.2s ease;
    font-size: inherit !important; /* Match parent font size */
    font-family: inherit !important; /* Match parent font family */
    line-height: inherit !important; /* Match parent line height */
}

.first-three-btn span {
    font-size: inherit !important; /* Ensure spans inherit the size */
    font-family: inherit !important;
    line-height: inherit !important;
}

.first-three-btn:hover {
    background: var(--card-hover) !important;
    border-color: var(--primary) !important;
}

.first-three-btn.copied {
    background: var(--success) !important;
    border-color: var(--success) !important;
}



@media (max-width: 768px) {
    /* ... existing mobile styles ... */
    
    /* Compact first three button spans - keep separate lines but reduce height */
    .first-three-btn {
        white-space: normal !important;
        text-align: left !important;
        line-height: 1.1 !important;
        height: auto !important;
        min-height: 44px !important;  /* Reduced from 60px */
        padding: 0.3rem 0.4rem !important;  /* Much less padding */
        display: flex !important;
        flex-direction: column !important;
        align-items: flex-start !important;
    }
    
    .first-three-btn span {
        display: block !important;
        width: 100% !important;
        line-height: 1.1 !important;  /* Tighter line height */
        margin-bottom: 1px !important;  /* Minimal spacing between lines */
        white-space: normal !important;
        word-wrap: break-word !important;
    }
    
 
}





















		/* Fixed Chart Check Tab Navigation */
.chart-check-tab-nav {
    display: flex;
    flex-direction: column;
    background: var(--card-bg);
    border-radius: 0.5rem 0.5rem 0 0;
    padding: 0.5rem;
    border-bottom: 2px solid var(--border);
    gap: 0.5rem;
}

.chart-check-tab-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 0.5rem;
}

.chart-check-tab-arrow {
    background: var(--primary);
    color: white;
    border: none;
    border-radius: 0.25rem;
    width: 32px;
    height: 32px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    transition: all 0.3s ease;
    font-size: 1rem;
}

.chart-check-tab-arrow:hover:not(:disabled) {
    background: var(--primary-dark);
    transform: scale(1.05);
}

.chart-check-tab-arrow:disabled {
    background: var(--border);
    cursor: not-allowed;
    transform: none;
    opacity: 0.5;
}

.chart-check-tab-title {
    flex: 1;
    text-align: center;
    font-weight: bold;
    color: var(--primary);
    font-size: 1.1rem;
    padding: 0.5rem;
}

.chart-check-tab-counter {
    background: var(--secondary);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 1rem;
    font-size: 0.8rem;
    font-weight: bold;
}

.chart-check-tab-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 0.25rem;
}

.chart-check-tab-button {
    background: var(--card-hover);
    color: var(--text-primary);
    border: 2px solid var(--border);
    border-radius: 0.375rem;
    padding: 0.5rem 0.25rem;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.8rem;
    font-weight: 500;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 40px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.chart-check-tab-button:hover {
    border-color: var(--primary);
    background: var(--primary);
    color: white;
    transform: translateY(-1px);
}

.chart-check-tab-button.active {
    background: var(--primary);
    border-color: var(--primary);
    color: white;
    font-weight: bold;
    box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .chart-check-tab-nav {
        padding: 0.25rem;
        gap: 0.25rem;
    }
    
    .chart-check-tab-header {
        gap: 0.25rem;
    }
    
    .chart-check-tab-arrow {
        width: 28px;
        height: 28px;
        font-size: 0.9rem;
    }
    
    .chart-check-tab-title {
        font-size: 0.95rem;
        padding: 0.25rem;
    }
    
    .chart-check-tab-counter {
        font-size: 0.7rem;
        padding: 0.2rem 0.4rem;
    }
    
    .chart-check-tab-buttons {
        gap: 0.2rem;
    }
    
    .chart-check-tab-button {
        padding: 0.4rem 0.2rem;
        font-size: 0.7rem;
        min-height: 36px;
    }
}
		


/* Chart Check Mode Colorful Borders */
.chart-check-left label:nth-of-type(1) + input,
.chart-check-left label:nth-of-type(1) + textarea {
    border-color: #your-new-color-1;
    box-shadow: 0 0 0 1px rgba(your-rgba-values, 0.2);
}

.chart-check-left label:nth-of-type(2) + input,
.chart-check-left label:nth-of-type(2) + textarea {
    border-color: #your-new-color-2;
    box-shadow: 0 0 0 1px rgba(your-rgba-values, 0.2);
}

.chart-check-left label:nth-of-type(3) + input,
.chart-check-left label:nth-of-type(3) + textarea {
    border-color: #your-new-color-3;
    box-shadow: 0 0 0 1px rgba(your-rgba-values, 0.2);
}

.chart-check-left label:nth-of-type(4) + input,
.chart-check-left label:nth-of-type(4) + textarea {
    border-color: #your-new-color-4;
    box-shadow: 0 0 0 1px rgba(your-rgba-values, 0.2);
}


		




/* Priority Color Variables - Red to Blue Gradient (Excluding Green) */
.priority-0 { --priority-color: #00ff41; } /* Complete - Keep bright green */
.priority-1 { --priority-color: #ff0000; } /* Urgent - Bright red */
.priority-2 { --priority-color: #ff2400; } /* High - Red-orange */
.priority-3 { --priority-color: #ff4900; } /* Medium-High - Orange */
.priority-4 { --priority-color: #ff6d00; } /* Medium - Orange-yellow */
.priority-5 { --priority-color: #ff9200; } /* Medium-Low - Yellow */
.priority-6 { --priority-color: #ffb600; } /* Low-Medium - Dark yellow */
.priority-7 { --priority-color: #ffdb00; } /* Low - Light blue */
.priority-8 { --priority-color: #ffff00; } /* Very Low - Blue */
.priority-9 { --priority-color: #800080; } /* Minimal - Dark blue */
.priority-10 { --priority-color: #bf00bf; } /* Lowest - Deep blue */
.priority-default { --priority-color: #444444; } /* No priority - Dark gray */


		
.row-item {
    position: relative;
    border-left: 4px solid var(--priority-color, #444444);
    transition: all 0.3s ease, border-left-width 0.3s ease;
    display: grid;
    grid-template-columns: 1fr 8px;
    min-height: 60px;
    gap: 1rem;
}

.row-item-content {
    grid-column: 1;
    padding: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.priority-sidebar {
    grid-column: 2;
    background: var(--priority-color, #444444);
    border-radius: 0 0.5rem 0.5rem 0;
    cursor: pointer;
    transition: all 0.3s ease;
    z-index: 10;
}


		


















		/* === Scoped help styling inside the existing modal body === */
.help-modal-body .help-section { color: var(--text-primary); background: transparent; line-height: 1.55; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }

/* Section chips (bold headers) */
.help-modal-body .section-header {
  display: inline-block; font-weight: 800; letter-spacing: .2px;
  padding: 6px 10px; border-radius: 999px; margin: 8px 0 12px;
  background: #111827; border: 1px solid #374151; color: #fff;
}

/* Color accents by tag */
.help-modal-body .section-header[data-tag="problems"]{ box-shadow: inset 0 0 0 9999px rgba(96,165,250,.18); border-color: rgba(96,165,250,.38); }
.help-modal-body .section-header[data-tag="ros"]     { box-shadow: inset 0 0 0 9999px rgba(52,211,153,.18); border-color: rgba(52,211,153,.38); }
.help-modal-body .section-header[data-tag="pmh"]     { box-shadow: inset 0 0 0 9999px rgba(245,158,11,.18); border-color: rgba(245,158,11,.38); }
.help-modal-body .section-header[data-tag="meds"]    { box-shadow: inset 0 0 0 9999px rgba(167,139,250,.18); border-color: rgba(167,139,250,.38); }
.help-modal-body .section-header[data-tag="allg"]    { box-shadow: inset 0 0 0 9999px rgba(244,114,182,.18); border-color: rgba(244,114,182,.38); }
.help-modal-body .section-header[data-tag="cex"]     { box-shadow: inset 0 0 0 9999px rgba(248,113,113,.18); border-color: rgba(248,113,113,.38); }
.help-modal-body .section-header[data-tag="trauma"]  { box-shadow: inset 0 0 0 9999px rgba(244,63,94,.18);  border-color: rgba(244,63,94,.38);  }

/* Collapsible groups */
.help-modal-body .help-collapsible { background: #0f172a; border: 1px solid #27324a; border-radius: 10px; padding: 8px 10px; margin: 10px 0; }
.help-modal-body .help-collapsible summary { cursor: pointer; font-weight: 800; color: var(--text-primary); outline: none; }
.help-modal-body .help-collapsible[open] { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,.15) inset; }

/* Topic chip + lists + subnote */
.help-modal-body .topic-header { font-weight: 800; display: inline-block; margin: 6px 0 4px; padding: 2px 8px; border-radius: 9px; background: #152036; color: #fca5a5; border: 1px solid #2a3a62; }
.help-modal-body ul { margin: 6px 0 10px 1.1rem; }
.help-modal-body li { margin: 4px 0; }
.help-modal-body .subnote { color: var(--text-secondary, #9ca3af); font-size: .9em; }

		






/* Chart Check Mode Split Layout */
.chart-check-layout {
    display: flex;
    gap: 1rem;
    height: calc(100vh - 250px);
    border: 3px solid var(--border);
    border-radius: 0.5rem;
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
    padding: 1rem;
    background: var(--card-bg);
}

.chart-check-left-panel {
    flex: 2;
    overflow-y: auto;
    padding-right: 1rem;
    border-right: 1px solid var(--border);
}

.chart-check-right-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--dark-bg);
    border-radius: 0.5rem;
    padding: 1rem;
    border: 2px solid var(--primary);
}

.chart-check-right-panel h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
}

.chart-check-right-panel textarea {
    flex: 1;
    resize: none;
    background: var(--dark-bg);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    padding: 0.75rem;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.9rem;
}

.chart-check-field-checkbox {
    width: 18px;
    height: 18px;
    margin-left: 0.5rem;
    cursor: pointer;
    accent-color: var(--primary);
    vertical-align: middle;
}

@media (max-width: 768px) {
    .chart-check-layout {
        flex-direction: column;
        height: auto;
    }
    
    .chart-check-left-panel {
        padding-right: 0;
        border-right: none;
        border-bottom: 1px solid var(--border);
        padding-bottom: 1rem;
    }
    
    .chart-check-right-panel {
        margin-top: 1rem;
        max-height: 300px;
    }
}




		
    </style>
</head>






	<!-- Replace the existing Tesseract script tag with this updated one -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
	
<script>
// Simple function to check if Tesseract is available
function isTesseractAvailable() {
    return typeof Tesseract !== 'undefined';
}

// Test function for OCR availability
async function testOCRAvailability() {
    if (!isTesseractAvailable()) {
        throw new Error('Tesseract.js not loaded');
    }
    
    try {
        // Create a simple test canvas with text
        const canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 50;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 50);
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText('TEST', 50, 30);
        
        const imageData = canvas.toDataURL();
        const { data: { text } } = await Tesseract.recognize(imageData, 'eng');
        
        return text.toLowerCase().includes('test');
    } catch (error) {
        console.error('OCR test failed:', error);
        return false;
    }
}
</script>




	
<body>
    <!-- Header with Census -->
    <div class="header">
        <div class="header-content">
            <div class="census">
                Census: <span class="census-number" id="censusCount">0</span>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Controls -->
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".json,.csv">
                <label for="fileInput" class="file-input-label">
                    üìÅ Import
                </label>
            </div>
            <button onclick="toggleColumnDropdown()">Column Options</button>
            <select id="columnSelect" onchange="sortRows()">
                <option value="">Sort by</option>
            </select>
               <button id="resortBtn" onclick="reSort()" style="display: none;">‚Üª Re-sort</button>
            <button onclick="toggleSearch()">üîç</button>
            <button id="exportButtonMain" onclick="exportData()">Export</button>
        </div>

        <!-- Column Dropdown -->
        <div id="columnDropdown" style="display: none;">
            <div id="columnSelector" class="column-selector"></div>
        </div>

        <!-- Search Container -->
        <div class="search-wrapper">
            <div id="searchContainer" class="search-container">
                <input type="text" id="searchInput" placeholder="Search entries..." />
                <button onclick="searchRows()">Search</button>
                <button onclick="clearSearch()">Clear</button>
            </div>
        </div>

        <!-- Row List -->
        <ul class="row-list" id="rowList"></ul>

        <!-- Floating Action Button -->
        <button class="fab" onclick="showAddEntryModal()">+</button>

       <!-- Add Entry Modal -->
<div id="addEntryModal" class="modal">
    <div class="modal-content">
        <h2>Add New Entry</h2>
        
        <div id="entryTypeSelection" class="nav-buttons">
            <button type="button" onclick="showManualEntry()">Manual Entry</button>
            <button type="button" onclick="showPasteEntry()">Paste Entry</button>
            <button type="button" onclick="showUpdatePatientsSection()">üîÑ Update Patients</button>
            <button type="button" onclick="closeAddEntryModal()">Cancel</button>
			<button type="button" onclick="showCameraEntry()">üì∏ Scan Label</button>
        </div>

        <form id="addEntryForm" onsubmit="addEntry(event)" style="display: none;">
            <div id="newEntryFields"></div>
            <div class="nav-buttons">
                <button type="submit">Save Entry</button>
                <button type="button" onclick="backToEntrySelection()">‚Üê Back</button>
            </div>
        </form>

        <div id="pasteEntrySection" style="display: none;">
            <label for="pasteTextArea">Paste Cerner patient list data:</label>
            <textarea id="pasteTextArea" class="import-textarea" placeholder="Paste patient list here..." rows="10"></textarea>
            <div class="nav-buttons">
                <button type="button" onclick="processPastedEntry()">Process & Add</button>
                <button type="button" onclick="backToEntrySelection()">‚Üê Back</button>
            </div>
        </div>

        <!-- Add the Update Patients section -->
        <div id="updatePatientsSection" style="display: none;">
            <h3 style="color: var(--accent-4); margin-bottom: 10px;">Update Patient List</h3>
            <p style="color: var(--text-secondary); margin-bottom: 10px;">Paste the patient list below to update room assignments and attending physicians:</p>
            <textarea id="updateListDataModal" class="import-textarea" placeholder="Paste patient list here..." rows="10"></textarea>
            <div class="nav-buttons">
                <button type="button" onclick="processUpdateListFromModal()">Update List</button>
                <button type="button" onclick="backToEntrySelection()">‚Üê Back</button>
            </div>
        </div>


		









		<div id="cameraEntrySection" style="display: none;">
    <h3 style="color: var(--accent-4); margin-bottom: 10px;">Scan Patient Label</h3>
    <p style="color: var(--text-secondary); margin-bottom: 15px;">Upload a photo of the patient label sticker:</p>
    
    <!-- Test OCR System Button -->
    <div style="margin-bottom: 1rem; text-align: center;">
        <button type="button" onclick="testOCRSystem()" style="background: linear-gradient(135deg, var(--secondary), #0891b2); margin-bottom: 0.5rem;">
            üîß Test OCR System
        </button>
        <div style="font-size: 0.8rem; color: var(--text-secondary);">Click to verify OCR is working before scanning</div>
    </div>
    
    <!-- File upload section -->
    <div style="margin: 1rem 0;">
        <div class="file-input-wrapper" style="margin-bottom: 1rem;">
            <input type="file" id="labelImageInput" accept="image/*" onchange="handleImageUpload(event)">
            <label for="labelImageInput" class="file-input-label" style="text-align: center; padding: 1rem; border: 2px dashed var(--primary);">
                üìÅ Upload or Take Photo
            </label>
        </div>
    </div>
    
    <!-- Image preview -->
    <div style="text-align: center;">
        <div id="capturedImage" style="display: none; margin: 1rem 0;">
            <img id="previewImage" style="max-width: 100%; max-height: 400px; border: 2px solid var(--border); border-radius: 0.5rem;">
        </div>
        
        <!-- Simple rotation controls -->
        <div id="rotationControls" style="display: none; margin: 1rem 0;">
            <button type="button" onclick="rotateImage(-90)" style="margin: 0 0.5rem;">‚Ü∫ Rotate Left</button>
            <button type="button" onclick="rotateImage(90)" style="margin: 0 0.5rem;">‚Üª Rotate Right</button>
        </div>
    </div>
    
    <!-- Processing progress -->
    <div id="ocrProgress" style="display: none; text-align: center; color: var(--primary); margin: 1rem 0; padding: 1rem; background: var(--card-bg); border-radius: 0.5rem;">
        <div style="margin-bottom: 0.5rem;">Processing image...</div>
        <div style="background: var(--dark-bg); border-radius: 1rem; height: 8px; overflow: hidden; margin-bottom: 0.5rem;">
            <div id="ocrProgressBar" style="background: var(--primary); height: 100%; width: 0%; transition: width 0.3s;"></div>
        </div>
        <span id="ocrProgressPercent">0%</span>
    </div>
    
    <!-- Extracted information display -->
    <div id="extractedInfo" style="display: none; background: var(--card-bg); padding: 1rem; border-radius: 0.5rem; margin: 1rem 0; border: 1px solid var(--success);">
        <h4 style="color: var(--success); margin-bottom: 0.5rem;">üìã Extracted Information:</h4>
        <div style="margin-bottom: 0.5rem;"><strong>Name:</strong> <span id="extractedName">-</span></div>
        <div><strong>MRN:</strong> <span id="extractedMRN">-</span></div>
    </div>
    
    <!-- Debug info -->
    <div id="debugInfo" style="display: none; background: var(--dark-bg); padding: 0.75rem; border-radius: 0.25rem; margin: 1rem 0; font-family: monospace; font-size: 0.8rem; max-height: 200px; overflow-y: auto;">
        <div style="color: var(--text-secondary); margin-bottom: 0.5rem;"><strong>Raw OCR Text:</strong></div>
        <div id="debugText" style="color: var(--text-primary);"></div>
    </div>
    
    <!-- Action buttons -->
    <div class="nav-buttons">
        <button id="processBtn" type="button" onclick="processCurrentImage()" style="display: none;">üîç Process Image</button>
        <button id="addExtractedBtn" type="button" onclick="addExtractedPatient()" style="display: none; background: linear-gradient(135deg, var(--success), #059669);">‚ûï Add Patient</button>
        <button type="button" onclick="toggleDebugInfo()">üêõ Toggle Debug</button>
        <button type="button" onclick="backToEntrySelection()">‚Üê Back</button>
    </div>
</div>
		

		







		

		
    </div>
</div>

		






















		




	    


        <!-- Details View -->
        <div class="details-view" id="detailsView">
            <div class="details-header">
                <div id="stickyTextContainer" class="sticky-text"></div>
                <div class="view-selector">
                    <button class="view-button active" onclick="switchView('basic')">Details</button>
                    <button class="view-button" onclick="switchView('chartcheck')">üìä Chart Check</button>
                    <button class="view-button" onclick="switchView('consult')">Consult Mode</button>
                </div>
            </div>

            <form id="editForm"></form>

            <div class="nav-buttons">
                <button id="prevButton" onclick="navigateDetails(-1)">‚Üê Previous</button>
                <button id="nextButton" onclick="navigateDetails(1)">Next ‚Üí</button>
                <button onclick="backToList()">Back to List</button>
                <button class="delete-button" onclick="deleteCurrentEntry()">üóëÔ∏è Delete Entry</button>
            </div>

            <!-- Consult-specific buttons (shown in consult mode) -->
            <div id="consultControls" class="hidden">
                <div class="nav-buttons">
                    <button id="convertTypeBtn" onclick="convertEntryType()">Convert to Patient</button>
                    <button onclick="exportToRTF('consult')"> Consult Note</button>
                    <button onclick="exportToRTF('trauma')"> Trauma Note</button>
		    <button onclick="showStaffPresentation()">Staff</button>

                </div>
            </div>
        </div>
    </div>



	<!-- Import Data Modal -->
<div id="importModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeImportModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
        <h2>Import Lab Data</h2>
        <div class="nav-buttons" style="margin-bottom: 1rem;">
            <button onclick="pasteFromClipboard()">üìã‚ö° Paste & Process</button>
            <button onclick="processImportedData()">Process Data</button>
        </div>
        <textarea id="importData" class="import-textarea" placeholder="Paste your vitals, labs, and meds data here..."></textarea>
    </div>
</div>

	


	
    <!-- Table View Modal -->
    <div id="tableModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTableModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2>Lab Values Table</h2>
            <div id="tableContainer"></div>
        </div>
    </div>














<!-- Graph View Modal -->
<div id="graphModal" class="modal">
        <div class="modal-content large-modal">
        <span class="close" onclick="closeGraphModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
        <h2>Vital Signs Table</h2> <!-- Changed from "Vital Signs Graphs" -->
        <!-- Remove the button div -->
        <div id="vitalChart" style="width: 100%; overflow-x: auto;"></div> <!-- Changed to div for table -->
    </div>
</div>
	
<!-- Help Modal -->
<div id="helpModal" class="help-modal">
    <div class="help-modal-content">
        <div class="help-modal-header">
            <h2 id="helpModalTitle" class="help-modal-title">Help & Instructions</h2>
            <button class="help-modal-close" onclick="closeHelpModal()">&times;</button>
        </div>
        <div id="helpModalBody" class="help-modal-body">
            <!-- Content will be inserted here -->
        </div>
    </div>
</div>











    <!-- Include Papa Parse and Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <script>
        // ============ GLOBAL VARIABLES ============
        let patientData = [];
        let currentPatientIndex = -1;
        let currentViewMode = 'basic'; // basic, chartcheck, consult
        let selectedColumns = [1, 2, 3, 19]; // Default to Name, RM, MRN, To do
        let filteredIndexes = [];
        let labData = {};
        let lastImportedData = '';
        let fullOrdersText = '';
        let showFullOrders = false;
        let showAbbreviatedTable = true; // Track abbreviated vs full table view
	let ioData = {};
        let currentChart = null;
		let currentSortColumn = ''; // Track current sort column
		let violinRedStylingApplied = false; // Add this flag
		let tempChecklistStates = {}; // Temporary checklist states


        // Master headers structure
        const MASTER_HEADERS = [
            'Type',      // "Patient" or "Consult"
            'Name',      
            'RM',        
            'MRN',       
            'Att',       
            'A/G',       // Age/Gender - Consult only
            'CC',        // Chief Complaint - Consult only
            'Problems',  // Patient only (maps to HPI for consults)
            'HPI',       // Consult only
            'ROS',       // Consult only
            'PMH',       // Consult only
            'Meds',      // Consult only
            'All',       // Allergies - Consult only
            'Surg hx',   // Consult only
            'FSH',       // Family/Social History - Consult only
            'ICS',       
            'VIOLIN',    
            'PE',        // Physical Exam - Consult only
            'ORDERS',    
            'To do',     
            'Priority',
            // Chart Check specific fields (stored but not shown in basic view)
            'ImportedData', // Store raw imported data
            'LabData'       // Store processed lab data
        ];

        const PATIENT_COLUMNS = [0, 1, 2, 3, 4, 7, 15, 16, 18, 19, 20];
        const CONSULT_COLUMNS = [0, 1, 2, 3, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20];

        const colors = [
            'colored-text-1', 'colored-text-2', 'colored-text-3',
            'colored-text-4', 'colored-text-5'
        ];


// Help Tips for Modal 
const helpContent = {
'Problems': `<details class="help-collapsible"><summary><span class="section-header" data-tag="problems">HPI</span><input type="checkbox" class="section-check"></summary><h3>Story</h3><p><strong>ASK EVERYTHING BUT WRITE DOWN THE POSITIVES! FOCUS ON WHAT IS RELEVANT TO THE SURGICAL CONSULTATION ‚Üí What is the DDX before seeing, and what possible surgical interventions or assistance may actually be required?</strong></p><ul><li><strong>Onset</strong><ul><li>Sequence of events and why presenting today; preceding events</li><li>Where coming from</li><li>What did they do there? Interventions, medications, studies, consultations</li><li>If they have tubes, drains or devices: are they functioning? What have the outputs been?</li></ul></li><li>Palliating, provoking</li><li>Quality, radiation, severity</li><li>Prior episodes, evolution over time</li><li><strong>Trauma Details:</strong><ul><li>Time of injury</li><li>Mechanism: MVC/MCC speed, location of force transfer</li><li>Seatbelt / helmet / airbags / protective devices</li><li>Post-injury course</li><li>Identified injuries</li><li>Therapies/interventions</li></ul></li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="ros">Review of Systems</span><input type="checkbox" class="section-check"></summary><ul><li><strong>Constitutional:</strong> fever, chills, night sweats, weight loss, anorexia (last MEAL), travel, sick contacts, diet changes <span class="subnote">(traveling guy, sun overhead, get tired, vacation)</span></li><li><strong>Neurologic:</strong> headache, dizziness, numbness, tingling, weakness, presyncope/syncope, tremors, convulsions/seizures, unsteady gait <span class="subnote">(head)</span></li><li><strong>Skin:</strong> jaundice, rash, lesions, petechiae, itching <span class="subnote">(sunburnt)</span></li><li><strong>ENMT:</strong> vision changes, hearing changes, ear or eye pain, sore throat, congestion, runny nose, hoarseness, dysphagia <span class="subnote">(eyes/ears)</span></li><li><strong>Respiratory:</strong> shortness of breath, cough, wheezing <span class="subnote">(chest)</span></li><li><strong>Cardiovascular:</strong> chest pain, palpitations <span class="subnote">(chest)</span></li><li><strong>Gastrointestinal:</strong> nausea, vomiting, last BM and gas, change in bowel habits, abdominal pain <span class="subnote">(stomach, colon)</span></li><li><strong>Genitourinary:</strong> dysuria, urine retention (last void: ___), hematuria, discharge <span class="subnote">(groin)</span></li><li><strong>Musculoskeletal:</strong> pain, joint swelling, stiffness, myalgias, trauma</li><li><strong>Psychiatric:</strong> anxiety, depression, restlessness, suicidal ideation</li><li><strong>Heme/Lymph:</strong> bleeding tendency, bruising tendency, petechiae, swollen nodes</li><li><strong>Menstrual:</strong> LMP, menopausal</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="pmh">Past Medical and Surgical History</span><input type="checkbox" class="section-check"></summary><ul><li>Previous diagnoses</li><li>Chronic conditions</li><li>Previous surgeries</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="meds">Current Medications</span><input type="checkbox" class="section-check"></summary><ul><li>Home medications</li><li>Current hospital medications</li><li>Allergies (cross-check)</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="allg">Allergies</span><input type="checkbox" class="section-check"></summary><ul><li>Drug allergies</li><li>Environmental allergies</li><li>Type of reaction</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="soc">Social History/Colonoscopy/EGD</span><input type="checkbox" class="section-check"></summary><ul><li>Emergency contact #</li><li>Smoking history</li><li>Alcohol use</li><li>Recreational/illicit drugs</li><li>Caffeine intake</li><li>Sexual history</li><li>Nutrition/diet</li><li>Stressors/mental health</li><li>Occupation/work environment</li><li>Religion/spiritual beliefs</li><li>Constipation help / bowel habits</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="fhx">Family History</span><input type="checkbox" class="section-check"></summary><ul><li>Major hereditary diseases (cardiovascular, diabetes, cancer, bleeding disorders)</li><li>Liver/biliary/pancreatic disease</li><li>Other significant familial conditions</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="cex">Clinical Examination</span><input type="checkbox" class="section-check"></summary><ul><li><strong>Gen:</strong> Well appearing in no acute distress. Alert and oriented x3.</li><li><strong>Neuro:</strong> strength and sensation intact BUE+BLE, CN II‚ÄìXII grossly intact, EOMI</li><li><strong>Resp:</strong> Non-labored breathing. No use of accessory muscles, no retractions.</li><li><strong>CV:</strong> Hemodynamically stable</li><li><strong>Pulse:</strong> palpable b/l DP/PT pulses, radial/ulnar pulses</li><li><strong>Abd:</strong> soft, non-tender, non-distended; no voluntary or involuntary guarding; no rebound or jolt tenderness</li><li><strong>Wound:</strong> Incisions clean, dry, intact.</li><li><strong>LTD:</strong> __________________</li></ul></details><details class="help-collapsible"><summary><span class="section-header" data-tag="trauma">Trauma Examination</span><input type="checkbox" class="section-check"></summary><ul><li><strong>Head:</strong> Normocephalic, atraumatic, no deformities, abrasions, tenderness, oropharynx clear, no blood in nares or ears, hearing intact</li><li><strong>Neuro:</strong> GCS 15, Pupils equal and reactive to light bilaterally, extraocular muscles intact, gross motor and sensory intact in all 4 extremities</li><li><strong>Face:</strong> Atraumatic, no deformities, abrasions, tenderness</li><li><strong>Chest:</strong> clear to auscultation bilaterally, non-tender, atraumatic, pulling on incentive spirometer</li><li><strong>CVS:</strong> RRR, hemodynamically stable</li><li><strong>Abdomen:</strong> soft, non-tender, non-distended, no voluntary or involuntary guarding, no jolt or rebound tenderness</li><li><strong>Pelvis:</strong> Stable</li><li><strong>Upper Extremities:</strong> Atraumatic, no deformities, abrasions, tenderness, Bilateral radial pulses palpable, brisk capillary refill</li><li><strong>Lower Extremities:</strong> Atraumatic, no deformities, abrasions, tenderness, brisk capillary refill, Bilateral femoral, DP, PT pulses palpable</li><li><strong>Spine:</strong> No obvious cervical, lumbar, or thoracic spine deformities, no step offs, no tenderness, trachea midline</li><li><strong>Perineum:</strong> No gross blood in the perineum, rectal exam deferred, anal wink reflex intact</li><li>GCS: Eye opening (E) (Think: Eyes = ‚Äúfour eyes‚Äù) -> 4‚ÄîOpens spontaneously, 3‚ÄîOpens to voice (command), 2‚ÄîOpens to painful stimulus, 1‚ÄîDoes not open eyes. Verbal response (V) (Think: Verbal = ‚ÄúJackson 5‚Äù), 5‚ÄîAppropriate and oriented, 4‚ÄîConfused, 3‚ÄîInappropriate words, 2‚ÄîIncomprehensible sounds, 1‚ÄîNo sounds. Motor response (M) 6‚ÄîObeys commands, 5‚ÄîLocalizes pain, 4‚ÄîWithdraws from pain, 3‚ÄîDecorticate posture, 2‚ÄîDecerebrate posture, 1‚ÄîNo movement</li></ul></details><p style="margin-top:1rem;"><a href="https://www.isncscialgorithm.com/Form" target="_blank" style="color:#3b82f6; text-decoration:underline;">ASIA Neurological Exam Form & Algorithm</a></p>`, 
	'ICS': '<ul><li><strong>Diagnostic imaging</strong></li><li><strong>Pathology + Microbiology</strong></li>  <li><strong>Overnight events</strong></li><li><strong>Latest consult notes</strong></li><li><strong>Procedures/Interventions</strong></li><li><strong>Non Primary: plan of care</strong></li></ul>',
    'VIOLIN': '<ul><li><strong>Vitals (HR, SBP, DBP, MAP, Temp, RR, SPO2, O2 therapy, Vent: Mode, RR, Vt, PEEP, FIO2, PIP, ETCO2, Cardiac: CVP, PASP/PADP, PAMAP, CO, CI, SvO2, SV, SVI, SVR) </strong></li> <li><strong> Intake (Blood products, oral, IVF, meds, tube feeds) and Outputs (BM, ostomy, urostomy, drains/tubes, UOP, emesis, blood loss, dialysis), Fluid balance </strong></li> <li><strong> CBC and left shift, BMP, Ca, Mg, P, Tbil, Dbili, ALK, GGT, AST/ALT, PT, PTT, INR, pH, PO2, PCO2, Bicarb, Base excess, Lactate, Trops, Misc: albumin, prealbumin, Procal, UA, Urine studies</strong></li><li><strong>Replete electrolytes: electrolytes</strong></li></ul> <li><strong> <a href="//docs.google.com/document/d/12lbPO5K7jMPhruuoedT-piCaQSr9dja2OObAeMD2NWk/edit?tab=t.0"> Review Imaging https:</a> </strong></li>', 
'ORDERS': '<ul><li><strong>Renew orders</strong></li><li><strong>Nutrition/fluids:</strong><ul><li><strong>Diet order/IVFs/tube feeds/TPN</strong></li></ul></li><li><strong>Pain medications:</strong></li><li><strong>LTD:</strong><ul><li><strong>Orders for any lines (central line, PICC, peripheral IVs, arterial line, chest tubes, drains, ports, NG tubes, respiratory support NC or facemask, ETT)</strong></li><li><strong>Inc. Types of trach and size ex. #8 cuffed subglottic tracheostomy, date placed</strong></li><li><strong>Record accurate outputs, suction/maintenance settings ex. CT -20 mmHg suction, quality of output</strong></li></ul></li><li><strong>Antibiotics/special medications/home meds:</strong><ul><li><strong>Note any IV or oral antibiotics or special therapies and the duration required.</strong></li><li><strong>Record doses of all pressors and sedation</strong></li></ul></li><li><strong>Anticoagulation/DVT prophylaxis:</strong><ul></ul></li><li><strong>Disposition</strong></li></ul>',   
	'Priority': '',
    'CC': '<b>Chief Complaint/Level</b><br><br>‚Ä¢ Primary reason for consultation<br>‚Ä¢ Trauma level if applicable<br>‚Ä¢ Brief description of problem',
'HPI': '<ul><li><strong>Trauma</strong><ul><li><strong>Time of injury</strong></li><li><strong>Mechanism:</strong> MVC/MCC: Speed, Location of force transfer</li><li><strong>Seatbelt / helmet / airbags / protective devices</strong></li><li><strong>Post-injury course</strong></li><li><strong>Identified injuries</strong></li><li><strong>Therapies/interventions</strong></li></ul></li><li><strong>STORY ‚Üí !!FOCUS ON WHAT IS RELEVANT TO THE SURGICAL CONSULTATION!! ‚Üí WHAT IS THE DDX before seeing, and what possible surgical interventions or assistance may actually be required?</strong><ul><li><strong>Onset</strong><ul><li><strong>Sequence of events and why presenting today, Preceding Events</strong></li><li><strong>Where coming from</strong></li><li><strong>What did they do there? Interventions, medications, studies, consultations</strong></li><li><strong>If they have tubes, drains or devices are they functioning? What has the outputs been?</strong></li></ul></li><li><strong>Palliating, provoking</strong></li><li><strong>Quality, radiation, severity</strong></li><li><strong>Prior episodes, evolution over time</strong></li></ul></li></ul>',
	'ROS': '<ul><li><strong>ROS</strong></li><li><strong>Constitutional: fever, chills, night sweats, weight loss, anorexia (last MEAL), travel, sick contacts, diet changes (traveling guy, sun overhead, get tired, vacation)</strong></li><li><strong>Neurologic: headache, dizziness, numbness, tingling, weakness, presyncope/syncope, tremors, convulsions/ seizures, unsteady gait (head)</strong></li><li><strong>Skin: Jaundice, rash, lesions, petechiae, itching (sunburnt)</strong></li><li><strong>ENMT: vision changes, hearing changes, ear or eye pain, sore throat, congestion, runny nose, hoarseness, dysphagia (eyes/ears)</strong></li><li><strong>Respiratory: shortness of breath, cough, wheezing (chest)</strong></li><li><strong>Cardiovascular: chest pain, palpitations (chest)</strong></li><li><strong>Gastrointestinal: nausea, vomiting, last BM and gas: change in bowel habits, abdominal pain, (stomach, colon)</strong></li><li><strong>Genitourinary: dysuria, urine retention (last void: ), hematuria, discharge (groin)</strong></li><li><strong>Musculoskeletal: pain, joint swelling, stiffness, myalgias, trauma</strong></li><li><strong>Psychiatric: anxiety, depression, restlessness, suicidal ideation</strong></li><li><strong>Heme/Lymph: bleeding tendency, bruising tendency, petechiae, swollen nodes</strong></li><li><strong>Menstrual: LMP, menopausal</strong></li></ul>',
    'PMH': '<b>Past Medical History</b><br><br>‚Ä¢ Previous diagnoses<br>‚Ä¢ Chronic conditions<br>‚Ä¢ Previous surgeries',
    'Meds': '<b>Current Medications</b><br><br>‚Ä¢ Home medications<br>‚Ä¢ Current hospital medications<br>‚Ä¢ Allergies',
    'All': '<b>Allergies</b><br><br>‚Ä¢ Drug allergies<br>‚Ä¢ Environmental allergies<br>‚Ä¢ Type of reaction',
	'PE': '<strong>Clinical Examination:</strong></div><ul><li><strong>Gen: Well appearing in no acute distress. Alert and oriented x3.</strong></li><li><strong>Neuro: strength and sensation intact BUE+BLE, CN II-XII grossly intact, EOMI</strong></li><li><strong>Resp: Non-labored breathing. No use of accessory muscles, no retractions.</strong></li><li><strong>CV: Hemodynamically stable</strong></li><li><strong>Pulse: palpable b/l DP/PT pulses, radial/ulnar pulses</strong></li><li><strong>Abd: soft, non tender, non distended, no voluntary or involuntary guarding, no rebound or jolt tenderness</strong></li><li><strong>Wound: Incisions clean, dry, intact.</strong></li><li><strong>LTD:</strong></li></ul><div><strong>Trauma Examination:</strong></div><ul><li><strong>Head: Normocephalic, atraumatic, no deformities, abrasions, tenderness, oropharynx clear, no blood in nares or ears, hearing intact</strong></li><li><strong>Neuro: GCS 15, Pupils equal and reactive to light bilaterally, extraocular muscles intact. gross motor and sensory intact in all 4 extremities.</strong></li><li><strong>Face: Atraumatic, no deformities, abrasions, tenderness</strong></li><li><strong>Chest: clear to auscultation bilaterally, non-tender, atraumatic, Pulling _ On incentive spirometer</strong></li><li><strong>CVS: RRR, hemodynamically stable</strong></li><li><strong>Abdomen: soft, non-tender, non-distended, no voluntary or involuntary guarding, no jolt or rebound tenderness</strong></li><li><strong>Pelvis: Stable</strong></li><li><strong>Upper Extremities: Atraumatic, no deformities, abrasions, tenderness, Bilateral radial pulses palpable, brisk capillary refill</strong></li><li><strong>Lower Extremities: Atraumatic, no deformities, abrasions, tenderness, brisk capillary refill, Bilateral femoral, DP, PT pulses palpable.</strong></li><li><strong>Spine: No obvious cervical, lumbar, or thoracic spine deformities, no step offs, no tenderness, trachea midline</strong></li><li><strong>Perineum: No gross blood in the perineum, rectal exam deferred, anal wink reflex intact</strong></li>',
'To do': 'INTERACTIVE_CHECKLIST', 
'Plan': '<h3>Nutrition/Fluids</h3><ul><li><strong>NPO considerations</strong><ul><li><strong>if NPO may need fluids</strong></li><li><strong>Speech and swallow consult for concern for dysphagia or older patients with cervical spine injury</strong></li></ul></li><li><strong>TPN/PPN</strong><ul><li><strong>Used when there are contraindications to EN</strong></li><li><strong>Critically Ill: Within 36 to 48 hours</strong></li><li><strong>Noncritically ill postoperative patients: After at least five days, usually at 14 days</strong></li><li><strong>Chronic malnutrition and anticipated prolonged bowel rest: Can be earlier than five to seven days</strong></li><li><strong>Daily order needs to be cosigned</strong></li><li><strong>Ensure fat emulsion is ordered</strong></li><li><strong>Need central access for TPN</strong></li><li><strong>Note rate</strong></li></ul></li><li><strong>TF</strong><ul><li><strong>Indications</strong></li><li><strong>Severe dysphagia (may need postpyloric access to reduce aspiration risk)</strong></li><li><strong>Persisted for at least two weeks and expected to persist for at least four weeks</strong></li><li><strong>Requirement of mechanical ventilation for 4 weeks or more (NG tube 4 weeks or more)</strong></li><li><strong>Note feeding rate versus goal rate</strong></li><li><strong>If via cortrack consider PEG</strong></li></ul></li><li><strong>Maintenance fluid rate: <a href="https://www.mdcalc.com/calc/72/maintenance-fluids-calculations" target="_blank">https://www.mdcalc.com/calc/72/maintenance-fluids-calculations</a></strong></li></ul><h3>Pain Management</h3><ul><li><strong>Convert all IV pain meds to oral when possible</strong></li><li><strong>Check MAR for frequency of requests for pain meds</strong></li><li><strong>Order standing non opioid pain meds for all patients on PRN opioids.</strong></li></ul><h3>LTD</h3><ul><li><strong>Make plan to remove drains/tubes.</strong></li><li><strong>Tracheostomy indicated for prolonged mechanical ventilation (&gt;10 days) unlikely to wean (max duration 3 weeks on ETT)</strong></li></ul><h3>Antibiotics/Special Meds</h3><ul><li><strong>Order Vancomycin/medication trough levels</strong></li><li><strong>Find out end date of antibiotics, wean off pressors and sedation. Otherwise set up long term antibiotic IV access if needed</strong></li><li><strong>Ensure all home meds are restarted if appropriate</strong></li></ul><h3>Anticoagulation</h3><ul><li><strong>Check/start dvt prophylaxis or home AC ex. aspirin/plavix when appropriate</strong></li><li><strong>.dvt_url for trauma patients</strong></li></ul><h3>Discharge</h3><ul><li><strong>PT/OT consult for all elderly debilitated patients postoperatively</strong></li><li><strong>Text SW/IDT daily with update for all primary patients</strong></li><li><strong>Special orders</strong><ul><li><strong>VNS: help with dressing changes, wound vacs, home medication review, vital signs monitoring</strong></li><li><strong>Home wound vac services</strong></li><li><strong>Home PT/OT</strong></li><li><strong>Home infusion services</strong></li><li><strong>Transportation/Medical</strong></li></ul></li></ul><h3>Adjuncts</h3><ul><li><strong>Urine retention-&gt; Foley, bladder scan, flomax</strong></li><li><strong>Constipation-&gt; senna, colace, miralax, suppository, enema</strong></li><li><strong>Nausea/vomiting-&gt; zofran, reglan, compazine, NGT</strong></li><li><strong>CXRs/KUBs</strong></li></ul>', 
	
};

		
		

        // ============ INITIALIZATION ============
        window.onload = function() {
            loadFromLocalStorage();
            setupEventListeners();
            updateCensus();
            
           
        };

        function setupEventListeners() {
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        }



	

        // ============ DATA MANAGEMENT ============
        function saveToLocalStorage() {
            try {
                const dataToSave = {
                    version: '2.0',
                    timestamp: new Date().toISOString(),
                    patients: patientData
                };
                localStorage.setItem('ultimatePatientList', JSON.stringify(dataToSave));
                

            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }










		function loadFromLocalStorage() {
    try {
        const saved = localStorage.getItem('ultimatePatientList');
        if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.patients && Array.isArray(parsed.patients)) {
                patientData = parsed.patients;
                displayRows();
                populateColumnSelector();
                populateColumnSelect();
                updateCensus();
            }
        }
        
        // LOAD CHECKLIST STATES
        const savedChecklists = localStorage.getItem('checklistStates');
        if (savedChecklists) {
            tempChecklistStates = JSON.parse(savedChecklists);
        }
    } catch (e) {
        console.error('Error loading from localStorage:', e);
    }
}




		



		function handleFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const fileName = file.name.toLowerCase();
        const reader = new FileReader();
        
        if (fileName.endsWith('.csv')) {
            // Handle CSV file
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const importedPatients = parseCSVData(csvText);
                    
                    if (importedPatients && importedPatients.length > 0) {
                        // Ask user if they want to replace or append
                        const replace = confirm(`Found ${importedPatients.length} patients in CSV.\n\nClick OK to REPLACE current list, or Cancel to ADD to current list.`);
                        
                        if (replace) {
                            patientData = importedPatients;
                        } else {
                            patientData = patientData.concat(importedPatients);
                        }
                        
                        displayRows();
                        populateColumnSelector();
                        populateColumnSelect();
                        saveToLocalStorage();
                        updateCensus();
                        alert(`Successfully imported ${importedPatients.length} patients from CSV!`);
                    } else {
                        alert('No valid patient data found in CSV file.');
                    }
                } catch (error) {
                    alert('Error parsing CSV file: ' + error.message);
                    console.error('Error parsing CSV:', error);
                }
            };
            reader.readAsText(file);
        } else if (fileName.endsWith('.json')) {
            // Handle JSON file (existing logic)
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    
                    if (jsonData.patients && Array.isArray(jsonData.patients)) {
                        patientData = jsonData.patients;
                    } else if (Array.isArray(jsonData)) {
                        patientData = jsonData;
                    } else {
                        alert('Invalid JSON format');
                        return;
                    }
                    
                    displayRows();
                    populateColumnSelector();
                    populateColumnSelect();
                    saveToLocalStorage();
                    updateCensus();
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                    console.error('Error parsing JSON:', error);
                }
            };
            reader.readAsText(file);
        } else {
            alert('Please select a JSON or CSV file.');
        }
    }
}



		

        function exportData() {
    // Show export options modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content">
            <h2>Export Data</h2>
            <div class="nav-buttons">
                <button onclick="exportJSON(); this.closest('.modal').remove()">Export as JSON</button>
                <button onclick="exportCSV(); this.closest('.modal').remove()">Export as CSV</button>
                <button onclick="this.closest('.modal').remove()">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}











function exportJSON() {
    if (patientData.length === 0) {
        alert('No data to export');
        return;
    }
    
    const dataToExport = {
        version: '2.0',
        exportDate: new Date().toISOString(),
        patients: patientData
    };
    
    // Create filename with format: list_M.D.YY
    const now = new Date();
    const month = now.getMonth() + 1; // No padding, just the number
    const day = now.getDate();
    const year = String(now.getFullYear()).slice(-2); // Last 2 digits of year
    const filename = `list_${month}.${day}.${year}.json`;
    
    downloadFile(JSON.stringify(dataToExport, null, 2), filename, 'application/json');
}

















	    



	    

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============ UI FUNCTIONS ============
        function updateCensus() {
            document.getElementById('censusCount').textContent = patientData.length;
        }

























		// Function to calculate checklist completion status
function getChecklistStatus(patient, patientIndex) {
    const patientKey = `${patientIndex}_${patient.Name || 'unnamed'}`;
    const isTrauma = patient.Type !== 'Consult';
    
    // Define item counts for each checklist type
    const traumaItemCount = 17; // Based on your traumaItems array
    const consultItemCount = 11; // Based on your consultItems array
    const totalItems = isTrauma ? traumaItemCount : consultItemCount;
    
    // Check if patient has any checklist state
    if (!tempChecklistStates[patientKey]) {
        return { completed: 0, total: totalItems, percentage: 0 };
    }
    
    const states = tempChecklistStates[patientKey];
    const completed = Object.values(states).filter(Boolean).length;
    const percentage = Math.round((completed / totalItems) * 100);
    
    return { completed, total: totalItems, percentage };
}











	function getPriorityStatus(patient) {
    // Normalize priority: handle undefined, null, or non-string values
    const priority = (patient.Priority || '').toString().trim().toLowerCase();
    console.log('getPriorityStatus: Normalized priority:', priority); // Debug log

    if (!priority) {
        console.log('getPriorityStatus: No priority, returning default');
        return { color: 'var(--card-bg)', title: 'No priority set' }; // Gray
    }

    // Handle priority "C" explicitly for green
    if (priority === 'c') {
        console.log('getPriorityStatus: Matched priority C, returning green');
        return { color: '#10b981', title: 'Priority C - Complete' }; // Green (emerald-500)
    }

    // Handle numeric priorities
    const priorityNum = parseInt(priority);
    if (!isNaN(priorityNum)) {
        console.log('getPriorityStatus: Priority is numeric:', priorityNum);
        switch (priorityNum) {
            case 1:
                return { color: '#ff0000', title: 'Priority 1 - Urgent' }; // Red
            case 2:
                return { color: '#ff2400', title: 'Priority 2 - High' }; // Orange
            case 3:
                return { color: '#ff4900', title: 'Priority 3 - Medium-High' }; // Amber
            case 4:
                return { color: '#ff6d00', title: 'Priority 4 - Medium' }; // Yellow
            case 5:
                return { color: '#ff9200', title: 'Priority 5 - Medium-Low' }; // yellow
            case 6:
                return { color: '#ffb600', title: 'Priority 6 - Low-Medium' }; // dark yellow
            case 7:
                return { color: '#ffdb00', title: 'Priority 7 - Low' }; // Cyan
            case 8:
                return { color: '#ffff00', title: 'Priority 8 - Very Low' }; // Blue
            case 9:
                return { color: '#800080', title: 'Priority 9 - Minimal' }; // Purple
            case 10:
                return { color: '#bf00bf', title: 'Priority 10 - Lowest' }; // Violet
            default:
                console.log('getPriorityStatus: Numeric priority out of range:', priorityNum);
                return { color: 'var(--card-bg)', title: `Priority ${priorityNum} - Out of range` }; // Gray
        }
    }

    // Text-based priority fallback
    console.log('getPriorityStatus: Checking text-based priority:', priority);
    if (priority.includes('done') || priority.includes('complete')) {
        return { color: '#10b981', title: `${priority} - Complete` }; // Green
    }
    if (priority.includes('urgent') || priority.includes('stat')) {
        return { color: '#ef4444', title: `${priority} - Urgent` }; // Red
    }
    if (priority.includes('high')) {
        return { color: '#f97316', title: `${priority} - High` }; // Orange
    }
    if (priority.includes('medium')) {
        return { color: '#f59e0b', title: `${priority} - Medium` }; // Amber
    }
    if (priority.includes('low')) {
        return { color: '#22c55e', title: `${priority} - Low` }; // Light Green
    }

    console.log('getPriorityStatus: Unrecognized priority, returning default:', priority);
    return { color: 'var(--card-bg)', title: `${priority}` }; // Default gray
}
		









function generateStatusIndicator(patient, index) {
    // Check if this should be grey (no consult data and no priority)
    const consultFields = ['CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'PE'];
    const hasConsultData = consultFields.some(field => patient[field]?.trim());
    const hasPriority = patient.Priority?.trim();

    if (!hasConsultData && !hasPriority) {
        return `
            <div class="status-dot" 
                 style="background: var(--card-bg); border: none;" 
                 title="No consult data or priority assigned">
            </div>`;
    }

    const priority = (patient.Priority || '').trim().toLowerCase();
    let color = 'var(--card-bg)'; // Default grey
    let title = 'No priority set';

    // Handle priority "C" explicitly for complete green
    if (priority === 'C') {
        color = '#00ff41'; // Bright neon green
        title = 'Priority C - Complete';
    } else if (!isNaN(parseInt(priority))) {
        // Numeric priorities
        const priorityNum = parseInt(priority);
        switch (priorityNum) {
            case 1:
                color = '#ff0000'; // Bright neon red
                title = 'Priority 1 - Urgent';
                break;
            case 2:
                color = '#ff2400'; // Bright neon orange
                title = 'Priority 2 - High';
                break;
            case 3:
                color = '#ff4900'; // Bright neon amber
                title = 'Priority 3 - Medium-High';
                break;
            case 4:
                color = '#ff6d00'; // Bright neon yellow
                title = 'Priority 4 - Medium';
                break;
            case 5:
                color = '#ff9200'; // Bright neon lime
                title = 'Priority 5 - Medium-Low';
                break;
            case 6:
                color = '#ffb600'; // Bright neon chartreuse
                title = 'Priority 6 - Low-Medium';
                break;
            case 7:
                color = '#ffdb00'; // Bright neon cyan
                title = 'Priority 7 - Low';
                break;
            case 8:
                color = '#ffff00'; // Bright neon blue
                title = 'Priority 8 - Very Low';
                break;
            case 9:
                color = '#800080'; // Bright neon purple
                title = 'Priority 9 - Minimal';
                break;
            case 10:
                color = '#bf00bf'; // Bright neon magenta
                title = 'Priority 10 - Lowest';
                break;
            default:
                color = 'var(--card-bg)'; // Grey for out of range
                title = `Priority ${priorityNum} - Out of range`;
        }
    } else if (priority) {
        // Text-based priorities
        if (priority.includes('done') || priority.includes('complete')) {
            color = '#00ff41'; // Bright neon green
            title = `${priority} - Complete`;
        } else if (priority.includes('urgent') || priority.includes('stat')) {
            color = '#ff0040'; // Bright neon red
            title = `${priority} - Urgent`;
        } else if (priority.includes('high')) {
            color = '#ff6600'; // Bright neon orange
            title = `${priority} - High`;
        } else if (priority.includes('medium')) {
            color = '#ffaa00'; // Bright neon amber
            title = `${priority} - Medium`;
        } else if (priority.includes('low')) {
            color = '#00ffff'; // Bright neon cyan
            title = `${priority} - Low`;
        } else {
            color = 'var(--card-bg)'; // Grey for unrecognized text
            title = `${priority}`;
        }
    }

    return `
        <div class="status-dot" 
             style="background: ${color};" 
             title="${title}">
        </div>`;
}








function displayRows(data = patientData) {
    const rowList = document.getElementById('rowList');
    rowList.innerHTML = '';

    patientData.forEach((patient, index) => {
        // Get priority status and color from getPriorityStatus
        const { color, title } = getPriorityStatus(patient);

        // Determine priority class for additional styling (optional)
        const priority = patient.Priority || '';
        const priorityNum = parseInt(priority);
        let priorityClass = 'priority-default';
        if (!isNaN(priorityNum) && priorityNum >= 1 && priorityNum <= 10) {
            priorityClass = `priority-${priorityNum}`;
        } else if (priority.toLowerCase() === 'c') {
            priorityClass = 'priority-complete';
        }

        // Create main list item
        const listItem = document.createElement('li');
        listItem.className = `row-item ${priorityClass}`;
        listItem.style.cssText = `
            position: relative;
            display: flex;
            align-items: stretch;
            background: var(--card-bg);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            border-left: 4px solid ${color}; /* Use color from getPriorityStatus */
            font-size: 0.9rem;
            margin-bottom: 1rem;
            padding: 0;
        `;

        // Content container
        const contentContainer = document.createElement('div');
        contentContainer.style.cssText = `
            flex: 1;
            padding: 0.75rem;
            display: flex;
            flex-direction: column;
            gap: 0.2rem;
        `;

        // First three columns button
        const firstThreeButton = document.createElement('button');
        firstThreeButton.className = 'first-three-btn';
        firstThreeButton.style.cssText = `
            width: fit-content;
            text-align: left;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 0.25rem;
            padding: 0.2rem 0.4rem;
            cursor: pointer;
            color: inherit;
            align-self: flex-start;
            display: flex;
            flex-direction: column;
            white-space: normal;
            font-family: inherit;
            font-size: 0.9rem;
            line-height: 1.2;
            gap: 0.1rem;
        `;

        // Store data for copy functionality
        firstThreeButton.patientData = patient;
        firstThreeButton.columnIndexes = selectedColumns.slice(0, 3);
        firstThreeButton.colorClasses = colors;

        firstThreeButton.onclick = (e) => {
            e.stopPropagation();
            copyPatientInfoImproved(firstThreeButton);
        };

        // Add first three columns to button
        const firstThreeColumns = selectedColumns.slice(0, 3);
        firstThreeColumns.forEach((colIndex, idx) => {
            const header = MASTER_HEADERS[colIndex];
            const value = patient[header] || '';
            if (value) {
                const span = document.createElement('span');
                span.className = colors[idx % colors.length];
                span.textContent = value;
                span.style.cssText = `
                    display: block;
                    font-family: inherit;
                    font-size: 0.9rem;
                    line-height: 1.2;
                    margin-bottom: 0.05rem;
                `;
                firstThreeButton.appendChild(span);
            }
        });

        contentContainer.appendChild(firstThreeButton);

        // Remaining columns
        if (selectedColumns.length > 3) {
            const remainingColumns = selectedColumns.slice(3);
            remainingColumns.forEach((colIndex, idx) => {
                const header = MASTER_HEADERS[colIndex];
                const value = patient[header] || '';
                if (value) {
                    const span = document.createElement('span');
                    span.className = colors[(idx + 3) % colors.length];
                    span.textContent = value;
                    span.style.cssText = `
                        display: block;
                        margin-left: 0.5rem;
                        margin-bottom: 0.1rem;
                        font-family: inherit;
                        font-size: 0.9rem;
                        line-height: 1.2;
                    `;
                    contentContainer.appendChild(span);
                }
            });
        }

        // Priority sidebar
        const prioritySidebar = document.createElement('div');
        prioritySidebar.className = 'priority-sidebar';
        prioritySidebar.style.cssText = `
            width: 12px;
            background: ${color}; /* Use color from getPriorityStatus */
            border-radius: 0 0.5rem 0.5rem 0;
            cursor: pointer;
            transition: all 0.3s ease;
            flex-shrink: 0;
            align-self: stretch;
        `;

        // Priority sidebar click handler
        prioritySidebar.onclick = (e) => {
            e.stopPropagation();
            showStatusSelector(patient, index, prioritySidebar);
        };

        // Priority sidebar hover effects
        prioritySidebar.onmouseenter = () => {
            prioritySidebar.style.width = '14px';
            prioritySidebar.style.boxShadow = '0 0 8px rgba(0,0,0,0.3)';
        };
        prioritySidebar.onmouseleave = () => {
            prioritySidebar.style.width = '12px';
            prioritySidebar.style.boxShadow = 'none';
        };

        // Add tooltip
        const priorityName = getPriorityName(patient.Priority);
        prioritySidebar.title = `Priority: ${priorityName} (Click to change)`;

        // Row hover effects
        listItem.onmouseenter = () => {
            listItem.style.background = 'var(--card-hover)';
            listItem.style.transform = 'translateX(5px)';
            listItem.style.borderLeftWidth = '6px';
            listItem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.2)';
        };

        listItem.onmouseleave = () => {
            listItem.style.background = 'var(--card-bg)';
            listItem.style.transform = 'translateX(0)';
            listItem.style.borderLeftWidth = '4px';
            listItem.style.boxShadow = 'none';
        };

        // Main row click handler (for details view)
        listItem.onclick = (e) => {
            if (!e.target.closest('.priority-sidebar') && !e.target.closest('.first-three-btn')) {
                showDetails(index);
            }
        };

        // Assemble the row
        listItem.appendChild(contentContainer);
        listItem.appendChild(prioritySidebar);

        // Add to list
        rowList.appendChild(listItem);
    });

    updateCensus();
}
		












	function getPriorityName(priority) {
    if (!priority || priority.trim() === '') {
        return 'No priority set';
    }

    const normalizedPriority = priority.toString().trim().toLowerCase();

    // Handle "C" explicitly
    if (normalizedPriority === 'c') {
        return 'Complete';
    }

    const priorityNum = parseInt(normalizedPriority);
    if (!isNaN(priorityNum)) {
        switch (priorityNum) {
            case 1: return 'Urgent';
            case 2: return 'High';
            case 3: return 'Medium-High';
            case 4: return 'Medium';
            case 5: return 'Medium-Low';
            case 6: return 'Low-Medium';
            case 7: return 'Low';
            case 8: return 'Very Low';
            case 9: return 'Minimal';
            case 10: return 'Lowest';
            default: return `Priority ${priorityNum}`;
        }
    }

    // Text-based priority fallback
    if (normalizedPriority.includes('done') || normalizedPriority.includes('complete')) {
        return 'Complete';
    }
    if (normalizedPriority.includes('urgent') || normalizedPriority.includes('stat')) {
        return 'Urgent';
    }
    if (normalizedPriority.includes('high')) {
        return 'High';
    }
    if (normalizedPriority.includes('medium')) {
        return 'Medium';
    }
    if (normalizedPriority.includes('low')) {
        return 'Low';
    }

    return normalizedPriority; // Return as-is if unrecognized
}


		











        function displayFilteredRows(filteredData) {
            const rowList = document.getElementById('rowList');
            rowList.innerHTML = '';

            if (filteredData.length === 0) {
                const noResultsItem = document.createElement('li');
                noResultsItem.className = 'row-item';
                noResultsItem.style.textAlign = 'center';
                noResultsItem.style.color = 'var(--text-secondary)';
                noResultsItem.textContent = 'No results found';
                rowList.appendChild(noResultsItem);
            } else {
                filteredData.forEach((patient, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'row-item';
                    
                    // Display the selected columns vertically
                    selectedColumns.forEach((colIndex, idx) => {
                        const header = MASTER_HEADERS[colIndex];
                        const value = patient[header] || '';
                        if (value) {
                            const span = document.createElement('span');
                            span.className = colors[idx % colors.length];
                            span.textContent = value;
                            span.style.display = 'block';
                            listItem.appendChild(span);
                        }
                    });
                    
                    const originalIndex = filteredIndexes[index];
                    listItem.onclick = () => showDetails(originalIndex);
                    
                    rowList.appendChild(listItem);
                });
            }
        }

        function populateColumnSelector() {
            const columnSelector = document.getElementById('columnSelector');
            columnSelector.innerHTML = '';
            MASTER_HEADERS.slice(0, -2).forEach((header, colIndex) => {
                const button = document.createElement('div');
                button.className = 'column-button';
                button.textContent = header;
                if (selectedColumns.includes(colIndex)) {
                    button.classList.add('selected');
                }
                button.onclick = () => toggleColumnSelection(colIndex, button);
                columnSelector.appendChild(button);
            });
        }

        function toggleColumnSelection(colIndex, button) {
            if (selectedColumns.includes(colIndex)) {
                selectedColumns = selectedColumns.filter(col => col !== colIndex);
                button.classList.remove('selected');
            } else {
                if (selectedColumns.length < 5) { // Limit to 5 columns
                    selectedColumns.push(colIndex);
                    selectedColumns.sort((a, b) => a - b);
                    button.classList.add('selected');
                } else {
                    alert('Maximum 5 columns can be selected');
                }
            }
            displayRows();
        }

        function populateColumnSelect() {
            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Sort by</option>';
            MASTER_HEADERS.slice(0, -2).forEach((header, index) => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                columnSelect.appendChild(option);
            });
        }









	    function sortRows() {
    const column = document.getElementById('columnSelect').value;
    if (column) {
        // Save the current sort column and show re-sort button
        currentSortColumn = column;
        document.getElementById('resortBtn').style.display = 'inline-block';
        
        patientData.sort((a, b) => {
            const valueA = a[column] || '';
            const valueB = b[column] || '';
            
            // Special handling for Priority column - numerical sort
            if (column === 'Priority') {
                // Convert to numbers, treating empty/non-numeric as Infinity (sort to end)
                const numA = valueA === '' || isNaN(valueA) ? Infinity : parseInt(valueA, 10);
                const numB = valueB === '' || isNaN(valueB) ? Infinity : parseInt(valueB, 10);
                return numA - numB;
            }
            
            // Regular string comparison for other columns
            return valueA.toString().toLowerCase().localeCompare(valueB.toString().toLowerCase());
        });
        displayRows();
    } else {
        // Hide re-sort button if no sort selected
        document.getElementById('resortBtn').style.display = 'none';
        currentSortColumn = '';
    }
}




	    function reSort() {
    if (currentSortColumn) {
        // Set the dropdown to the current sort column
        document.getElementById('columnSelect').value = currentSortColumn;
        // Call the existing sort function
        sortRows();
        
        // Optional: Show a brief confirmation
        const btn = document.getElementById('resortBtn');
        const originalText = btn.textContent;
        btn.textContent = '‚úì Sorted!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 1000);
    }
}


	    




	    

        function resortRows() {
            sortRows();
        }

        function toggleColumnDropdown() {
            const dropdown = document.getElementById('columnDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        // ============ SEARCH FUNCTIONS ============
        function toggleSearch() {
            const searchContainer = document.getElementById('searchContainer');
            const searchWrapper = document.querySelector('.search-wrapper');
            
            searchContainer.classList.toggle('active');
            if (searchContainer.classList.contains('active')) {
                searchWrapper.classList.add('expanded');
                document.getElementById('searchInput').focus();
            } else {
                searchWrapper.classList.remove('expanded');
            }
        }





		function searchRows() {
    const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
    if (!searchTerm) {
        clearSearch();
        return;
    }

    // Filter from patientData using the same fields you normally show
    const filtered = patientData.filter(patient =>
        Object.values(patient).some(value =>
            (value || '').toString().toLowerCase().includes(searchTerm)
        )
    );

    // Render using the same row logic but only with filtered data
    displayRows(filtered);
}

function clearSearch() {
    document.getElementById('searchInput').value = '';
    displayRows(); // show all rows again
    const searchWrapper = document.querySelector('.search-wrapper');
    searchWrapper.classList.remove('expanded');
    document.getElementById('searchContainer').classList.remove('active');
}






		

        // ============ DETAILS VIEW ============


 function showDetails(index) {
    // Validate index
    if (index < 0 || index >= patientData.length) {
        console.error('Invalid patient index:', index);
        alert('Error: Patient not found');
        return;
    }
    
    currentPatientIndex = index;
    const detailsView = document.getElementById('detailsView');
    
    // Ensure detailsView exists
    if (!detailsView) {
        console.error('Details view element not found');
        return;
    }
    
    const patient = patientData[index];
    if (!patient) {
        console.error('Patient data not found at index:', index);
        return;
    }
    
    document.getElementById('stickyTextContainer').textContent = patient.Name || 'Unnamed Patient';
    
    // Reset view mode to basic if it's invalid
    if (!currentViewMode) currentViewMode = 'basic';
    
    // Show appropriate view based on current mode
    try {
        switchView(currentViewMode);
    } catch (e) {
        console.error('Error switching view:', e);
        switchView('basic');
    }
    
    detailsView.style.display = 'block';
    updateNavButtons();
}
 








function switchView(mode) {
    currentViewMode = mode;
    const patient = patientData[currentPatientIndex];
    
    // Update active button
    document.querySelectorAll('.view-button').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`.view-button[onclick*="${mode}"]`).classList.add('active');
    
    // Hide all mode-specific controls
    document.getElementById('consultControls').classList.add('hidden');
    
    // Generate form based on mode
    const form = document.getElementById('editForm');
    form.innerHTML = '';
    
    let fieldsToShow = []; // DECLARE HERE, OUTSIDE the switch
    let isChartCheckMode = false;
    
    switch(mode) {
        case 'basic':
            fieldsToShow = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'To do', 'Priority'];
            break;

      














case 'chartcheck':
            isChartCheckMode = true;
            
            const chartCheckContainer = document.createElement('div');
            chartCheckContainer.className = 'chart-check-layout';
            chartCheckContainer.id = 'chartCheckMainContainer';
            chartCheckContainer.style.cssText = `
                display: flex;
                gap: 1rem;
                height: calc(100vh - 250px);
                border: 3px solid var(--border);
                border-radius: 0.5rem;
                transition: border-color 0.3s ease, box-shadow 0.3s ease;
                padding: 1rem;
                background: var(--dark-bg);
            `;
            
            const leftPanel = document.createElement('div');
            leftPanel.className = 'chart-check-left-panel';
            leftPanel.style.cssText = `
                flex: 2;
                overflow-y: auto;
                padding-right: 1rem;
                border-right: 1px solid var(--border);
            `;
            
            const checkboxFields = ['Problems', 'ICS', 'VIOLIN', 'ORDERS', 'To do'];
            const fieldsToShowChartCheck = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'Priority'];
            
            fieldsToShowChartCheck.forEach(header => {
                const label = document.createElement('label');
                label.style.cssText = `
                    display: block;
                    margin-top: 0.75rem;
                    margin-bottom: 0.25rem;
                    color: var(--text-secondary);
                    font-weight: 500;
                    font-size: 0.9rem;
                    text-transform: uppercase;
                `;
                
                let labelHTML = header;
                
                if (checkboxFields.includes(header)) {
                    labelHTML += `<input type="checkbox" class="chart-check-field-checkbox" data-field="${header}" 
                         style="width: 18px; height: 18px; margin-left: 0.5rem; cursor: pointer; accent-color: var(--primary);" />`;
                }
                
                if (helpContent[header]) {
                    labelHTML += `<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
                }
                
                label.innerHTML = labelHTML;
                
                // Handle checkbox state and listeners
                if (checkboxFields.includes(header)) {
                    const fieldKey = `chartcheck_${header}_${currentPatientIndex}`;
                    try {
                        const savedState = localStorage.getItem(fieldKey);
                        const checkbox = label.querySelector('.chart-check-field-checkbox');
                        if (checkbox && savedState === 'true') {
                            checkbox.checked = true;
                        }
                        if (checkbox) {
                            checkbox.addEventListener('change', function() {
                                try {
                                    localStorage.setItem(fieldKey, this.checked);
                                    updateChartCheckProgress();
                                } catch (e) {
                                    console.error('Failed to save checkbox state:', e);
                                }
                            });
                        }
                    } catch (e) {
                        console.error('Error loading checkbox state:', e);
                    }
                }
                
                // ADD SPECIAL BUTTONS FOR SPECIFIC FIELDS
                if (header === 'Problems') {
                    const podBtn = document.createElement('button');
                    podBtn.textContent = 'Update POD';
                    podBtn.style.marginLeft = '10px';
                    podBtn.style.padding = '0.3rem 0.6rem';
                    podBtn.style.fontSize = '0.8rem';
                    podBtn.onclick = function(e) {
                        e.preventDefault();
                        updatePOD();
                    };
                    label.appendChild(podBtn);
                







} else if (header === 'VIOLIN') {
                   
                    
                    const btnContainer = document.createElement('div');
                    btnContainer.className = 'violin-button-container';
                    btnContainer.style.marginLeft = '10px';
                    
                    const importBtn = document.createElement('button');
                    importBtn.textContent = '‚¨áÔ∏è Import';
                    importBtn.onclick = function(e) {
                        e.preventDefault();
                        showImportModal();
                    };
                    
                    const tableBtn = document.createElement('button');
                    tableBtn.textContent = 'üìä Labs';
                    tableBtn.onclick = function(e) {
                        e.preventDefault();
                        showTableView();
                    };
                    
                    const graphBtn = document.createElement('button');
                    graphBtn.textContent = 'üìä Vitals';
                    graphBtn.onclick = function(e) {
                        e.preventDefault();
                        showVitalsTable();
                    };
                    
                    const fishboneBtn = document.createElement('button');
                    fishboneBtn.textContent = 'üêü Fishbone';
                    fishboneBtn.id = 'violinToggleBtn';
                    fishboneBtn.onclick = function(e) {
                        e.preventDefault();
                        toggleViolinMode();
                    };
                    
                    btnContainer.appendChild(importBtn);
                    btnContainer.appendChild(tableBtn);
                    btnContainer.appendChild(graphBtn);
                    btnContainer.appendChild(fishboneBtn);
                    label.appendChild(btnContainer);



                } else if (header === 'ORDERS') {
                    const btnContainer = document.createElement('span');
                    btnContainer.style.marginLeft = '10px';
                    
                    const abbrevBtn = document.createElement('button');
                    abbrevBtn.textContent = 'Abbrev Orders';
                    abbrevBtn.style.margin = '0 2px';
                    abbrevBtn.style.padding = '0.3rem 0.6rem';
                    abbrevBtn.style.fontSize = '0.8rem';
                    abbrevBtn.onclick = function(e) {
                        e.preventDefault();
                        updateOrders();
                    };
                    
                    const fullBtn = document.createElement('button');
                    fullBtn.textContent = 'Full Orders';
                    fullBtn.style.margin = '0 2px';
                    fullBtn.style.padding = '0.3rem 0.6rem';
                    fullBtn.style.fontSize = '0.8rem';
                    fullBtn.onclick = function(e) {
                        e.preventDefault();
                        toggleOrdersView();
                    };
                    
                    btnContainer.appendChild(abbrevBtn);
                    btnContainer.appendChild(fullBtn);
                    label.appendChild(btnContainer);
                }
                
                leftPanel.appendChild(label);
                
                // Create input field
                let input;
                if (header === 'Name' || header === 'RM' || header === 'MRN' || header === 'Att' || header === 'Priority') {
                    input = document.createElement('input');
                    input.type = 'text';
                } else {
                    input = document.createElement('textarea');
                }
                
                input.id = `field_${header.replace(/\s+/g, '_')}`;
                input.value = patient[header] || '';
                
                input.addEventListener('input', function() {
                    patient[header] = this.value;
                    if (header === 'Name') {
                        document.getElementById('stickyTextContainer').textContent = this.value || 'Unnamed Patient';
                    }
                    saveToLocalStorage();
                    if (input.tagName === 'TEXTAREA') {
                        autoResizeTextarea(this);
                    }
                });
                
                leftPanel.appendChild(input);
                
                if (input.tagName === 'TEXTAREA') {
                    setTimeout(() => autoResizeTextarea(input), 0);
                }
                
                // Add full orders display below ORDERS field
                if (header === 'ORDERS') {
                    const fullOrdersDiv = document.createElement('div');
                    fullOrdersDiv.id = 'fullOrdersDisplay';
                    fullOrdersDiv.className = 'orders-section hidden';
                    fullOrdersDiv.style.marginTop = '0.75rem';
                    leftPanel.appendChild(fullOrdersDiv);
                }
            });
            
            // RIGHT PANEL - Shows "To do" field
            const rightPanel = document.createElement('div');
            rightPanel.className = 'chart-check-right-panel';
            rightPanel.style.cssText = `
                flex: 1;
                display: flex;
                flex-direction: column;
                background: var(--dark-bg);
                border-radius: 0.5rem;
                padding: 1rem;
                border: 2px solid var(--primary);
            `;
            
            const todoLabel = document.createElement('label');
            todoLabel.style.cssText = `
                display: block;
                margin-bottom: 0.5rem;
                color: var(--text-secondary);
                font-weight: 500;
                font-size: 0.9rem;
                text-transform: uppercase;
            `;
            
            todoLabel.innerHTML = `To do<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('Plan')">?</button>`;
            
            const todoTextarea = document.createElement('textarea');
            todoTextarea.id = 'field_To_do';
            todoTextarea.value = patient['To do'] || '';
            todoTextarea.style.cssText = `
                flex: 1;
                resize: none;
                background: var(--card-bg);
                border: 1px solid var(--border);
                border-radius: 0.25rem;
                padding: 0.75rem;
                color: var(--text-primary);
                font-family: inherit;
                font-size: 0.9rem;
				overflow-y: auto; 
            `;
            
            todoTextarea.addEventListener('input', function() {
                patient['To do'] = this.value;
                saveToLocalStorage();
                autoResizeTextarea(this);
            });
            
            rightPanel.appendChild(todoLabel);
            rightPanel.appendChild(todoTextarea);
            
            chartCheckContainer.appendChild(leftPanel);
            chartCheckContainer.appendChild(rightPanel);
            form.appendChild(chartCheckContainer);
            
            if (patient.ImportedData) {
                lastImportedData = patient.ImportedData;
            }
            if (patient.LabData) {
                try {
                    labData = JSON.parse(patient.LabData);
                } catch (e) {
                    labData = {};
                }
            }
            
            setTimeout(() => {
                updateChartCheckProgress();
            }, 100);
            
            break;
       






































					






                    
                case 'consult':
                    // Show consult fields
                    if (patient.Type === 'Consult') {
                        fieldsToShow = ['Name', 'RM', 'MRN', 'A/G', 'CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'VIOLIN', 'PE', 'To do', 'Priority'];
                    } else {
                        fieldsToShow = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'To do', 'Priority'];
                    }
                    document.getElementById('consultControls').classList.remove('hidden');
                    updateConvertButton();
                    break;
            }


			fieldsToShow.forEach(header => {
    const label = document.createElement('label');

if (currentViewMode === 'consult' && CONSULT_MODE_LABELS[header]) {
    if (helpContent[header]) {
        label.innerHTML = `${CONSULT_MODE_LABELS[header]}<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
    } else {
        label.textContent = CONSULT_MODE_LABELS[header];
    }
} else {
    if (helpContent[header]) {
        label.innerHTML = `${header}<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
    } else {
        label.textContent = header;
    }
}

				
				


		    
                
                // Add buttons for specific fields in chart check mode
                if (currentViewMode === 'chartcheck') {
                    if (header === 'Problems') {
                        const podBtn = document.createElement('button');
                        podBtn.textContent = 'Update POD';
                        podBtn.style.marginLeft = '10px';
                        podBtn.style.padding = '0.3rem 0.6rem';
                        podBtn.style.fontSize = '0.8rem';
                        podBtn.onclick = function(e) {
                            e.preventDefault();
                            updatePOD();
                        };
                        label.appendChild(podBtn);
                    
						
					
					} else if (header === 'VIOLIN') {

    
    // Create button container with special class for mobile styling
    const btnContainer = document.createElement('div');
    btnContainer.className = 'violin-button-container';
    btnContainer.style.marginLeft = '10px';
    
    const importBtn = document.createElement('button');
    importBtn.textContent = '‚¨áÔ∏è Import';
    importBtn.onclick = function(e) {
        e.preventDefault();
        showImportModal();
    };
    
    const tableBtn = document.createElement('button');
    tableBtn.textContent = 'üìä Labs';
    tableBtn.onclick = function(e) {
        e.preventDefault();
        showTableView();
    };
    
    const graphBtn = document.createElement('button');
    graphBtn.textContent = 'üìä Vitals';
    graphBtn.onclick = function(e) {
        e.preventDefault();
        showVitalsTable();
    };
    
    btnContainer.appendChild(importBtn);
    btnContainer.appendChild(tableBtn);
    btnContainer.appendChild(graphBtn);
    label.appendChild(btnContainer);
}
					
					else if (header === 'ORDERS') {
                        const btnContainer = document.createElement('span');
                        btnContainer.style.marginLeft = '10px';
                        
                        const abbrevBtn = document.createElement('button');
                        abbrevBtn.textContent = 'Abbrev Orders';
                        abbrevBtn.style.margin = '0 2px';
                        abbrevBtn.style.padding = '0.3rem 0.6rem';
                        abbrevBtn.style.fontSize = '0.8rem';
                        abbrevBtn.onclick = function(e) {
                            e.preventDefault();
                            updateOrders();
                        };
                        
                        const fullBtn = document.createElement('button');
                        fullBtn.textContent = 'Full Orders';
                        fullBtn.style.margin = '0 2px';
                        fullBtn.style.padding = '0.3rem 0.6rem';
                        fullBtn.style.fontSize = '0.8rem';
                        fullBtn.onclick = function(e) {
                            e.preventDefault();
                            toggleOrdersView();
                        };
                        
                        btnContainer.appendChild(abbrevBtn);
                        btnContainer.appendChild(fullBtn);
                        label.appendChild(btnContainer);
                    }
                }
                
let input;
if (header === 'Name' || header === 'RM' || header === 'MRN' || header === 'Att' || header === 'Priority') {
    input = document.createElement('input');
}
else if (header === 'VIOLIN') {
    input = document.createElement('textarea');
    // Remove contentEditable and inline styles - let CSS handle it
}
else {
    input = document.createElement('textarea');
}



                    
                if (input.tagName === 'INPUT') {
                    input.type = 'text';
                }
                
                input.id = `field_${header.replace(/\s+/g, '_')}`;


// Set initial content
if (header === 'VIOLIN') {
    const content = patient[header] || '';
    // If content has HTML spans, use innerHTML to preserve red formatting
    if (content.includes('<span')) {
        input.innerHTML = content;
    } else {
        input.textContent = content;
    }
} else {
    input.value = patient[header] || '';
}



				

input.addEventListener('input', function() {
    patient[header] = this.value;
    
    if (header === 'Name') {
        document.getElementById('stickyTextContainer').textContent = this.value || 'Unnamed Patient';
    }
    saveToLocalStorage();
    
    if (input.tagName === 'TEXTAREA') {
        autoResizeTextarea(this);
    }
});




                form.appendChild(label);
                
                // Add full orders display above ORDERS field
                if (header === 'ORDERS' && currentViewMode === 'chartcheck') {
                    const fullOrdersDiv = document.createElement('div');
                    fullOrdersDiv.id = 'fullOrdersDisplay';
                    fullOrdersDiv.className = 'orders-section hidden';
                    form.appendChild(fullOrdersDiv);
                }
                
                form.appendChild(input);
                
                if (input.tagName === 'TEXTAREA') {
                    setTimeout(() => autoResizeTextarea(input), 0);
                }
            });
          
        }




        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        function updateNavButtons() {
            document.getElementById('prevButton').disabled = currentPatientIndex === 0;
            document.getElementById('nextButton').disabled = currentPatientIndex === patientData.length - 1;
        }

        function navigateDetails(step) {
            const newIndex = currentPatientIndex + step;
            if (newIndex >= 0 && newIndex < patientData.length) {
                showDetails(newIndex);
            }
        }

        function backToList() {
            document.getElementById('detailsView').style.display = 'none';
            displayRows();
        }

        function deleteCurrentEntry() {
            if (currentPatientIndex !== -1) {
                if (confirm("Are you sure you want to delete this entry?")) {
                    patientData.splice(currentPatientIndex, 1);
                    backToList();
                    displayRows();
                    saveToLocalStorage();
                }
            }
        }

        // ============ ADD/UPDATE ENTRIES ============
        function showAddEntryModal() {
            document.getElementById('addEntryModal').style.display = 'block';
            document.getElementById('entryTypeSelection').style.display = 'block';
            document.getElementById('addEntryForm').style.display = 'none';
            document.getElementById('pasteEntrySection').style.display = 'none';
        }

        function closeAddEntryModal() {
            document.getElementById('addEntryModal').style.display = 'none';
        }

        function showManualEntry() {
            document.getElementById('entryTypeSelection').style.display = 'none';
            document.getElementById('addEntryForm').style.display = 'block';
            generateNewEntryFields();
        }

        function showPasteEntry() {
            document.getElementById('entryTypeSelection').style.display = 'none';
            document.getElementById('pasteEntrySection').style.display = 'block';
            document.getElementById('pasteTextArea').focus();
        }

  function backToEntrySelection() {
    document.getElementById('entryTypeSelection').style.display = 'block';
    document.getElementById('addEntryForm').style.display = 'none';
    document.getElementById('pasteEntrySection').style.display = 'none';
    document.getElementById('updatePatientsSection').style.display = 'none';
    document.getElementById('cameraEntrySection').style.display = 'none';
    document.getElementById('pasteTextArea').value = '';
    document.getElementById('updateListDataModal').value = '';
    
    // Reset camera UI
    resetCameraUI();
}

























	    function generateNewEntryFields(type = 'Patient') {
    const newEntryFields = document.getElementById('newEntryFields');
    newEntryFields.innerHTML = '';
    
    // If type selection is needed
    if (!type || type === true) {
        const typeSelection = document.createElement('div');
        typeSelection.innerHTML = `
            <h3 style="margin-bottom: 1rem;">Select Entry Type:</h3>
            <div class="nav-buttons" style="margin-bottom: 1rem;">
                <button type="button" onclick="generateNewEntryFields('Patient')">Regular Patient</button>
                <button type="button" onclick="generateNewEntryFields('Consult')">Consult</button>
            </div>
        `;
        newEntryFields.appendChild(typeSelection);
        return;
    }
    
    const typeLabel = document.createElement('h3');
    typeLabel.textContent = `New ${type} Entry`;
    typeLabel.style.marginBottom = '1rem';
    typeLabel.style.color = type === 'Consult' ? 'var(--secondary)' : 'var(--primary)';
    newEntryFields.appendChild(typeLabel);
    
    const typeInput = document.createElement('input');
    typeInput.type = 'hidden';
    typeInput.value = type;
    typeInput.setAttribute('data-type', 'true');
    newEntryFields.appendChild(typeInput);

   // Define the fields you want to show - UPDATED ORDER
	const fieldsToShow = ['Name', 'RM', 'MRN', 'Problems', 'To do', 'Priority'];
    
    fieldsToShow.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        label.style.display = 'block';
        label.style.marginTop = '0.5rem';
        label.style.marginBottom = '0.25rem';
        label.style.color = 'var(--text-secondary)';
        label.style.fontSize = '0.9rem';
        newEntryFields.appendChild(label);
        
        const input = document.createElement('input');
        input.placeholder = `Enter ${header}...`;
        input.setAttribute('data-header', header);
        input.style.width = '100%';
        input.style.marginBottom = '0.75rem';
        newEntryFields.appendChild(input);
    });
}
















	    

















        function addEntry(event) {
            event.preventDefault();
            
            const newPatient = {};
            MASTER_HEADERS.forEach(header => {
                newPatient[header] = '';
            });
            
            const typeInput = document.querySelector('#newEntryFields input[data-type="true"]');
            if (typeInput) {
                newPatient.Type = typeInput.value;
            } else {
                newPatient.Type = 'Patient';
            }
            
            const fields = document.querySelectorAll('#newEntryFields input[data-header]');
            fields.forEach(field => {
                const header = field.getAttribute('data-header');
                newPatient[header] = field.value.trim();
            });

 if (newPatient['A/G']) {
        newPatient['Problems'] = newPatient['A/G'];
    }


            if (!newPatient.Name) {
                alert('Please enter at least a name.');
                return;
            }

            patientData.push(newPatient);
            displayRows();
            saveToLocalStorage();
            closeAddEntryModal();
            updateCensus();
        }








        function processPastedEntry() {
            const pastedText = document.getElementById('pasteTextArea').value.trim();
            
            if (!pastedText) {
                alert('Please paste some data first.');
                return;
            }

            const newPatients = parseCernerData(pastedText);
            
            if (newPatients && newPatients.length > 0) {
                newPatients.forEach(patient => {
                    patientData.push(patient);
                });
                
                displayRows();
                saveToLocalStorage();
                closeAddEntryModal();
                updateCensus();
                alert(`Successfully added ${newPatients.length} patient(s)!`);
            } else {
                alert('Could not parse the pasted data. Please check the format.');
            }
        }












function parseCernerData(text) {
  const lines = text.split('\n').filter(l => l.trim());
  const newPatients = [];

  lines.forEach(line => {
    const lc = line.toLowerCase();
    if (
      !line.trim() ||
      lc.includes('patient list') ||
      (lc.includes('room') && lc.includes('name'))
    ) return;

    // split on tabs or big spaces
    let cols = line.split('\t').filter(c => c.trim());
    if (cols.length < 3) {
      cols = line.split(/\s{2,}/).filter(c => c.trim());
    }
    if (cols.length < 2) return;

    // grab the basics
    let room = '', name = '', mrn = '', att = '';
    cols.forEach(c => {
      const t = c.trim();
      if (/^\d{5,10}$/.test(t) && !mrn)           mrn = t;
      else if (/^(WMC|ICU|CCU|[A-Z]{2,4})\s+/.test(t) && !room) room = t;
      else if (t.includes(',') && !name)           name = t;
      else if (/(MD|MBBS|DO|Dr\b)/i.test(t) && !att) att = t;
      else if (room && mrn && !name)               name = t;
    });
    if (!name) {
      const guess = cols.find(c => c.trim() && !/^\d+$/.test(c) && c.trim() !== room);
      name = guess ? guess.trim() : 'Unknown';
    }

    // build the blank patient object
    const p = {};
    MASTER_HEADERS.forEach(h => p[h] = '');
    p.Type = 'Patient';
    p.Name = name;
    p.RM   = room || 'TBD';
    p.MRN  = mrn  || '';
    p.Att  = att  || '';

    // ‚Äî‚Äî extract Age/Gender ‚Äî‚Äî
    let ag = '';
    const col7 = cols[6]?.trim() || '';
    // 1) single ‚Äú30F‚Äù in col7
    const m1 = /^(\d+)([MF])$/i.exec(col7);
    if (m1) {
      ag = m1[1] + m1[2].toUpperCase();
    }
    // 2) separate age in col7 + gender in col8
    else if (cols.length >= 8) {
      const age = cols[6].trim();
      const g   = cols[7].trim().toUpperCase();
      if (/^\d+$/.test(age) && /^[MF]$/.test(g)) {
        ag = age + g;
      }
    }

    // if we got it, seed both A/G _and_ Problems
    if (ag) {
      p['A/G']      = ag;
      p['Problems'] = ag;
    }

    newPatients.push(p);
  });

  return newPatients;
}




































function processUpdateList() {
    const text = document.getElementById('updateListData').value.trim();
    if (!text) {
        alert('Please paste the patient list');
        return;
    }

    const minimal = parseCernerData(text);
    if (minimal.length === 0) {
        alert('No valid patient entries found. Please check the format.');
        return;
    }

    // build lookup maps for your existing patients
    const byMRN  = new Map();
    const byName = new Map();
    patientData.forEach(p => {
        if (p.MRN)           byMRN.set(p.MRN, p);
        if (p.Name?.trim())  byName.set(p.Name.trim().toUpperCase(), p);
    });

    // now create a brand-new array in EXACTLY the pasted order
    const updated = minimal.map(mini => {
        // try MRN match, then Name match
        const key = mini.Name.trim().toUpperCase();
        const existing = byMRN.get(mini.MRN) || byName.get(key);

        if (existing) {
            // keep all existing fields, but update RM/MRN/Att (and A/G if you like)
            existing.RM   = mini.RM;
            existing.MRN  = mini.MRN;
            existing.Att  = mini.Att;
            if (mini['A/G']) existing['A/G'] = mini['A/G'];
            return existing;
        } else {
            // brand new patient: has RM, MRN, Att, Type, plus A/G
            return mini;
        }
    });

    // replace your master list
    patientData = updated;

    saveToLocalStorage();
    displayRows();
    closeUpdateListModal();

    alert(
        `List updated!\n\n` +
        `Total now: ${patientData.length}\n` +
        `Matched existing: ${minimal.filter(m => byMRN.has(m.MRN) || byName.has(m.Name.toUpperCase())).length}\n` +
        `New patients: ${minimal.filter(m => !(byMRN.has(m.MRN)||byName.has(m.Name.toUpperCase()))).length}`
    );
}





// Custom labels for consult mode
const CONSULT_MODE_LABELS = {
    'Name': 'Name',
    'RM': 'RM',
    'MRN': 'MRN',
    'A/G': 'A/G',
    'CC': 'CC/Level',
    'HPI': 'HPI/Mech',
    'ROS': 'ROS/1-2o',
    'PMH': 'PMH',
    'Meds': 'Meds',
    'All': 'All',
    'Surg hx': 'SurgHx',
    'FSH': 'FSHCM#',
    'VIOLIN': 'VIOLIN',
    'PE': 'PE',
    'To do': 'To Do',
    'Priority': 'Priority'
};



















        // ============ CONSULT MODE FUNCTIONS ============
        function updateConvertButton() {
            const patient = patientData[currentPatientIndex];
            const btn = document.getElementById('convertTypeBtn');
            if (btn) {
                if (patient.Type === 'Consult') {
                    btn.textContent = 'üîÑ Convert to Patient';
                } else {
                    btn.textContent = 'üîÑ Convert to Consult';
                }
            }
        }








		function convertEntryType() {
    const patient = patientData[currentPatientIndex];
    
    if (patient.Type === 'Consult') {
        if (confirm('Convert this consult to a regular patient?')) {
            patient.Type = 'Patient';
            if (!patient.Problems && patient.HPI) {
                patient.Problems = patient.HPI;
            }
            saveToLocalStorage();
            switchView('consult');
            displayRows();
        }
    } else {
        if (confirm('Convert this patient to a consult?')) {
            patient.Type = 'Consult';
            if (!patient.HPI && patient.Problems) {
                patient.HPI = patient.Problems;
            }
            
            // AUTO-ASSIGN PRIORITY 1 WHEN CONVERTING TO CONSULT
            const consultFields = ['CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'PE'];
            const hasConsultData = consultFields.some(field => patient[field] && patient[field].trim());
            if (hasConsultData && (!patient.Priority || patient.Priority.trim() === '')) {
                patient.Priority = '1'; // Set to urgent/red when converting to consult with data
            }
            
            saveToLocalStorage();
            switchView('consult');
            displayRows();
        }
    }
}
		


















































		


















		
        function exportToRTF(type) {
            if (currentPatientIndex === -1) return;
            
            const patient = patientData[currentPatientIndex];
            
            if (patient.Type !== 'Consult') {
                alert("This is a regular patient entry. Convert to consult first to generate consult/trauma notes.");
                return;
            }
            
            let noteText = "";
            const ageGender = patient['A/G'] || '';
            const cc = patient.CC || '';
            const hpi = patient.HPI || '';
            const ros = patient.ROS || '';
            const pmh = patient.PMH || '';
            const meds = patient.Meds || 'denies';
            const all = patient.All || 'denies';
            const surghx = patient['Surg hx'] || 'denies';
            const fsh = patient.FSH || 'denies';
            const violin = patient.VIOLIN || '';
            const pe = patient.PE || '';
            const plan = patient['To do'] || '';

            const pmhPhrase = pmh ? `with PMH ${pmh}` : "with no PMH";
            let finalLine = `\\i Discussed with Attending Physician\\i0\\par .supp2\\par`;

            if (type === "consult") {
                noteText = 
`\\b\\ul Surgery Initial Consultation Note:\\ul0\\b0\\par\\par
\\b\\ul CC:\\ul0\\b0  ${cc}\\par\\par
\\b\\ul Subjective:\\ul0\\b0\\par
\\b HPI: \\b0  ${ageGender} ${pmhPhrase} ${hpi}\\par\\par
\\b ROS: \\b0  ${ros}\\par.rosgen\\par\\par
\\b Meds: \\b0   ${meds}\\par
\\b All: \\b0  ${all}\\par
\\b Surghx: \\b0   ${surghx}\\par
\\b FamHx/Sochx/HCM:  \\b0  ${fsh}\\par\\par
\\b\\ul Objective:\\ul0\\b0\\par
\\b Physical Exam: \\b0  ${pe}\\par.pe\\par
\\b  Labs/imaging: \\b0   ${violin}\\par\\par
\\b\\ul Assessment:\\ul0\\b0\\par
${ageGender} ${pmhPhrase}, surgery consulted for ${cc}\\par\\par
\\b\\ul Plan:\\ul0\\b0\\par
${plan}\\par.plan\\par
${finalLine}`;
            } else if (type === "trauma") {
                noteText =
`\\b\\ul Trauma Initial Evaluation/Consult Note:\\ul0\\b0\\par\\par
\\b\\ul Activation: \\ul0\\b0 ${cc}\\par\\par
\\b\\ul HPI:\\ul0\\b0\\par
${ageGender} ${pmhPhrase} s/p ${hpi}\\par
\\b Primary Survey:\\b0  Airway intact. b/l breath sounds present. Hemodynamically stable, palpable femoral/radial pulses, extremities wwp, GCS 15 (E4 V5 M6)\\par
\\b Secondary Survey:\\b0  ${ros}\\par
\\b FAST:\\b0  no intra-abdominal free fluid noted\\par
\\b CXR:\\b0  no HTX, no PTX\\par
\\b Pelvic XR:\\b0  no obvious fractures or dislocation\\par\\par
\\b Meds:\\b0  ${meds}\\par
\\b All:\\b0  ${all}\\par
\\b Surghx:\\b0  ${surghx}\\par
\\b FamHx/Sochx/HCM:\\b0  ${fsh}\\par\\par
\\b\\ul Objective:\\ul0\\b0\\par
\\b Physical Exam: \\b0  ${pe}\\par.petrauma\\par
.frailty\\par\\par
\\b\\ul Assessment:\\ul0\\b0\\par
${ageGender} ${pmhPhrase} s/p ${hpi}\\par
INJURIES:\\par${violin}\\par\\par
\\b\\ul Plan:\\ul0\\b0\\par
${plan}\\par.plantrauma\\par
${finalLine}`;
            }

            const now = new Date();
            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
            const filename = type === "consult" ? `consult_note_${timestamp}.rtf` : `trauma_note_${timestamp}.rtf`;

            const rtf = `{\\rtf1\\ansi\\deff0\n${noteText}}`;
            downloadFile(rtf, filename, 'application/rtf');
        }

        // ============ CHART CHECK MODE FUNCTIONS ============













function updatePOD() {
    // Try multiple possible field IDs for tab mode vs regular mode
    let problemsField = document.getElementById('field_Problems') || 
                       document.querySelector('[id*="Problems"]') ||
                       document.querySelector('textarea[id*="field_Problems"]');
    
    if (!problemsField) {
        alert('Problems field not found. Make sure you are in the Clinical tab or Details view.');
        return;
    }
    
    const problemsText = problemsField.value;
    if (!problemsText || !problemsText.trim()) {
        alert('No problems text found. Please enter some text first.');
        return;
    }
    
    const lines = problemsText.split('\n');
    
    // Find if there's a date anywhere in the problems section
    let surgeryDate = null;
    let dateMatch = null;
    let dateLineIndex = -1;
    
    // Look for dates in multiple formats
    for (let i = 0; i < lines.length; i++) {
        // Try multiple date formats
        // Format 1: (MM/DD) or MM/DD
        dateMatch = lines[i].match(/\(?(\d{1,2})\/(\d{1,2})\)?/);
        
        // Format 2: MM/DD/YY or MM/DD/YYYY
        if (!dateMatch) {
            dateMatch = lines[i].match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
            if (dateMatch) {
                // We have year information
                const month = parseInt(dateMatch[1]);
                const day = parseInt(dateMatch[2]);
                const year = parseInt(dateMatch[3]);
                const fullYear = year < 100 ? 2000 + year : year;
                surgeryDate = new Date(fullYear, month - 1, day);
                dateLineIndex = i;
                break;
            }
        }
        
        if (dateMatch && !surgeryDate) {
            const month = parseInt(dateMatch[1]);
            const day = parseInt(dateMatch[2]);
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            
            // Create date object for the surgery date
            surgeryDate = new Date(currentYear, month - 1, day);
            
            // If surgery date is in the future, it's probably from last year
            if (surgeryDate > currentDate) {
                surgeryDate.setFullYear(currentYear - 1);
            }
            dateLineIndex = i;
            break;
        }
    }
    
    if (!surgeryDate) {
        alert('No date found in the problems section.\n\nPlease add a date in one of these formats:\n- MM/DD (e.g., 12/25)\n- (MM/DD) (e.g., (12/25))\n- MM/DD/YY (e.g., 12/25/24)\n- MM/DD/YYYY (e.g., 12/25/2024)');
        return;
    }
    
    // Calculate days difference
    const currentDate = new Date();
    const diffTime = currentDate - surgeryDate;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    console.log('Surgery date:', surgeryDate);
    console.log('Current date:', currentDate);
    console.log('POD:', diffDays);
    
    // Look for existing POD in any line
    let podLineIndex = -1;
    let podMatch = null;
    for (let i = 0; i < lines.length; i++) {
        podMatch = lines[i].match(/POD\s*\d+/i);
        if (podMatch) {
            podLineIndex = i;
            break;
        }
    }
    
    // Update or add POD
    if (podLineIndex !== -1) {
        // Update existing POD line
        lines[podLineIndex] = lines[podLineIndex].replace(/POD\s*\d+/i, `POD ${diffDays}`);
    } else {
        // Add POD at the beginning of the second line
        if (lines.length === 1) {
            // If there's only one line, add POD as a new second line
            lines.push(`POD ${diffDays}`);
        } else if (lines.length >= 2) {
            // If there's already a second line, prepend POD to it
            const secondLine = lines[1].trim();
            if (secondLine) {
                // If second line has content, add POD at the beginning with a space
                lines[1] = `POD ${diffDays} ${secondLine}`;
            } else {
                // If second line is empty, just set it to POD
                lines[1] = `POD ${diffDays}`;
            }
        }
    }
    
    // Update the textarea
    problemsField.value = lines.join('\n');
    autoResizeTextarea(problemsField);
    
    // Save the updated value
    patientData[currentPatientIndex].Problems = problemsField.value;
    saveToLocalStorage();
    
    // Format the date nicely for the alert
    const formattedDate = surgeryDate.toLocaleDateString('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    });
    
    alert(`POD updated to ${diffDays}\n\nCalculated from surgery date: ${formattedDate}\nCurrent date: ${currentDate.toLocaleDateString('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    })}`);
}







function showImportModal() {
    document.getElementById('importModal').style.display = 'block';
    
    // Always clear the textarea - don't load any existing data
    document.getElementById('importData').value = '';
    
    // Reset the paste button to its original state
    resetPasteButton();
    

}


        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
        }

























		function processImportedData() {
    const importText = document.getElementById('importData').value;
    if (!importText) return;
    
    console.log('Processing new import data...');
    
    // FORCE CLEAR ALL CACHED DATA
    const patient = patientData[currentPatientIndex];
    patient.VIOLIN = '';
    patient.ImportedData = '';
    patient.LabData = '';
    labData = {};
    lastImportedData = '';
    
    // Clear the textarea immediately
    const violinField = document.getElementById('field_VIOLIN') || 
                       document.querySelector('textarea[id*="VIOLIN"]');
    if (violinField) {
        violinField.value = 'Processing...';
    }
    
    // Process new data
    patient.ImportedData = importText;
    lastImportedData = importText;
    
    labData = extractLabValues(importText);
    const fishbone = generateFishbone(labData);
    
    // Update patient data
    patient.VIOLIN = fishbone;
    patient.LabData = JSON.stringify(labData);
    
    // Update textarea
    if (violinField) {
        violinField.value = fishbone;
        autoResizeTextarea(violinField);
    }
    
 
    
    saveToLocalStorage();
    closeImportModal();
    
// Force refresh ALL displays regardless of mode
setTimeout(() => {
    // Update the textarea field directly
    const violinField = document.getElementById('field_VIOLIN') || 
                       document.querySelector('textarea[id*="VIOLIN"]');
    if (violinField) {
        violinField.value = fishbone;
        autoResizeTextarea(violinField);
    }
    
    // Refresh chart check display if in that mode
    if (currentViewMode === 'chartcheck') {
        refreshViolinDisplay();
    }
    
    // Also try to refresh basic mode fishbone
    const fishboneContainer = document.getElementById('fishboneDisplay');
    if (fishboneContainer) {
        showFishboneInline();
    }
}, 100);

// Update the fishbone display
    setTimeout(() => {
        updateViolinDisplay();
    }, 100);

			
}












































        function generateTableView() {
            if (!labData || Object.keys(labData).length === 0) {
                document.getElementById('tableContainer').innerHTML = '<p>No lab data available. Please import data first.</p>';
                return;
            }
            
            let tableHTML = '<table class="data-table">';
            tableHTML += '<tr><th>Parameter</th>';
            
            const maxValues = Math.max(
                ...Object.values(labData.labs || {}).map(arr => arr ? arr.length : 0),
                ...Object.values(labData.vitals || {}).map(arr => arr ? arr.length : 0)
            );
            
            for (let i = 0; i < maxValues; i++) {
                tableHTML += `<th>Value ${i + 1}</th>`;
            }
            tableHTML += '</tr>';
            
            // Add vitals
            if (labData.vitals) {
                if (labData.vitals.temp) {
                    tableHTML += '<tr><td>Temperature</td>';
                    labData.vitals.temp.forEach(val => {
                        tableHTML += `<td>${val}¬∞C</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.hr) {
                    tableHTML += '<tr><td>Heart Rate</td>';
                    labData.vitals.hr.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.sbp) {
                    tableHTML += '<tr><td>Systolic BP</td>';
                    labData.vitals.sbp.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.dbp) {
                    tableHTML += '<tr><td>Diastolic BP</td>';
                    labData.vitals.dbp.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.o2) {
                    tableHTML += '<tr><td>O2 Saturation</td>';
                    labData.vitals.o2.forEach(val => {
                        tableHTML += `<td>${val}%</td>`;
                    });
                    tableHTML += '</tr>';
                }
            }
            
            // Add labs
            const labNames = {
                'wbc': 'WBC',
                'hgb': 'Hemoglobin',
                'hct': 'Hematocrit',
                'plt': 'Platelets',
                'na': 'Sodium',
                'k': 'Potassium',
                'cl': 'Chloride',
                'co2': 'CO2',
                'bun': 'BUN',
                'cr': 'Creatinine',
                'glu': 'Glucose',
                'ca': 'Calcium',
                'mg': 'Magnesium',
                'phos': 'Phosphorus',
                'ph': 'pH',
                'pco2': 'pCO2',
                'po2': 'pO2',
                'bicarb': 'Bicarbonate',
                'lactate': 'Lactic Acid',
                'ast': 'AST',
                'alt': 'ALT',
                'tbili': 'Total Bilirubin',
                'dbili': 'Direct Bilirubin',
                'alkphos': 'Alk Phos',
                'ggt': 'GGT'
            };
            
            if (labData.labs) {
                for (const [key, name] of Object.entries(labNames)) {
                    if (labData.labs[key]) {
                        tableHTML += `<tr><td>${name}</td>`;
                        labData.labs[key].forEach(val => {
                            tableHTML += `<td>${val}</td>`;
                        });
                        tableHTML += '</tr>';
                    }
                }
            }
            
            tableHTML += '</table>';
            document.getElementById('tableContainer').innerHTML = tableHTML;
        }




















































function showVitalsTable() {
    document.getElementById('graphModal').style.display = 'block';
    generateVitalsTable();
}

















































function generateVitalsTable() {
    const container = document.getElementById('vitalChart');
    
    if (!lastImportedData) {
        container.innerHTML = '<p>No vital signs data available. Please import data first.</p>';
        return;
    }
    
    // Extract vital signs with timestamps
    const vitalReadings = [];
    const timeSet = new Set();
    
    // Extract temperature readings
    const tempRegex = /Temperature\s*(?:Temporal Artery|Axillary)?:\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    let match;
    while ((match = tempRegex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        vitalReadings.push({
            type: 'Temperature',
            value: parseFloat(match[1]),
            unit: '¬∞C',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: parseFloat(match[1]) > 38 || parseFloat(match[1]) < 35
        });
    }
    
    // Extract heart rate readings
    const hrRegex = /(?:Heart Rate|Heart Rate Monitored|Apical Heart Rate).*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = hrRegex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        const hr = parseInt(match[1]);
        vitalReadings.push({
            type: 'Heart Rate',
            value: hr,
            unit: 'bpm',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: hr > 100 || hr < 60
        });
    }










  










// Extract blood pressure readings - SEPARATE PATTERNS
// First, collect all systolic readings
const systolicReadings = {};
const systolicRegex = /Systolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
while ((match = systolicRegex.exec(lastImportedData)) !== null) {
    const timeKey = `${match[2]} ${match[3]}`;
    systolicReadings[timeKey] = parseInt(match[1]);
}

// Then collect all diastolic readings
const diastolicReadings = {};
const diastolicRegex = /Diastolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
while ((match = diastolicRegex.exec(lastImportedData)) !== null) {
    const timeKey = `${match[2]} ${match[3]}`;
    diastolicReadings[timeKey] = parseInt(match[1]);
}

// Now match systolic and diastolic by timestamp
Object.keys(systolicReadings).forEach(timeKey => {
    timeSet.add(timeKey);
    const sbp = systolicReadings[timeKey];
    const dbp = diastolicReadings[timeKey];
    
    // Parse the date
    const [dateStr, timeStr] = timeKey.split(' ');
    const [month, day, year] = dateStr.split('/');
    const datetime = new Date(`20${year}-${month}-${day} ${timeStr}`);
    
    // Add systolic reading
    vitalReadings.push({
        type: 'Systolic BP',
        value: sbp,
        unit: 'mmHg',
        time: timeKey,
        datetime: datetime,
        abnormal: sbp < 90 || sbp > 180
    });
    
    // Add diastolic reading if it exists for this timestamp
    if (dbp !== undefined) {
        vitalReadings.push({
            type: 'Diastolic BP',
            value: dbp,
            unit: 'mmHg',
            time: timeKey,
            datetime: datetime,
            abnormal: dbp < 60 || dbp > 120
        });
    }
});

// Also check for any diastolic readings without matching systolic
Object.keys(diastolicReadings).forEach(timeKey => {
    if (!systolicReadings[timeKey]) {
        timeSet.add(timeKey);
        const dbp = diastolicReadings[timeKey];
        const [dateStr, timeStr] = timeKey.split(' ');
        const [month, day, year] = dateStr.split('/');
        const datetime = new Date(`20${year}-${month}-${day} ${timeStr}`);
        
        vitalReadings.push({
            type: 'Diastolic BP',
            value: dbp,
            unit: 'mmHg',
            time: timeKey,
            datetime: datetime,
            abnormal: dbp < 60 || dbp > 120
        });
    }
});






















    
    // Extract O2 saturation readings
    const o2Regex = /O2 Saturation.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = o2Regex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        const o2 = parseInt(match[1]);
        vitalReadings.push({
            type: 'O2 Saturation',
            value: o2,
            unit: '%',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: o2 < 92
        });
    }
    
    // Extract I/O data
    const ioData = extractIntakeOutputData(lastImportedData);
    
    // Add intake readings
    if (ioData.intakes.enteral && ioData.intakes.enteral.length > 0) {
        ioData.intakes.enteral.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Enteral Feeding',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    if (ioData.intakes.bloodProducts && ioData.intakes.bloodProducts.length > 0) {
        ioData.intakes.bloodProducts.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Blood Products',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    if (ioData.intakes.other && ioData.intakes.other.length > 0) {
        ioData.intakes.other.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: entry.description || 'Other Intake',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    // Add output readings
    if (ioData.outputs.urine && ioData.outputs.urine.length > 0) {
        ioData.outputs.urine.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Urine Output',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }




    
  // Add drain outputs
    Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
        if (entries && entries.length > 0) {
            const cleanDrainType = drainType.replace(/^Other:\s*/i, '');
            entries.forEach(entry => {
                const timeKey = entry.dateTimeStr;
                timeSet.add(timeKey);
                vitalReadings.push({
                    type: cleanDrainType,
                    value: entry.volume,
                    unit: 'mL',
                    time: timeKey,
                    datetime: entry.dateTime,
                    abnormal: entry.volume > 100
                });
            });
        }
    });
    
    // Process count data and add to vital readings (MOVED HERE!)
    Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
        if (entries && entries.length > 0) {
            entries.forEach(entry => {
                const timeKey = entry.dateTimeStr;
                timeSet.add(timeKey);
                vitalReadings.push({
                    type: countType,
                    value: entry.count,
                    unit: 'count',
                    time: timeKey,
                    datetime: entry.dateTime,
                    abnormal: countType.toLowerCase().includes('stool') && entry.count > 1
                });
            });
        }
    });


	
    // Convert time set to sorted array
    const now = new Date();
    const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
    
    const times = Array.from(timeSet)
        .filter(timeStr => {
            const parts = timeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (!parts) return false;
            const dt = new Date(`20${parts[3]}-${parts[1]}-${parts[2]} ${parts[4]}:${parts[5]}:${parts[6]}`);
            return dt >= twentyFourHoursAgo && dt <= now;
        })
        .sort((a, b) => {
            const dateA = new Date(a.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '20$3-$1-$2'));
            const dateB = new Date(b.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '20$3-$1-$2'));
            return dateB - dateA; // Most recent first
        });
    
    if (times.length === 0) {
        container.innerHTML = '<p>No vital signs or I/O data with timestamps found in the last 24 hours.</p>';
        return;
    }
    
    // Get all unique vital types and organize them by category
    const allTypes = [...new Set(vitalReadings.map(r => r.type))];
    
// Categorize the types
const vitalTypes = ['Temperature', 'Heart Rate', 'Systolic BP', 'Diastolic BP', 'O2 Saturation'];
const intakeTypes = allTypes.filter(t => 
    t.includes('Enteral') || t.includes('Blood Product') || 
    (vitalReadings.find(r => r.type === t && ioData.intakes.other && 
     ioData.intakes.other.some(i => i.description === t)))
);
const countTypes = allTypes.filter(t => t.includes('Count'));
const outputTypes = allTypes.filter(t => 
    !vitalTypes.includes(t) && !intakeTypes.includes(t) && !countTypes.includes(t)
);






    
    // Build the VERTICAL table HTML
    let tableHTML = `
        <h2 style="margin-bottom: 1rem; text-align: center;">Vital Signs & I/O Table (Last 24 Hours)</h2>
        <div style="overflow: auto; max-height: 80vh; width: 100%;">
            <table style="border-collapse: collapse; width: 100%; background: var(--card-bg); min-width: 800px;">
                <thead style="position: sticky; top: 0; background: var(--primary); z-index: 10;">
                    <tr>
                        <th rowspan="2" style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; min-width: 120px; position: sticky; left: 0; z-index: 11;">Date/Time</th>`;
    
    // Add section headers
    if (vitalTypes.length > 0) {
        tableHTML += `<th colspan="${vitalTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; text-align: center;">VITAL SIGNS</th>`;
    }
    if (intakeTypes.length > 0) {
        tableHTML += `<th colspan="${intakeTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--secondary); color: white; text-align: center;">INTAKES</th>`;
    }
    if (outputTypes.length > 0) {
        tableHTML += `<th colspan="${outputTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--danger); color: white; text-align: center;">OUTPUTS</th>`;
    }

if (countTypes.length > 0) {
    tableHTML += `<th colspan="${countTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--accent-5); color: white; text-align: center;">COUNTS</th>`;
}


    
    tableHTML += `</tr><tr>`;
    
    // Add individual column headers
    vitalTypes.forEach(vitalType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${vitalType}</th>`;
    });
    
    intakeTypes.forEach(intakeType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--secondary); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${intakeType}</th>`;
    });
    
    outputTypes.forEach(outputType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--danger); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${outputType}</th>`;
    });


countTypes.forEach(countType => {
    tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--accent-5); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${countType}</th>`;
});



    
    tableHTML += `</tr></thead><tbody>`;
    
    // Add rows for each time point
    times.forEach((time, index) => {
        const shortTime = time.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '$1/$2').replace(/:00$/, '');
        const rowStyle = index % 2 === 0 ? 'background: var(--card-bg);' : 'background: rgba(255,255,255,0.05);';
        
        tableHTML += `<tr style="${rowStyle}">`;
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; font-weight: bold; position: sticky; left: 0; background: var(--card-bg); z-index: 1;">${shortTime}</td>`;
        
        // Add vital signs data
        vitalTypes.forEach(vitalType => {
            const reading = vitalReadings.find(r => r.type === vitalType && r.time === time);
            if (reading) {
                const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
                let displayValue = reading.value;
                
                if (vitalType === 'Temperature' && !displayValue.toString().includes('¬∞')) {
                    displayValue = `${reading.value}¬∞C`;
                } else if (vitalType === 'O2 Saturation' && !displayValue.toString().includes('%')) {
                    displayValue = `${reading.value}%`;
                }
                
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; ${style}">${displayValue}</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });
        
        // Add intake data
        intakeTypes.forEach(intakeType => {
            const reading = vitalReadings.find(r => r.type === intakeType && r.time === time);
            if (reading) {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(6, 182, 212, 0.1);">${reading.value} mL</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });
        
        // Add output data
        outputTypes.forEach(outputType => {
            const reading = vitalReadings.find(r => r.type === outputType && r.time === time);
            if (reading) {
                const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(239, 68, 68, 0.1); ${style}">${reading.value} mL</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });


// Add count data
countTypes.forEach(countType => {
    const reading = vitalReadings.find(r => r.type === countType && r.time === time);
    if (reading) {
        const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(255, 128, 0, 0.1); ${style}">${reading.value}</td>`;
    } else {
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
    }
});



        
        tableHTML += `</tr>`;
    });
    
    tableHTML += `</tbody></table></div>`;
    
    // Add close button
    tableHTML += `<div style="margin-top: 1.5rem; text-align: center;"><button onclick="closeGraphModal()" style="padding: 0.75rem 2rem;">Close</button></div>`;
    
    container.innerHTML = tableHTML;
}
























































































        function updateOrders() {
            if (!lastImportedData) {
                alert('Please import data first using the Import Data button');
                return;
            }
            
            const orders = extractOrders(lastImportedData);
            const ordersField = document.getElementById('field_ORDERS');
            if (ordersField) {
                ordersField.value = orders;
                patientData[currentPatientIndex].ORDERS = orders;
                autoResizeTextarea(ordersField);
                saveToLocalStorage();
            }
        }

























function toggleOrdersView() {
    showFullOrders = !showFullOrders;
    renderOrdersTable();
}

function toggleTableView() {
    showAbbreviatedTable = !showAbbreviatedTable;
    renderOrdersTable();
}

function renderOrdersTable() {
    const fullOrdersDisplay = document.getElementById('fullOrdersDisplay');

    if (!fullOrdersDisplay) {
        console.error('fullOrdersDisplay element not found');
        return;
    }

    if (showFullOrders && (fullOrdersText || lastImportedData)) {
        // Create table-based full orders display
        const medsText = fullOrdersText || extractFullMeds(lastImportedData);

        if (!medsText || medsText.trim().length === 0) {
            fullOrdersDisplay.innerHTML = '<em style="color: var(--text-secondary);">No medication orders found in imported data.</em>';
            fullOrdersDisplay.classList.remove('hidden');
            return;
        }

        const dietMatch = lastImportedData ? lastImportedData.match(/DIET ORDER:\s*([^\n]+)/i) : null;

        let currentSection = 'Scheduled';
        const medsLines = medsText.split('\n');
        const categorizedMeds = {
            'nutrition': [],
            'pain': [],
            'antibiotics': [],
            'pressors': [],
            'anticoag': [],
            'neuro': [],
            'gi': [],
            'cardio': [],
            'endocrine': [],
            'misc': []
        };

        // Add diet order if found
        if (dietMatch) {
            categorizedMeds['nutrition'].push({
                text: `Diet: ${dietMatch[1].trim()}`,
                route: 'PO',
                isPRN: false
            });
        }

        medsLines.forEach(line => {
            const trimmedLine = line.trim();

            if (trimmedLine.toLowerCase().includes('scheduled:')) {
                currentSection = 'Scheduled';
                return;
            } else if (trimmedLine.toLowerCase().includes('prn:')) {
                currentSection = 'PRN';
                return;
            } else if (trimmedLine.toLowerCase().includes('continuous:')) {
                currentSection = 'Continuous';
                return;
            }

            if (!trimmedLine) return;

            const isPRN = currentSection === 'PRN';
            const lineLower = trimmedLine.toLowerCase();

            // For combination medications (e.g., "drug + carrier"), extract the first drug for categorization
            let drugForCategorization = lineLower;
            if (lineLower.includes(' + ')) {
                const firstPart = lineLower.split(' + ')[0].trim();
                drugForCategorization = firstPart;
            }

            // Determine route (IV, PO, SC, etc.)
            let route = 'PO'; // default
            if (lineLower.includes('intravenous') || lineLower.includes(' iv ') || lineLower.includes(',iv,') ||
                lineLower.includes('iv continuous') || lineLower.includes('iv push') || lineLower.match(/\biv\b/)) {
                route = 'IV';
            } else if (lineLower.includes('subcutaneous') || lineLower.includes(' sc ')) {
                route = 'SC';
            } else if (lineLower.includes('intramuscular') || lineLower.includes(' im ')) {
                route = 'IM';
            } else if (lineLower.includes('per rectum') || lineLower.includes(' pr ')) {
                route = 'PR';
            } else if (lineLower.includes('inhalation') || lineLower.includes('neb')) {
                route = 'INH';
            }

            const medObj = {
                text: trimmedLine,
                route: route,
                isPRN: isPRN
            };

            // Categorize medications - CHECK ACTIVE DRUGS FIRST before carrier fluids!
            // Pain medications
            if (drugForCategorization.match(/oxycodone|hydromorphone|acetaminophen|methocarbamol|baclofen|ibuprofen|ketorolac|tramadol|lidocaine|methadone|fentanyl|morphine|celecoxib|cyclobenzaprine|naproxen|hydrocodone|meperidine|codeine/i)) {
                categorizedMeds['pain'].push(medObj);
            }
            // Pressors and sedation - check BEFORE fluids
            else if (drugForCategorization.match(/norepinephrine|norEPINEPHrine|epinephrine|EPINEPHrine|vasopressin|phenylephrine|dopamine|dobutamine|propofol|midazolam|dexmedetomidine|dexmedeTOMIDine|lorazepam|diazepam|ketamine|angiotensin/i)) {
                categorizedMeds['pressors'].push(medObj);
            }
            // Heparin infusions - check BEFORE fluids
            else if (drugForCategorization.match(/heparin|enoxaparin/i)) {
                categorizedMeds['anticoag'].push(medObj);
            }
            // Insulin infusions - check BEFORE fluids (but Parenteral Nutrition goes to nutrition)
            else if (drugForCategorization.match(/insulin regular|insulin\s+\d+\s+unit/i) && !lineLower.includes('parenteral')) {
                categorizedMeds['endocrine'].push(medObj);
            }
            // Antibiotics
            else if (drugForCategorization.match(/cefepime|vancomycin|piperacillin|tazobactam|ceftriaxone|amoxicillin|ciprofloxacin|metronidazole|doxycycline|clindamycin|azithromycin|meropenem|levofloxacin|cephalexin|ampicillin|gentamicin|linezolid|ertapenem|trimethoprim|sulfamethoxazole|diflucan|fluconazole|daptomycin|ceftolozane|amphotericin|micafungin|cefazolin|ceftazidime|eravacycline|tobramycin|erythromycin/i)) {
                categorizedMeds['antibiotics'].push(medObj);
            }
            // Anticoagulation (oral anticoagulants)
            else if (drugForCategorization.match(/aspirin|clopidogrel|apixaban|warfarin|rivaroxaban|fondaparinux|ticagrelor|dabigatran|prasugrel/i)) {
                categorizedMeds['anticoag'].push(medObj);
            }
            // Neuro/Psych
            else if (drugForCategorization.match(/levetiracetam|keppra|phenytoin|dilantin|valproic|depakote|carbamazepine|lamotrigine|topiramate|gabapentin|pregabalin|lacosamide|haloperidol|quetiapine|olanzapine|risperidone|aripiprazole|ziprasidone|clozapine|lithium|sertraline|escitalopram|fluoxetine|paroxetine|citalopram|venlafaxine|duloxetine|bupropion|mirtazapine|trazodone|clonazepam|alprazolam/i)) {
                categorizedMeds['neuro'].push(medObj);
            }
            // GI
            else if (drugForCategorization.match(/ondansetron|pantoprazole|famotidine|omeprazole|esomeprazole|lansoprazole|ranitidine|docusate|senna|bisacodyl|polyethylene|miralax|metoclopramide|promethazine|prochlorperazine/i)) {
                categorizedMeds['gi'].push(medObj);
            }
            // Cardio/Pulm
            else if (drugForCategorization.match(/metoprolol|carvedilol|atenolol|labetalol|esmolol|lisinopril|enalapril|captopril|losartan|valsartan|amlodipine|diltiazem|nicardipine|hydralazine|furosemide|lasix|bumetanide|torsemide|spironolactone|albuterol|ipratropium|duoneb|nitroglycerin|isosorbide|digoxin|amiodarone|sotalol|flecainide|rosuvastatin|atorvastatin|simvastatin|pravastatin|lovastatin|fluvastatin|pitavastatin|crestor|lipitor|zocor/i)) {
                categorizedMeds['cardio'].push(medObj);
            }
            // Endocrine (other insulins and endocrine meds)
            else if (drugForCategorization.match(/insulin|lispro|aspart|glargine|lantus|detemir|levemir|degludec|tresiba|levothyroxine|synthroid|liothyronine|hydrocortisone|dexamethasone|decadron|hypoglycemia|glucagon/i)) {
                categorizedMeds['endocrine'].push(medObj);
            }
            // Nutrition/Fluids - checked LAST so active drugs aren't miscategorized
            else if (lineLower.match(/npo|lactated\s+ringer|lactated ringers|normal saline|parenteral nutrition|sodium chloride|dextrose\s+5%|dextrose\s+50%|plasmalyte|infant formula|pediatric|regular diet|clear liquid|renal|cardiac|diabetic|dysphagia|soft|full liquid|bariatric|albumin|tube feed|enteral/i)) {
                categorizedMeds['nutrition'].push(medObj);
            }
            else {
                categorizedMeds['misc'].push(medObj);
            }
        });

        // Medication abbreviation database
        const MED_ABBREVIATIONS = {
            'hydromorphone': 'D', 'oxycodone': 'O', 'morphine': 'M', 'fentanyl': 'F',
            'acetaminophen': 'T', 'ibuprofen': 'Ibu', 'ketorolac': 'Toradol',
            'cefepime': 'Cefepime', 'vancomycin': 'Vanc', 'piperacillin-tazobactam': 'Pip-Tazo',
            'piperacillin': 'Pip', 'meropenem': 'Mero', 'ceftriaxone': 'CTX',
            'azithromycin': 'Azithro', 'levofloxacin': 'Levo', 'ciprofloxacin': 'Cipro',
            'metronidazole': 'Flagyl', 'sulfamethoxazole-trimethoprim': 'TMP-SMX',
            'norepinephrine': 'Levo', 'epinephrine': 'Epi', 'vasopressin': 'Vaso',
            'propofol': 'Prop', 'midazolam': 'Versed', 'dexmedetomidine': 'Prec',
            'heparin': 'Hep', 'enoxaparin': 'Lovenox', 'warfarin': 'Coumadin',
            'aspirin': 'ASA', 'clopidogrel': 'Plavix',
            'levetiracetam': 'Keppra', 'phenytoin': 'Dilantin', 'gabapentin': 'Neurontin',
            'haloperidol': 'Haldol', 'quetiapine': 'Seroquel', 'olanzapine': 'Zyprexa',
            'ondansetron': 'Z', 'pantoprazole': 'Protonix', 'famotidine': 'Pepcid',
            'metoprolol': 'Metop', 'furosemide': 'Lasix', 'albuterol': 'Alb',
            'insulin lispro': 'Lispro', 'insulin regular': 'Reg', 'insulin glargine': 'Lantus',
            'sodium chloride 0.9%': 'NS', 'lactated ringer': 'LR', 'dextrose 5%': 'D5W'
        };

        // Helper function to abbreviate medication text
        function abbreviateMedText(medText) {
            let abbreviated = medText;
            const textLower = medText.toLowerCase();

            // Check for medication abbreviations
            for (let [fullName, abbrev] of Object.entries(MED_ABBREVIATIONS)) {
                if (textLower.includes(fullName.toLowerCase())) {
                    abbreviated = abbreviated.replace(new RegExp(fullName, 'gi'), abbrev);
                    break;
                }
            }

            // Extract dose and frequency
            const doseMatch = abbreviated.match(/(\d+(?:\.\d+)?)\s*(mg|mcg|g|unit\(s\)|units?|mL|mEq)/i);
            const freqMatch = abbreviated.match(/every\s+(\d+)\s+hours?|(\d+)\s+times?\s+(?:a\s+)?day|daily|BID|TID|QID/i);
            const routeMatch = abbreviated.match(/\b(Oral|Intravenous|Subcutaneous|IV|PO|SC)\b/i);

            let shortForm = abbreviated.split(' ')[0]; // Start with first word (likely the abbreviation)

            if (doseMatch) {
                shortForm += doseMatch[1] + doseMatch[2].replace('unit(s)', 'u').replace('units', 'u');
            }

            if (freqMatch) {
                if (freqMatch[1]) shortForm += ` Q${freqMatch[1]}`;
                else if (freqMatch[2]) {
                    const times = freqMatch[2];
                    if (times === '2') shortForm += ' BID';
                    else if (times === '3') shortForm += ' TID';
                    else if (times === '4') shortForm += ' QID';
                }
            }

            if (routeMatch) {
                const route = routeMatch[1].toUpperCase();
                if (route === 'ORAL') shortForm += ' PO';
                else if (route === 'INTRAVENOUS') shortForm += ' IV';
                else if (route === 'SUBCUTANEOUS') shortForm += ' SC';
                else shortForm += ` ${route}`;
            }

            return shortForm;
        }

        // Helper function to create category row with single medications column
        function createCategoryRow(categoryName, medList) {
            const poMeds = medList.filter(m => m.route === 'PO' || m.route === 'SC' || m.route === 'PR' ||
                                                m.route === 'INH' || m.route === 'IM');
            const ivMeds = medList.filter(m => m.route === 'IV');

            let html = '<tr>';
            html += `<td style="background: #1e1e1e; font-weight: 600; color: var(--primary); padding: 8px; border-bottom: 1px solid #333; vertical-align: top; width: 140px;">${categoryName}</td>`;

            // Single medications column with PO and IV/other subsections
            html += '<td style="padding: 8px; border-bottom: 1px solid #333; vertical-align: top; line-height: 1.6;">';

            // PO section
            if (poMeds.length > 0) {
                html += '<div style="margin-bottom: 0.5rem;"><strong style="color: #888; font-size: 10px;">PO:</strong></div>';
                poMeds.forEach(med => {
                    const color = med.isPRN ? '#ff6b6b' : 'var(--primary)';
                    const displayText = showAbbreviatedTable ? abbreviateMedText(med.text) : med.text;
                    html += `<div style="color: ${color}; margin-left: 0.5rem;">${displayText}</div>`;
                });
            }

            // IV/other section
            if (ivMeds.length > 0) {
                // Add spacing if there were PO meds
                if (poMeds.length > 0) {
                    html += '<div style="margin-top: 0.75rem; margin-bottom: 0.5rem;"><strong style="color: #888; font-size: 10px;">IV/other:</strong></div>';
                } else {
                    html += '<div style="margin-bottom: 0.5rem;"><strong style="color: #888; font-size: 10px;">IV/other:</strong></div>';
                }
                ivMeds.forEach(med => {
                    const color = med.isPRN ? '#ff6b6b' : '#ffa726';
                    const displayText = showAbbreviatedTable ? abbreviateMedText(med.text) : med.text;
                    html += `<div style="color: ${color}; margin-left: 0.5rem;">${displayText}</div>`;
                });
            }

            // If no meds at all
            if (poMeds.length === 0 && ivMeds.length === 0) {
                html += '<span style="color: #555; font-style: italic;">‚Äî</span>';
            }

            html += '</td>';
            html += '</tr>';
            return html;
        }

        // Build table HTML with toggle buttons
        let tableHTML = '<div style="background: var(--card-bg); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--primary);">';
        tableHTML += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">';
        tableHTML += '<strong style="color: var(--primary); font-size: 16px;">üìã Full Orders List</strong>';

        // Toggle buttons
        tableHTML += '<div style="display: flex; gap: 5px;">';
        tableHTML += `<button onclick="showAbbreviatedTable = true; renderOrdersTable();" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; background: ${showAbbreviatedTable ? 'var(--primary)' : '#444'}; color: ${showAbbreviatedTable ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-weight: ${showAbbreviatedTable ? '600' : '400'};">Abbreviated</button>`;
        tableHTML += `<button onclick="showAbbreviatedTable = false; renderOrdersTable();" style="padding: 0.4rem 0.8rem; font-size: 0.85rem; background: ${!showAbbreviatedTable ? 'var(--primary)' : '#444'}; color: ${!showAbbreviatedTable ? '#000' : '#fff'}; border: none; border-radius: 4px; cursor: pointer; font-weight: ${!showAbbreviatedTable ? '600' : '400'};">Full</button>`;
        tableHTML += '</div>';
        tableHTML += '</div>';

        tableHTML += '<table style="width: 100%; border-collapse: collapse; font-family: \'Courier New\', monospace; font-size: 11px; background: #252525; border-radius: 8px; overflow: hidden;">';
        tableHTML += '<thead><tr>';
        tableHTML += '<th style="background: linear-gradient(135deg, #2d5a7b 0%, #1e3a5f 100%); color: var(--primary); padding: 8px 10px; text-align: left; font-weight: 600; border-bottom: 2px solid var(--primary); width: 140px;">Category</th>';
        tableHTML += '<th style="background: linear-gradient(135deg, #2d5a7b 0%, #1e3a5f 100%); color: var(--primary); padding: 8px 10px; text-align: left; font-weight: 600; border-bottom: 2px solid var(--primary);">Medications</th>';
        tableHTML += '</tr></thead>';
        tableHTML += '<tbody>';

        tableHTML += createCategoryRow('Nutrition/Fluids', categorizedMeds['nutrition']);
        tableHTML += createCategoryRow('Pain', categorizedMeds['pain']);
        tableHTML += createCategoryRow('Antibiotics', categorizedMeds['antibiotics']);
        tableHTML += createCategoryRow('Pressors/Sedation', categorizedMeds['pressors']);
        tableHTML += createCategoryRow('Anticoagulation', categorizedMeds['anticoag']);
        tableHTML += createCategoryRow('Neuro/Psych', categorizedMeds['neuro']);
        tableHTML += createCategoryRow('GI', categorizedMeds['gi']);
        tableHTML += createCategoryRow('Cardio/Pulm', categorizedMeds['cardio']);
        tableHTML += createCategoryRow('Endocrine', categorizedMeds['endocrine']);
        tableHTML += createCategoryRow('MISC', categorizedMeds['misc']);

        tableHTML += '</tbody></table>';
        tableHTML += '</div>';

        fullOrdersDisplay.innerHTML = tableHTML;
        fullOrdersDisplay.classList.remove('hidden');
    } else {
        fullOrdersDisplay.classList.add('hidden');
    }
}






















        // ============ LAB DATA EXTRACTION FUNCTIONS ============




        function extractLabValues(text) {
            const data = {
                vitals: {},
                labs: {},
                dates: {},
                times: {},
                weight: null,
                intake: null,
                output: null,
                o2therapy: null,
                age: null
            };

            // Extract weight
            const weightMatch = text.match(/Weight Measured:\s*([\d.]+)\s*kg/i);
            if (weightMatch) {
                data.weight = parseFloat(weightMatch[1]);
            }

            // Extract intake and output
            const intakeMatch = text.match(/Intake\s*mL\s+([\d,]+(?:\.\d+)?)/);
            if (intakeMatch) {
                data.intake = parseFloat(intakeMatch[1].replace(/,/g, ''));
            }

            const outputMatch = text.match(/Output\s*mL\s+([\d,]+(?:\.\d+)?)/);
            if (outputMatch) {
                data.output = parseFloat(outputMatch[1].replace(/,/g, ''));
            }








// Helper: parse "MM/DD/YY HH:MM:SS" into a Date
function parseTS(dateStr, timeStr) {
  const [mo, day, yr] = dateStr.split('/').map(n => parseInt(n, 10));
  const [h, m, s]    = timeStr.split(':').map(n => parseInt(n, 10));
  return new Date(2000 + yr, mo - 1, day, h, m, s);
}

// Helper function to pick latest entry
function pickLatest(regex, text) {
  const arr = [];
  let mm;
  while ((mm = regex.exec(text)) !== null) {
    arr.push({
      val: mm[1].trim(),
      ts:  parseTS(mm[2], mm[3])
    });
  }
  if (!arr.length) return null;
  arr.sort((a,b) => a.ts - b.ts);
  return arr.pop().val;
}

// ‚Äî‚Äî‚Äî Oxygen Therapy ‚Äî‚Äî‚Äî
const o2Entries = [];
const o2Regex = /Oxygen Therapy:\s*(.+?)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
let m;
while ((m = o2Regex.exec(text)) !== null) {
  o2Entries.push({
    desc: m[1].trim(),
    ts:   parseTS(m[2], m[3])
  });
}

if (o2Entries.length) {
  // pick the latest
  o2Entries.sort((a, b) => a.ts - b.ts);
  const latest = o2Entries.pop();
  data.o2therapyRaw  = latest.desc;
  const rawLower = latest.desc.toLowerCase();

  // map to short codes
  if (/room air/i.test(rawLower)) {
    data.o2therapyCode = 'RA';
  } else if (/invasive mechanical ventilator/i.test(rawLower)) {
    data.o2therapyCode = 'Vent';
  } else if (/non-invasive mechanical ventilator/i.test(rawLower) || /bipap|cpap/i.test(rawLower)) {
    data.o2therapyCode = 'BiPAP/CPAP';
  } else if (/high[- ]?flow nasal cannula/i.test(rawLower)) {
    data.o2therapyCode = 'HFNC';
  } else if (/nasal cannula/i.test(rawLower) && !/high[- ]?flow/i.test(rawLower)) {
    data.o2therapyCode = 'NC';
  } else if (/non-?rebreather/i.test(rawLower)) {
    data.o2therapyCode = 'NRB';
  } else {
    data.o2therapyCode = 'O2';
  }
} // Close the if (o2Entries.length) block

// ‚Äî‚Äî‚Äî Oxygen Flow Rate ‚Äî‚Äî‚Äî
const flowEntries = [];
const flowRegex = /Oxygen Flow Rate:\s*([\d.]+\s*L\/min)\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi;
while ((m = flowRegex.exec(text)) !== null) {
  flowEntries.push({
    rate: m[1].trim(),
    ts:   parseTS(m[2], m[3])
  });
}
if (flowEntries.length) {
  flowEntries.sort((a, b) => a.ts - b.ts);
  data.o2flowRaw = flowEntries.pop().rate;
}










		// ‚Äî‚Äî‚Äî Ventilator Settings ‚Äî‚Äî‚Äî
data.ventModeRaw      = pickLatest(/Ventilator Mode:\s*([^(]+)\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventFrequencyRaw = pickLatest(/Ventilator Frequency(?:,\s*Mandatory)?:\s*(\d+)\s*br\/min\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventTidalRaw     = pickLatest(/Tidal Volume(?:,\s*Delivered)?:\s*(\d+)\s*mL\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventPeepRaw      = pickLatest(/Positive End Expiratory Pressure:\s*(\d+)\s*cmH2O\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventFiO2Raw      = pickLatest(/FIO2:\s*(\d+)\s*%\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);

// If we detected ventilator settings but o2therapyCode isn't set to 'Vent', set it
if (data.ventModeRaw && !data.o2therapyCode) {
    data.o2therapyCode = 'Vent';
    data.o2therapyRaw = 'Mechanical Ventilation';
}

















		


		

            // Extract age
            const ageMatch = text.match(/Age:\s*(\d+)\s*Years/i);
            if (ageMatch) {
                data.age = parseInt(ageMatch[1], 10);
            }




	// Extract vitals (only from last 24 hours)
            // Helper function to check if entry is within 24 hours
            const now = new Date();
            const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
            
            function isWithin24Hours(dateTimeStr) {
                const parts = dateTimeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
                if (!parts) return false;
                const dt = new Date(`20${parts[3]}-${parts[1]}-${parts[2]} ${parts[4]}:${parts[5]}:${parts[6]}`);
                return dt >= twentyFourHoursAgo && dt <= now;
            }
            
            // Extract temperature with timestamps
            const tempRegex = /Temperature\s*(?:Temporal Artery|Axillary)?:\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const tempValues = [];
            let tempMatch;
            while ((tempMatch = tempRegex.exec(text)) !== null) {
                const timeKey = `${tempMatch[2]} ${tempMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    tempValues.push(parseFloat(tempMatch[1]));
                }
            }
            if (tempValues.length > 0) {
                data.vitals.temp = tempValues;
            }
            
            // Extract heart rate with timestamps
            const hrRegex = /(?:Heart Rate|Heart Rate Monitored|Apical Heart Rate).*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const hrValues = [];
            let hrMatch;
            while ((hrMatch = hrRegex.exec(text)) !== null) {
                const timeKey = `${hrMatch[2]} ${hrMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    hrValues.push(parseInt(hrMatch[1]));
                }
            }
            if (hrValues.length > 0) {
                data.vitals.hr = hrValues;
            }
            
            // Extract systolic BP with timestamps
            const sbpRegex = /Systolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const sbpValues = [];
            let sbpMatch;
            while ((sbpMatch = sbpRegex.exec(text)) !== null) {
                const timeKey = `${sbpMatch[2]} ${sbpMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    sbpValues.push(parseInt(sbpMatch[1]));
                }
            }
            if (sbpValues.length > 0) {
                data.vitals.sbp = sbpValues;
            }
            
            // Extract diastolic BP with timestamps
            const dbpRegex = /Diastolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const dbpValues = [];
            let dbpMatch;
            while ((dbpMatch = dbpRegex.exec(text)) !== null) {
                const timeKey = `${dbpMatch[2]} ${dbpMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    dbpValues.push(parseInt(dbpMatch[1]));
                }
            }
            if (dbpValues.length > 0) {
                data.vitals.dbp = dbpValues;
            }
            
            // Extract O2 saturation with timestamps
            const o2SatRegex = /O2 Saturation.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const o2Values = [];
            let o2Match;
            while ((o2Match = o2SatRegex.exec(text)) !== null) {
                const timeKey = `${o2Match[2]} ${o2Match[3]}`;
                if (isWithin24Hours(timeKey)) {
                    o2Values.push(parseInt(o2Match[1]));
                }
            }
            if (o2Values.length > 0) {
                data.vitals.o2 = o2Values;
            }





// Extract lab values with dates
const extractLabValue = (pattern, name) => {
    const matches = text.match(new RegExp(pattern + '.*?([\\d.]+).*?\\((\\d{2}/\\d{2}/\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2})\\)', 'gi'));
    if (matches && matches.length > 0) {
        const values = [];
        const dates = [];
        const times = [];
        
        matches.forEach(match => {
            const valueMatch = match.match(/:\s*[<>]?\s*([\d.]+)/);
            const dateTimeMatch = match.match(/\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/);
            if (valueMatch) {
                values.push(parseFloat(valueMatch[1]));
                if (dateTimeMatch) {
                    dates.push(dateTimeMatch[1]);
                    times.push(dateTimeMatch[2]);
                }
            }
        });

        data.labs[name] = values;
        
        // Store BOTH formats for backward compatibility
        if (dates.length > 0) {
            data.dates[name] = dates[0];  // ‚Üê Keep this for existing code
            data.times[name] = times[0];  // ‚Üê Keep this for existing code
            
            // ADD these new arrays for the table hover feature
            if (!data.datesArray) data.datesArray = {};
            if (!data.timesArray) data.timesArray = {};
            data.datesArray[name] = dates;  // ‚Üê New: full array
            data.timesArray[name] = times;  // ‚Üê New: full array
        }
    }
};

			

   






            // Extract all lab values
            extractLabValue('WBC:', 'wbc');
            extractLabValue('Hgb:', 'hgb');
            extractLabValue('Hct:', 'hct');
            extractLabValue('Platelet Count:', 'plt');
            extractLabValue('Sodium:', 'na');
            extractLabValue('Potassium:', 'k');
            extractLabValue('Chloride:', 'cl');
            extractLabValue('CO2:', 'co2');
            extractLabValue('BUN:', 'bun');
            extractLabValue('Creatinine:', 'cr');
            extractLabValue('Glucose:', 'glu');
            extractLabValue('Calcium, Ionized:', 'ca');
            extractLabValue('Ionized Calcium:', 'ca');
            
            // If no ionized calcium, try total calcium
            if (!data.labs.ca || data.labs.ca.length === 0) {
                extractLabValue('Calcium:', 'totalCa');
                extractLabValue('Albumin:', 'albumin');
                
                if (data.labs.totalCa && data.labs.totalCa.length > 0 && 
                    data.labs.albumin && data.labs.albumin.length > 0) {
                    const totalCa = data.labs.totalCa[0];
                    const albumin = data.labs.albumin[0];
                    const correctedCa = totalCa + 0.8 * (4.0 - albumin);
                    data.labs.ca = [parseFloat(correctedCa.toFixed(2))];
                    data.labs.caType = 'corrected';
                    if (data.dates.totalCa) {
                        data.dates.ca = data.dates.totalCa;
                        data.times.ca = data.times.totalCa;
                    }
                }
            }
            
            extractLabValue('Magnesium Level:', 'mg');
            extractLabValue('Inorganic Phosphorus:', 'phos');
            
            // Extract ABG values
            extractLabValue('pH:', 'ph');
            extractLabValue('pC02:', 'pco2');
            extractLabValue('PO2:', 'po2');
            extractLabValue('Bicarbonate:', 'bicarb');
            extractLabValue('Lactic Acid:', 'lactate');
            
            // Extract LFT values
            extractLabValue('AST:', 'ast');
            extractLabValue('ALT:', 'alt');
	    extractLabValue('Total Bilirubin:', 'tbil');  // Changed from 'tbili' to 'tbil'
            extractLabValue('Direct Bilirubin:', 'dbil'); // Changed from 'dbili' to 'dbil'

            extractLabValue('Alkaline Phosphatase:', 'alk'); // Changed from 'alkphos' to 'alk'

            extractLabValue('GGT:', 'ggt');


           // Add coagulation lab extractions (these were missing)
          extractLabValue('Prothrombin Time:', 'pt');
          extractLabValue('INR:', 'inr');
         extractLabValue('APTT:', 'ptt');
         extractLabValue('Fibrinogen:', 'fib');

extractLabValue('Troponin I, High Sensitivity:', 'trop');

// Extract pancreatic enzymes
extractLabValue('Amylase:', 'amylase');
extractLabValue('Lipase:', 'lipase');
extractLabValue('Albumin:', 'albumin');
extractLabValue('Prealbumin:', 'prealbumin');




            return data;
        }


































function extractIntakeOutputData(text) {
    console.log('extractIntakeOutputData called with text length:', text ? text.length : 0);
    
const ioData = {
    intakes: {
        enteral: [],
        bloodProducts: [],
        other: []
    },
    outputs: {
        urine: [],
        urinaryCatheter: false,
        lastUrineTime: null,
        drains: {},
        other: {}
    },
    counts: {},
    elapsedHours: null,
    cutoffTime: null,
    totalIntake: null,
    totalOutput: null,
    fluidBalance: null
};

    // Extract intake/output section
    const ioMatch = text.match(/<Intake and Output Start>([\s\S]*?)<Intake and Output End>/i);
    if (!ioMatch) {
        console.log('No I/O section found in text');
        return ioData;
    }
    
    console.log('Found I/O section');
    const ioText = ioMatch[1];
    
    // Split into intake and output sections
    const intakeMatch = ioText.match(/Intake\s*\n([\s\S]*?)(?=Output|$)/i);
    const outputMatch = ioText.match(/Output\s*\n([\s\S]*?)$/i);
    
    const intakeSection = intakeMatch ? intakeMatch[1] : '';
    const outputSection = outputMatch ? outputMatch[1] : '';

    // Get current time and calculate 7 AM cutoff
    const now = new Date();
    const currentHour = now.getHours();
    const cutoffDate = new Date(now);
    
    if (currentHour < 7) {
        // If before 7 AM, go back to 7 AM yesterday
        cutoffDate.setDate(cutoffDate.getDate() - 1);
    }
    cutoffDate.setHours(7, 0, 0, 0);
    
    console.log('Current time:', now);
    console.log('Cutoff date:', cutoffDate);

    // Helper function to parse date/time
    function parseDateTime(dateTimeStr) {
        // Format: (06/14/25 07:00:00)
        const match = dateTimeStr.match(/\((\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\)/);
        if (!match) return null;
        
        const [_, month, day, year, hour, minute, second] = match;
        const fullYear = 2000 + parseInt(year);
        return new Date(fullYear, parseInt(month) - 1, parseInt(day), 
                       parseInt(hour), parseInt(minute), parseInt(second));
    }

    // Helper function to check if entry is within time window
    function isWithinTimeWindow(dateTime) {
        if (!dateTime) return false;
        return dateTime >= cutoffDate && dateTime <= now;
    }

    // Process intake entries
    if (intakeSection && !intakeSection.includes('No qualifying data available')) {
        const intakeLines = intakeSection.split('\n').filter(line => line.trim());
        
        intakeLines.forEach(line => {
            if (line.trim() === '') return;
            
            const dateTime = parseDateTime(line);
            if (!isWithinTimeWindow(dateTime)) return;
            
            const volumeMatch = line.match(/:\s*(\d+)\s*mL/);
            if (!volumeMatch) return;
            
            const volume = parseInt(volumeMatch[1]);
            const entry = {
                description: line.split(':')[0].trim(),
                volume: volume,
                dateTime: dateTime,
                dateTimeStr: line.match(/\(([^)]+)\)/)[1]
            };
            
       // Categorize intake
            if (line.toLowerCase().includes('enteral') || 
                line.toLowerCase().includes('tube feed') ||
                line.toLowerCase().includes('feeding tube') ||
                line.toLowerCase().includes('nasogastric') ||
                line.toLowerCase().includes('ng tube') ||
                line.toLowerCase().includes('peg') ||
                line.toLowerCase().includes('jejunostomy')) {
                ioData.intakes.enteral.push(entry);
            } else if (line.toLowerCase().includes('blood') || 
                       line.toLowerCase().includes('red blood cells') ||
                       line.toLowerCase().includes('packed cells') ||
                       line.toLowerCase().includes('plasma') || 
                       line.toLowerCase().includes('platelets') ||
                       line.toLowerCase().includes('fresh frozen') ||
                       line.toLowerCase().includes('cryoprecipitate') ||
                       line.toLowerCase().includes('albumin')) {
                ioData.intakes.bloodProducts.push(entry);
            } else {
                ioData.intakes.other.push(entry);
            }
			
        });
    }

    // Process output entries
    if (outputSection) {
        const outputLines = outputSection.split('\n').filter(l => l.trim());
        outputLines.forEach(rawLine => {
            let line = rawLine.trim();
            // strip any leading "#<n> "
            line = line.replace(/^#\d+\s*/, '');
            // skip bare headers
            if (/^output$/i.test(line) && !line.includes(':')) return;
            const dateTime = parseDateTime(line);
            if (!isWithinTimeWindow(dateTime)) return;
            const volumeMatch = line.match(/:\s*(\d+)\s*mL/i);
            if (!volumeMatch) return;
            const volume = +volumeMatch[1];
            const dateTimeStr = (line.match(/\(([^)]+)\)/) || [,''])[1];
            // Extract a clean description:
            let description = '';
            if (/Other:/i.test(line)) {
                // grab text after "Other:" up to the next " - " or ":" 
                const m = line.match(/Other:\s*([^:-]+?)(?:\s*-\s*|:)/i);
                description = m ? m[1].trim() : '';
            } else {
                description = line.split(':')[0].trim();
            }
            const entry = { description, volume, dateTime, dateTimeStr };
            // now categorize
            if (/urinary catheter/i.test(line) || /straight cath/i.test(line) ||
                /urine output/i.test(line) || /void/i.test(line)) {
                ioData.outputs.urine.push(entry);
                if (/catheter/i.test(line)) ioData.outputs.urinaryCatheter = true;
                if (!ioData.outputs.lastUrineTime || dateTime > ioData.outputs.lastUrineTime) {
                    ioData.outputs.lastUrineTime = dateTime;
                    ioData.outputs.lastUrineTimeStr = dateTimeStr;
                }
            } else if (/estimated blood loss/i.test(line)) {
                ioData.outputs.other['Estimated Blood Loss'] = 
                    ioData.outputs.other['Estimated Blood Loss'] || [];
                ioData.outputs.other['Estimated Blood Loss'].push(entry);
            } else if (/drain/i.test(description) || /jp/i.test(description)) {
                // surgical drains now grouped correctly by the cleaned description
                ioData.outputs.drains[description] = 
                    ioData.outputs.drains[description] || [];
                ioData.outputs.drains[description].push(entry);
            } else {
                // anything else
                const key = description || 'Other Output';
                ioData.outputs.other[key] = ioData.outputs.other[key] || [];
                ioData.outputs.other[key].push(entry);
            }
        });
    }



// Process count entries
const countData = {};
if (outputSection) {
    const countRegex = /(Stool Count|Urine Count|Vomit Count|.*?Count):\s*(\d+)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    let countMatch;
    while ((countMatch = countRegex.exec(outputSection)) !== null) {
        const countType = countMatch[1];
        const count = parseInt(countMatch[2]);
        const dateTime = parseDateTime(`(${countMatch[3]} ${countMatch[4]})`);
        
        if (isWithinTimeWindow(dateTime)) {
            if (!countData[countType]) {
                countData[countType] = [];
            }
            countData[countType].push({
                count: count,
                dateTime: dateTime,
                dateTimeStr: `${countMatch[3]} ${countMatch[4]}`
            });
        }
    }
}

ioData.counts = countData;

// Calculate elapsed time



    
    // Calculate elapsed time
    const elapsedMs = now - cutoffDate;
    const elapsedHours = elapsedMs / (1000 * 60 * 60);
    ioData.elapsedHours = elapsedHours;
    ioData.cutoffTime = cutoffDate;
    
    console.log('I/O data processed:', {
        enteralCount: ioData.intakes.enteral.length,
        bloodProductCount: ioData.intakes.bloodProducts.length,
        urineCount: ioData.outputs.urine.length,
        hasCatheter: ioData.outputs.urinaryCatheter,
        drainTypes: Object.keys(ioData.outputs.drains),
        elapsedHours: elapsedHours
    });

	

    return ioData;
}











































































function generateFishbone(data) {
    let fishbone = '';
    
    // Helper function to wrap abnormal values
    const markAbnormal = (value) => `*${value}*`;
    
    // ===== VITALS SECTION =====
    if (data.vitals.temp && data.vitals.temp.length > 0) {
        const tempMin = Math.min(...data.vitals.temp).toFixed(1);
        const tempMax = Math.max(...data.vitals.temp).toFixed(1);
        const tempAvg = (data.vitals.temp.reduce((a, b) => a + b, 0) / data.vitals.temp.length).toFixed(1);
        
        const hadFever = data.vitals.temp.some(t => t > 38);
        const hadHypothermia = data.vitals.temp.some(t => t < 35);
        
        if (hadFever || hadHypothermia) {
            fishbone += `T ${markAbnormal(`${tempMin}-${tempMax}`)} (${tempAvg}), `;
        } else {
            fishbone += `T ${tempMin}-${tempMax} (${tempAvg}), `;
        }
    } else {
        fishbone += 'no T, ';
    }
    
    if (data.vitals.hr && data.vitals.hr.length > 0) {
        const hrMin = Math.min(...data.vitals.hr);
        const hrMax = Math.max(...data.vitals.hr);
        const hrAvg = Math.round(data.vitals.hr.reduce((a, b) => a + b, 0) / data.vitals.hr.length);
        
        const hadTachycardia = data.vitals.hr.some(hr => hr > 100);
        const hadBradycardia = data.vitals.hr.some(hr => hr < 60);
        
        if (hadTachycardia || hadBradycardia) {
            fishbone += `HR ${markAbnormal(`${hrMin}-${hrMax}`)}(${hrAvg}), `;
        } else {
            fishbone += `HR ${hrMin}-${hrMax}(${hrAvg}), `;
        }
    } else {
        fishbone += 'no HR, ';
    }
    
   


// Handle SBP and DBP separately
if (data.vitals.sbp && data.vitals.sbp.length > 0) {
    const sbpMin = Math.min(...data.vitals.sbp);
    const sbpMax = Math.max(...data.vitals.sbp);
    const sbpAvg = Math.round(data.vitals.sbp.reduce((a, b) => a + b, 0) / data.vitals.sbp.length);
    
    const hadHypotension = data.vitals.sbp.some(sbp => sbp < 90);
    const hadHypertension = data.vitals.sbp.some(sbp => sbp > 180);
    
    if (hadHypotension || hadHypertension) {
        fishbone += `SBP ${markAbnormal(`${sbpMin}-${sbpMax}`)} (${sbpAvg}), `;
    } else {
        fishbone += `SBP ${sbpMin}-${sbpMax} (${sbpAvg}), `;
    }
} else {
    fishbone += 'no SBP, ';
}

if (data.vitals.dbp && data.vitals.dbp.length > 0) {
    const dbpMin = Math.min(...data.vitals.dbp);
    const dbpMax = Math.max(...data.vitals.dbp);
    const dbpAvg = Math.round(data.vitals.dbp.reduce((a, b) => a + b, 0) / data.vitals.dbp.length);
    
    const hadDiastolicHypertension = data.vitals.dbp.some(dbp => dbp > 120);
    const hadDiastolicHypotension = data.vitals.dbp.some(dbp => dbp < 60);
    
    if (hadDiastolicHypertension || hadDiastolicHypotension) {
        fishbone += `DBP ${markAbnormal(`${dbpMin}-${dbpMax}`)} (${dbpAvg}) `;
    } else {
        fishbone += `DBP ${dbpMin}-${dbpMax} (${dbpAvg}) `;
    }
} else {
    fishbone += 'no DBP ';
}







    // O2 saturation with therapy
    if (data.vitals.o2 && data.vitals.o2.length > 0) {
        const o2Min = Math.min(...data.vitals.o2);
        const o2Max = Math.max(...data.vitals.o2);
        
        const hadHypoxia = data.vitals.o2.some(o2 => o2 < 94);
        
        if (hadHypoxia) {
            fishbone += `O2 ${markAbnormal(`${o2Min}-${o2Max}`)}`;
        } else {
            fishbone += `O2 ${o2Min}-${o2Max}`;
        }
        
        if (data.o2therapyCode && data.o2therapyCode !== 'RA') {
            fishbone += `-${markAbnormal(data.o2therapyCode)}`;
            if (data.o2flowRaw && data.o2therapyCode !== 'Vent') {
                fishbone += `@${data.o2flowRaw}`;
            }
        }


} else if (data.o2therapyCode) {
    if (data.o2therapyCode === 'RA') {
        fishbone += `O2: ${data.o2therapyCode}`;
    } else {
        fishbone += `O2: ${markAbnormal(data.o2therapyCode)}`;
        if (data.o2flowRaw && data.o2therapyCode !== 'Vent') {
            fishbone += `@${data.o2flowRaw}`;
        }
    }
} else {
    fishbone += 'no O2';
}




    fishbone += '\n';

   // ===== OXYGEN THERAPY DETAILS ===== 
    // Only show detailed info for ventilators (complex settings worth showing separately)
    if (data.o2therapyCode === 'Vent') {
        const mode = data.ventModeRaw ? data.ventModeRaw.replace(/[\s\/\+]+/g,'') : '';
        const freq = data.ventFrequencyRaw || '';
        const tv = data.ventTidalRaw || '';
        const peep = data.ventPeepRaw || '';
        const fio2 = data.ventFiO2Raw || '';
        const settings = [freq, tv, peep, fio2 ? fio2 + '%' : ''].filter(x => x).join('/');
        fishbone += `${markAbnormal(`Ventilator: ${mode} ${settings}`)}\n`;
    }
	

    // ===== INTAKE/OUTPUT SECTION =====
    if (lastImportedData) {
        const ioData = extractIntakeOutputData(lastImportedData);
        const elapsedHours = ioData.elapsedHours || 24;
        const elapsedHoursDisplay = Math.round(elapsedHours);
        
// Get total intake from the summary section instead of calculating
let totalIntake = 0;
const intakeSummaryMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Intake\s+mL\s+([\d,]+(?:\.\d+)?)/i);
if (intakeSummaryMatch) {
    totalIntake = parseFloat(intakeSummaryMatch[1].replace(/,/g, ''));
} else {
    // Fallback to calculation if summary not found
    totalIntake += ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.other.reduce((sum, entry) => sum + entry.volume, 0);
}
		
        
    // Get total output from the summary section instead of calculating
let totalOutput = 0;
const outputSummaryMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Output\s+mL\s+([\d,]+(?:\.\d+)?)/i);
if (outputSummaryMatch) {
    totalOutput = parseFloat(outputSummaryMatch[1].replace(/,/g, ''));
} else {
    // Fallback to calculation if summary not found
    totalOutput += ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    Object.values(ioData.outputs.drains).forEach(entries => {
        totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
    Object.values(ioData.outputs.other).forEach(entries => {
        totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
}
		
        
        // INTAKES
        fishbone += `I: ${totalIntake}\n`;
        let hasIntakes = false;

		
        
        if (ioData.intakes.enteral.length > 0) {
            const totalEnteral = ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
            const hourlyEnteral = Math.round(totalEnteral / elapsedHours);
            const latestEnteral = ioData.intakes.enteral.sort((a, b) => b.dateTime - a.dateTime)[0];
            fishbone += `Enteral: ${totalEnteral}mL/${elapsedHoursDisplay}hr (${hourlyEnteral}mL/hr) - last: ${latestEnteral.dateTimeStr}\n`;
            hasIntakes = true;
        }
        
        if (ioData.intakes.bloodProducts.length > 0) {
            const totalBlood = ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
            const latestBlood = ioData.intakes.bloodProducts.sort((a, b) => b.dateTime - a.dateTime)[0];
            fishbone += `Blood products: ${totalBlood}mL/${elapsedHoursDisplay}hr - last: ${latestBlood.dateTimeStr}\n`;
            hasIntakes = true;
        }
        
        if (ioData.intakes.other.length > 0) {
            const groupedIntakes = {};
            ioData.intakes.other.forEach(entry => {
                const type = entry.description || 'Other intake';
                if (!groupedIntakes[type]) groupedIntakes[type] = [];
                groupedIntakes[type].push(entry);
            });
            
            Object.entries(groupedIntakes).forEach(([type, entries]) => {
                const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
                const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                fishbone += `${type}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}\n`;
                hasIntakes = true;
            });
        }
        
        if (!hasIntakes) {
            fishbone += ``;
        }
        
        // OUTPUTS  
        fishbone += `O: ${totalOutput}\n`;
        let hasOutputs = false;
        



		// Urine output
if (ioData.outputs.urine.length > 0) {
    const totalUrine = ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    const hourlyOutput = Math.round(totalUrine / elapsedHours);
    
    // Start with Foley if present
    let urineStr = '';
    if (ioData.outputs.urinaryCatheter) {
        urineStr = `${markAbnormal('Foley')} `;
    }
    
    urineStr += `UOP: ${totalUrine}mL/${elapsedHoursDisplay}hr`;
    if (data.weight) {
        const urinePerKgHr = (hourlyOutput / data.weight).toFixed(2);
        urineStr += ` (${urinePerKgHr}mL/kg/hr)`;
        if (urinePerKgHr < 0.5) {
            // Rebuild the string to mark the UOP part as abnormal while keeping Foley at front
            const foleyPrefix = ioData.outputs.urinaryCatheter ? `${markAbnormal('Foley')} ` : '';
            urineStr = `${foleyPrefix}UOP: ${markAbnormal(`${totalUrine}mL/${elapsedHoursDisplay}hr (${urinePerKgHr}mL/kg/hr)`)}`;
        }
    }
    urineStr += ` - last: ${ioData.outputs.lastUrineTimeStr}`;
    
    fishbone += urineStr + '\n';
    hasOutputs = true;
} else {
    fishbone += `${markAbnormal('No urine found')}\n`;
    hasOutputs = true;
}


		
        
     // Drains
Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
    if (entries.length > 0) {
        const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        let drainStr = `${markAbnormal(drainType)}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`;
        if (total > (30 * elapsedHours)) {
            drainStr = `${markAbnormal(drainType)}: ${markAbnormal(`${total}mL/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}`;
        }
        fishbone += drainStr + '\n';
        hasOutputs = true;
    }
});
        
        // Other outputs
        Object.entries(ioData.outputs.other).forEach(([outputType, entries]) => {
            if (entries.length > 0) {
                const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
                const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                if (outputType.includes('Blood Loss')) {
                    fishbone += `${outputType}: ${markAbnormal(`${total}mL/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}\n`;
                } else {
                    fishbone += `${outputType}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}\n`;
                }
                hasOutputs = true;
            }
        });
        
        // COUNTS
        if (Object.keys(ioData.counts || {}).length > 0) {
            fishbone += `COUNTS:\n`;
            Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
                if (entries.length > 0) {
                    const totalCount = entries.reduce((sum, entry) => sum + entry.count, 0);
                    const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                    let countStr = `${countType}: ${totalCount}/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`;
                    if ((countType.toLowerCase().includes('stool') && totalCount > 3) || 
                        (countType.toLowerCase().includes('vomit') && totalCount > 0)) {
                        countStr = `${countType}: ${markAbnormal(`${totalCount}/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}`;
                    }
                    fishbone += countStr + '\n';
                }
            });
        }
        
        // Fluid balance
        const intakeMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Intake\s+mL\s+([\d,]+(?:\.\d+)?)/i);
        const outputMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Output\s+mL\s+([\d,]+(?:\.\d+)?)/i);
        const balanceMatch = lastImportedData.match(/Fluid\s+Balance\s+([-+]?[\d,]+(?:\.\d+)?)/i);
        
        let fluidBalance = null;
        if (balanceMatch) {
            fluidBalance = parseFloat(balanceMatch[1].replace(/,/g, ''));
        } else if (intakeMatch && outputMatch) {
            const totalIntake = parseFloat(intakeMatch[1].replace(/,/g, ''));
            const totalOutput = parseFloat(outputMatch[1].replace(/,/g, ''));
            fluidBalance = totalIntake - totalOutput;
        }
        
 


if (fluidBalance !== null) {
    const sign = fluidBalance >= 0 ? '+' : '';
    const absBalance = Math.abs(fluidBalance);
    
    if (absBalance > 100) {
        fishbone += `Fluid Balance: ${markAbnormal(`${sign}${fluidBalance.toFixed(1)}mL`)}\n`;
    } else {
        fishbone += `Fluid Balance: ${sign}${fluidBalance.toFixed(1)}mL\n`;
    }
}



        
        fishbone += '\n';
    }

   

// ===== DATE CHECKING FUNCTION (MUST BE HERE) =====
const currentDate = new Date();
currentDate.setHours(0, 0, 0, 0);
const yesterday = new Date(currentDate);
yesterday.setDate(yesterday.getDate() - 1);

const isRecentDate = (dateStr) => {
    if (!dateStr) return false;
    const [month, day, year] = dateStr.split('/').map(n => parseInt(n));
    const labDate = new Date(2000 + year, month - 1, day);
    labDate.setHours(0, 0, 0, 0);
    return labDate >= yesterday && labDate <= currentDate;
};



	
	



// ===== CBC FISHBONE =====
// Layout: X1=WBC, X2=Hgb, X3=PLT
//         X4=blank, X5=Hct, X6=blank
// Visual:
// WBC  \ Hgb  / PLT
//      / Hct  \

const wbc = data.labs.wbc?.[0];
const hgb = data.labs.hgb?.[0];
const plt = data.labs.plt?.[0];
const hct = data.labs.hct?.[0];

const wbcPrev = data.labs.wbc?.[1];
const hgbPrev = data.labs.hgb?.[1];
const pltPrev = data.labs.plt?.[1];
const hctPrev = data.labs.hct?.[1];

// Format values with previous values for abnormals
let wbcStr = '--';
if (wbc !== undefined) {
    if (wbc < 4.5 || wbc > 11) {
        wbcStr = wbcPrev !== undefined ? `${markAbnormal(wbc)}(${wbcPrev})` : markAbnormal(wbc);
    } else {
        wbcStr = wbc.toString();
    }
}

let hgbStr = '--';
if (hgb !== undefined) {
    if (hgb <= 7 || (hgbPrev !== undefined && hgbPrev - hgb >= 1)) {
        hgbStr = hgbPrev !== undefined ? `${markAbnormal(hgb)}(${hgbPrev})` : markAbnormal(hgb);
    } else {
        hgbStr = hgb.toString();
    }
}

let pltStr = '--';
if (plt !== undefined) {
    if (plt < 150 || plt > 400) {
        pltStr = pltPrev !== undefined ? `${markAbnormal(plt)}(${pltPrev})` : markAbnormal(plt);
    } else {
        pltStr = plt.toString();
    }
}

let hctStr = '--';
if (hct !== undefined) {
    if (hct < 21) {
        hctStr = hctPrev !== undefined ? `${markAbnormal(hct)}(${hctPrev})` : markAbnormal(hct);
    } else {
        hctStr = hct.toString();
    }
}

// Pair matching for CBC:
// Pair 1: X1(WBC) top / X4(blank) bottom
const cbcPair1Top = wbcStr;
const cbcPair1Bottom = ''; // X4 is blank
const cbcPair1Width = Math.max(cbcPair1Top.length, cbcPair1Bottom.length);
const cbcPair1TopPadded = cbcPair1Top.padEnd(cbcPair1Width);
const cbcPair1BottomPadded = cbcPair1Bottom.padEnd(cbcPair1Width);

// Pair 2: X2(Hgb) top / X5(Hct) bottom
const cbcPair2Top = hgbStr;
const cbcPair2Bottom = hctStr;
const cbcPair2Width = Math.max(cbcPair2Top.length, cbcPair2Bottom.length);
const cbcPair2TopPadded = cbcPair2Top.padEnd(cbcPair2Width);
const cbcPair2BottomPadded = cbcPair2Bottom.padEnd(cbcPair2Width + 1);

// Pair 3: X3(PLT) top / X6(blank) bottom
const cbcPair3Top = pltStr;
const cbcPair3Bottom = ''; // X6 is blank
const cbcPair3Width = Math.max(cbcPair3Top.length, cbcPair3Bottom.length);
const cbcPair3TopPadded = cbcPair3Top.padEnd(cbcPair3Width);
const cbcPair3BottomPadded = cbcPair3Bottom.padEnd(cbcPair3Width);

// Build CBC lines
const cbcTopLine = `${cbcPair1TopPadded}\\${cbcPair2TopPadded} /${cbcPair3TopPadded}`;
fishbone += cbcTopLine + '\n';

const cbcBottomLine = `${cbcPair1BottomPadded}/${cbcPair2BottomPadded}\\${cbcPair3BottomPadded}`;
fishbone += cbcBottomLine + '\n';

// ===== BMP FISHBONE =====
// Layout: X1=Na,  X2=Cl,  X3=BUN, X4=Glu
//         X5=K,   X6=CO2, X7=Cr
// Visual:
// Na  | Cl  | BUN / Glu
// K   | CO2 | Cr  \

const na  = data.labs.na?.[0];
const k   = data.labs.k?.[0];
const cl  = data.labs.cl?.[0];
const co2 = data.labs.co2?.[0];
const bun = data.labs.bun?.[0];
const cr  = data.labs.cr?.[0];
const glu = data.labs.glu?.[0];

const naPrev = data.labs.na?.[1];
const kPrev = data.labs.k?.[1];
const clPrev = data.labs.cl?.[1];
const co2Prev = data.labs.co2?.[1];
const bunPrev = data.labs.bun?.[1];
const crPrev = data.labs.cr?.[1];
const gluPrev = data.labs.glu?.[1];

// Format BMP values with previous values for abnormals
let naStr = '--';
if (na !== undefined) {
    if (na < 135 || na > 145) {
        naStr = naPrev !== undefined ? `${markAbnormal(na)}(${naPrev})` : markAbnormal(na);
    } else {
        naStr = na.toString();
    }
}

let kStr = '--';
if (k !== undefined) {
    if (k < 4.0 || k > 5.0) {
        kStr = kPrev !== undefined ? `${markAbnormal(k)}(${kPrev})` : markAbnormal(k);
    } else {
        kStr = k.toString();
    }
}

let clStr = '--';
if (cl !== undefined) {
    if (cl < 96 || cl > 106) {
        clStr = clPrev !== undefined ? `${markAbnormal(cl)}(${clPrev})` : markAbnormal(cl);
    } else {
        clStr = cl.toString();
    }
}

let co2Str = '--';
if (co2 !== undefined) {
    co2Str = co2.toString();
}

let bunStr = '--';
if (bun !== undefined) {
    if (bun > 24) {
        bunStr = bunPrev !== undefined ? `${markAbnormal(bun)}(${bunPrev})` : markAbnormal(bun);
    } else {
        bunStr = bun.toString();
    }
}

let crStr = '--';
if (cr !== undefined) {
    if (cr > 1.2 || (crPrev !== undefined && cr - crPrev > 0.3)) {
        crStr = crPrev !== undefined ? `${markAbnormal(cr)}(${crPrev})` : markAbnormal(cr);
    } else {
        crStr = cr.toString();
    }
}

let gluStr = '--';
if (glu !== undefined) {
    if (glu > 200 || glu < 70) {
        gluStr = gluPrev !== undefined ? `${markAbnormal(glu)}(${gluPrev})` : markAbnormal(glu);
    } else {
        gluStr = glu.toString();
    }
}

// Pair matching for BMP:
// Pair 1: X1(Na) top / X5(K) bottom
const bmpPair1Top = naStr;
const bmpPair1Bottom = kStr;
const bmpPair1Width = Math.max(bmpPair1Top.length, bmpPair1Bottom.length);
const bmpPair1TopPadded = bmpPair1Top.padEnd(bmpPair1Width);
const bmpPair1BottomPadded = bmpPair1Bottom.padEnd(bmpPair1Width);

// Pair 2: X2(Cl) top / X6(CO2) bottom
const bmpPair2Top = clStr;
const bmpPair2Bottom = co2Str;
const bmpPair2Width = Math.max(bmpPair2Top.length, bmpPair2Bottom.length);
const bmpPair2TopPadded = bmpPair2Top.padEnd(bmpPair2Width);
const bmpPair2BottomPadded = bmpPair2Bottom.padEnd(bmpPair2Width);

// Pair 3: X3(BUN) top / X7(Cr) bottom
const bmpPair3Top = bunStr;
const bmpPair3Bottom = crStr;
const bmpPair3Width = Math.max(bmpPair3Top.length, bmpPair3Bottom.length);
const bmpPair3TopPadded = bmpPair3Top.padEnd(bmpPair3Width);
const bmpPair3BottomPadded = bmpPair3Bottom.padEnd(bmpPair3Width);

// Build BMP lines
const bmpTopLine = `${bmpPair1TopPadded}|${bmpPair2TopPadded}|${bmpPair3TopPadded}/${gluStr}`;
fishbone += bmpTopLine + '\n';

const bmpBottomLine = `${bmpPair1BottomPadded}|${bmpPair2BottomPadded}|${bmpPair3BottomPadded}\\`;
fishbone += bmpBottomLine + '\n';





// ===== ELECTROLYTES (Ca/Mg/Phos) SECTION =====
const ca = data.labs.ca?.[0];
const caPrev = data.labs.ca?.[1];
const mg = data.labs.mg?.[0];
const mgPrev = data.labs.mg?.[1];
const phos = data.labs.phos?.[0];
const phosPrev = data.labs.phos?.[1];

let caStr = '--';
if (ca !== undefined) {
    if (ca < 8.5 || ca > 10.2) {
        caStr = caPrev !== undefined ? `${markAbnormal(ca)}(${caPrev})` : markAbnormal(ca);
    } else {
        caStr = ca.toString();
    }
}

let mgStr = '--';
if (mg !== undefined) {
    if (mg < 1.7 || mg > 2.2) {
        mgStr = mgPrev !== undefined ? `${markAbnormal(mg)}(${mgPrev})` : markAbnormal(mg);
    } else {
        mgStr = mg.toString();
    }
}

let phosStr = '--';
if (phos !== undefined) {
    if (phos < 2.5 || phos > 4.5) {
        phosStr = phosPrev !== undefined ? `${markAbnormal(phos)}(${phosPrev})` : markAbnormal(phos);
    } else {
        phosStr = phos.toString();
    }
}

fishbone += `Ca:${caStr}, Mg:${mgStr}, P:${phosStr}\n`;




	

    // ===== LFTs SECTION =====
    if ((data.labs.ast || data.labs.alt || data.labs.tbil || data.labs.alk) && 
        (isRecentDate(data.dates.ast) || isRecentDate(data.dates.alt))) {
        const ast = data.labs.ast?.[0];
        const alt = data.labs.alt?.[0];
        const astPrev = data.labs.ast?.[1];
        const altPrev = data.labs.alt?.[1];
        
        let astAltStr = '';
        if (ast && alt && (ast > 40 || alt > 40)) {
            astAltStr = `AST/ALT:${markAbnormal(`${ast}/${alt}`)}(${astPrev || '--'}/${altPrev || '--'})`;
        } else if (ast && alt) {
            astAltStr = `AST/ALT:${ast}/${alt}`;
        }
        
        const tbil = data.labs.tbil?.[0];
        const tbilPrev = data.labs.tbil?.[1];
        let tbilStr = '';
        if (tbil !== undefined) {
            if (tbil > 1.2) {
                tbilStr = `TB:${markAbnormal(tbil)}${tbilPrev !== undefined ? `(${tbilPrev})` : ''}`;
            } else {
                tbilStr = `TB:${tbil}`;
            }
        } else {
            tbilStr = 'TB:--';
        }
        
        const dbil = data.labs.dbil?.[0];
        const dbilPrev = data.labs.dbil?.[1];
        let dbilStr = '';
        if (dbil !== undefined) {
            if (dbil > 0.3) {
                dbilStr = `DB:${markAbnormal(dbil)}${dbilPrev !== undefined ? `(${dbilPrev})` : ''}`;
            } else {
                dbilStr = `DB:${dbil}`;
            }
        } else {
            dbilStr = 'DB:--';
        }
        
        const alk = data.labs.alk?.[0];
        const alkPrev = data.labs.alk?.[1];
        let alkStr = '';
        if (alk !== undefined) {
            if (alk > 150 || alk < 40) {
                alkStr = `ALK:${markAbnormal(alk)}${alkPrev !== undefined ? `(${alkPrev})` : ''}`;
            } else {
                alkStr = `ALK:${alk}`;
            }
        } else {
            alkStr = 'ALK:--';
        }
        
        fishbone += `LFTs: ${astAltStr}, ${tbilStr}, ${dbilStr}, ${alkStr}`;
        
        const lfDate = data.dates.ast || data.dates.alt || data.dates.tbil;
        const lfTime = data.times.ast || data.times.alt || data.times.tbil || '';
        if (lfDate) {
            fishbone += ` (${lfDate}${lfTime ? ' ' + lfTime : ''})`;
        }
        fishbone += '\n';
    }

    // ===== COAGULATION SECTION =====
    if ((data.labs.pt || data.labs.ptt || data.labs.inr || data.labs.fib) &&
        (isRecentDate(data.dates.pt) || isRecentDate(data.dates.ptt) || 
         isRecentDate(data.dates.inr) || isRecentDate(data.dates.fib))) {
        
        const pt = data.labs.pt?.[0];
        const ptt = data.labs.ptt?.[0];
        const inr = data.labs.inr?.[0];
        const fib = data.labs.fib?.[0];
        
        const ptPrev = data.labs.pt?.[1];
        const pttPrev = data.labs.ptt?.[1];
        const inrPrev = data.labs.inr?.[1];
        const fibPrev = data.labs.fib?.[1];
        
        let ptStr = '--';
        if (pt !== undefined) {
            if (pt > 13.5 && ptPrev !== undefined) {
                ptStr = `${markAbnormal(pt)}(${ptPrev})`;
            } else if (pt > 13.5) {
                ptStr = markAbnormal(pt);
            } else {
                ptStr = pt.toString();
            }
        }
        
        let pttStr = '--';
        if (ptt !== undefined) {
            if (ptt > 35 && pttPrev !== undefined) {
                pttStr = `${markAbnormal(ptt)}(${pttPrev})`;
            } else if (ptt > 35) {
                pttStr = markAbnormal(ptt);
            } else {
                pttStr = ptt.toString();
            }
        }
        
        let inrStr = '--';
        if (inr !== undefined) {
            if (inr > 1.1 && inrPrev !== undefined) {
                inrStr = `${markAbnormal(inr)}(${inrPrev})`;
            } else if (inr > 1.1) {
                inrStr = markAbnormal(inr);
            } else {
                inrStr = inr.toString();
            }
        }
        
        let fibStr = '--';
        if (fib !== undefined) {
            if ((fib < 200 || fib > 400) && fibPrev !== undefined) {
                fibStr = `${markAbnormal(fib)}(${fibPrev})`;
            } else if (fib < 200 || fib > 400) {
                fibStr = markAbnormal(fib);
            } else {
                fibStr = fib.toString();
            }
        }
        
        fishbone += `Coags: PT/PTT: ${ptStr}/${pttStr}, INR: ${inrStr}, Fib: ${fibStr}`;
        
        const coagDate = data.dates.pt || data.dates.ptt || data.dates.inr || data.dates.fib;
        const coagTime = data.times.pt || data.times.ptt || data.times.inr || data.times.fib || '';
        if (coagDate) {
            fishbone += ` (${coagDate}${coagTime ? ' ' + coagTime : ''})`;
        }
        fishbone += '\n';
    }
    
    // ===== ABG SECTION =====
    if ((data.labs.ph || data.labs.po2 || data.labs.pco2) && 
        (isRecentDate(data.dates.ph) || isRecentDate(data.dates.po2))) {
        const ph = data.labs.ph?.[0];
        const po2 = data.labs.po2?.[0];
        const pco2 = data.labs.pco2?.[0];
        const bicarb = data.labs.bicarb?.[0];
        
        let phStr = ph !== undefined ? (ph < 7.35 || ph > 7.45 ? markAbnormal(ph) : ph.toString()) : '--';
        let po2Str = po2 !== undefined ? (po2 < 80 ? markAbnormal(po2) : po2.toString()) : '--';
        let pco2Str = pco2 !== undefined ? (pco2 < 35 || pco2 > 45 ? markAbnormal(pco2) : pco2.toString()) : '--';
        let bicarbStr = bicarb !== undefined ? (bicarb < 22 || bicarb > 28 ? markAbnormal(bicarb) : bicarb.toString()) : '--';
        
        fishbone += `ABG: ${phStr}/${pco2Str}/${po2Str}/${bicarbStr}`;
        
        const abgDate = data.dates.ph || data.dates.po2 || data.dates.pco2;
        const abgTime = data.times.ph || data.times.po2 || data.times.pco2 || '';
        if (abgDate) {
            fishbone += ` (${abgDate}${abgTime ? ' ' + abgTime : ''})`;
        }
        fishbone += '\n';
    }
    
    // ===== MISC LABS SECTION =====
    const miscLabs = [];
    
    const lactate = data.labs.lactate?.[0];
    if (lactate !== undefined) {
        let lactateStr = `Lactate:${lactate > 2 ? markAbnormal(lactate) : lactate}`;
        miscLabs.push(lactateStr);
    }
    
    const trop = data.labs.trop?.[0];
    if (trop !== undefined && isRecentDate(data.dates.trop)) {
        let tropStr = `Trop:${trop > 0.04 ? markAbnormal(trop) : trop}`;
        miscLabs.push(tropStr);
    }
    
    const amylase = data.labs.amylase?.[0];
    if (amylase !== undefined && isRecentDate(data.dates.amylase)) {
        let amylaseStr = `Amylase:${amylase > 110 ? markAbnormal(amylase) : amylase}`;
        miscLabs.push(amylaseStr);
    }
    
    const lipase = data.labs.lipase?.[0];
    if (lipase !== undefined && isRecentDate(data.dates.lipase)) {
        let lipaseStr = `Lipase:${lipase > 140 ? markAbnormal(lipase) : lipase}`;
        miscLabs.push(lipaseStr);
    }
    
    if (miscLabs.length > 0) {
        fishbone += `Misc: ${miscLabs.join(', ')}\n`;
    }
    
    return fishbone;
}

































  











































































































function extractOrders(text) {
    // Extract medications section
    const medsMatch = text.match(/Medications.*?\(\d+\)\s*Active([\s\S]*?)(?=(?:\n\n)?(?:DIET ORDER:|CONSULTATION:|PROCEDURE:|IMAGING:|LABS:|$))/i);
    if (!medsMatch) return '';
    
    const medsText = medsMatch[1];
    
    // Get existing LTD and dispo
    const currentOrders = document.getElementById('field_ORDERS')?.value || '';
    let existingLTD = '';
    let existingDispo = '';
    
    if (currentOrders) {
        const ltdMatch = currentOrders.match(/^LTD:[ \t]*([^\r\n]*)/m);
        const dispoMatch = currentOrders.match(/dispo:\s*([^\n]+)/);
        if (ltdMatch) existingLTD = ltdMatch[1].trim();
        if (dispoMatch) existingDispo = dispoMatch[1].trim();
    }
    
    fullOrdersText = medsText;
    
    // Extract diet order
    const dietMatch = text.match(/DIET ORDER:\s*([^\n]+)/i);
    
    // Initialize order categories
    const orders = {
        'N/F': [],
        'Pain': [],
        'Abx': [],
        'AC': []
    };

    // COMPREHENSIVE MEDICATION ABBREVIATION TABLE
    const drugAbbreviations = {
        // Pain medications
        'acetaminophen': { abbr: 'T', category: 'Pain' },
        'tylenol': { abbr: 'T', category: 'Pain' },
        'morphine': { abbr: 'm', category: 'Pain' },
        'oxycodone': { abbr: 'o', category: 'Pain' },
        'oxyCODONE': { abbr: 'o', category: 'Pain' },
        'percocet': { abbr: 'perc', category: 'Pain' },
        'hydromorphone': { abbr: 'D', category: 'Pain' },
        'dilaudid': { abbr: 'D', category: 'Pain' },
        'fentanyl': { abbr: 'fent', category: 'Pain' },
        'tramadol': { abbr: 'tram', category: 'Pain' },
        'ketorolac': { abbr: 'k', category: 'Pain' },
        'toradol': { abbr: 'k', category: 'Pain' },
        'gabapentin': { abbr: 'g', category: 'Pain' },
        'neurontin': { abbr: 'g', category: 'Pain' },
        'pregabalin': { abbr: 'lyrica', category: 'Pain' },
        'lidocaine': { abbr: 'lido', category: 'Pain' },
        'methocarbamol': { abbr: 'r', category: 'Pain' },
        'robaxin': { abbr: 'r', category: 'Pain' },
        'cyclobenzaprine': { abbr: 'flexeril', category: 'Pain' },
        'baclofen': { abbr: 'bac', category: 'Pain' },
        'ibuprofen': { abbr: 'ibu', category: 'Pain' },
        'naproxen': { abbr: 'nap', category: 'Pain' },
        'celecoxib': { abbr: 'celebrex', category: 'Pain' },
        'dexmedetomidine': { abbr: 'precedex', category: 'Pain' },
        
        // Antibiotics
        'vancomycin': { abbr: 'vanco', category: 'Abx' },
        'piperacillin': { abbr: 'zosyn', category: 'Abx' },
        'tazobactam': { abbr: 'zosyn', category: 'Abx' },
        'ceftriaxone': { abbr: 'ctx', category: 'Abx' },
        'cefepime': { abbr: 'cef', category: 'Abx' },
        'cefazolin': { abbr: 'ancef', category: 'Abx' },
        'meropenem': { abbr: 'mero', category: 'Abx' },
        'azithromycin': { abbr: 'azithro', category: 'Abx' },
        'levofloxacin': { abbr: 'levo', category: 'Abx' },
        'ciprofloxacin': { abbr: 'cipro', category: 'Abx' },
        'metronidazole': { abbr: 'flagyl', category: 'Abx' },
        'clindamycin': { abbr: 'clinda', category: 'Abx' },
        'doxycycline': { abbr: 'doxy', category: 'Abx' },
        'fluconazole': { abbr: 'fluc', category: 'Abx' },
        'micafungin': { abbr: 'mica', category: 'Abx' },
        'ampicillin': { abbr: 'amp', category: 'Abx' },
        'amoxicillin': { abbr: 'amox', category: 'Abx' },
        'trimethoprim': { abbr: 'bactrim', category: 'Abx' },
        'sulfamethoxazole': { abbr: 'bactrim', category: 'Abx' },
        'linezolid': { abbr: 'linezolid', category: 'Abx' },
	'ertapenem': { abbr: 'ertapenem', category: 'Abx' },
	'ceftriaxone': { abbr: 'ceftriaxone', category: 'Abx' },
        
        // Pressors
        'norepinephrine': { abbr: 'levo', category: 'Abx' },
        'epinephrine': { abbr: 'epi', category: 'Abx' },
        'vasopressin': { abbr: 'vaso', category: 'Abx' },
        'phenylephrine': { abbr: 'neo', category: 'Abx' },
        'dopamine': { abbr: 'dopa', category: 'Abx' },
        
        // Anticoagulation
        'heparin': { abbr: 'hep', category: 'AC' },
        'enoxaparin': { abbr: 'L', category: 'AC' },
        'lovenox': { abbr: 'L', category: 'AC' },
        'aspirin': { abbr: 'ASA', category: 'AC' },
        'clopidogrel': { abbr: 'plavix', category: 'AC' },
        'warfarin': { abbr: 'coumadin', category: 'AC' },
        'apixaban': { abbr: 'eliquis', category: 'AC' },
        'rivaroxaban': { abbr: 'xarelto', category: 'AC' },
        'fondaparinux': { abbr: 'arixtra', category: 'AC' },
        
        // Fluids
        'lactated ringers': { abbr: 'LR', category: 'N/F' },
        'normal saline': { abbr: 'NS', category: 'N/F' },
        'dextrose': { abbr: 'D', category: 'N/F' },
        'd5w': { abbr: 'D5W', category: 'N/F' },
        'd5ns': { abbr: 'D5NS', category: 'N/F' },
        'albumin': { abbr: 'alb', category: 'N/F' },
	'parenteral nutrition': { abbr: 'TPN', category: 'N/F' },
	'total parenteral nutrition': { abbr: 'TPN', category: 'N/F' },
	'tpn': { abbr: 'TPN', category: 'N/F' },
	'peripheral parenteral nutrition': { abbr: 'PPN', category: 'N/F' },
	'ppn': { abbr: 'PPN', category: 'N/F' },
    };








function extractDoseInfo(line) {
    let dose = '';
    let freq = '';
    
    // Extract all dose matches - now handles commas in numbers (e.g., "1,000 mg")
    const doseMatches = [...line.matchAll(/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*(mg|g|mcg|unit|units|mL|L)/gi)];
    
    if (doseMatches.length > 0) {
        // For medications with multiple doses (like "500 mg 1 tab 1,000 mg 2 tab"),
        // take the highest dose which is usually the total therapeutic dose
        let bestDose = doseMatches[0];
        
        for (let match of doseMatches) {
            // Remove commas for numeric comparison
            const currentValue = parseFloat(match[1].replace(/,/g, ''));
            const bestValue = parseFloat(bestDose[1].replace(/,/g, ''));
            
            // Take the higher dose value, or if same unit type, the larger number
            if (match[2].toLowerCase() === bestDose[2].toLowerCase() && currentValue > bestValue) {
                bestDose = match;
            }
        }
        
        // Clean the dose value (remove commas for final output)
        const cleanDose = parseFloat(bestDose[1].replace(/,/g, ''));
        const unit = bestDose[2].toLowerCase();
        
        // Convert units when appropriate
        let finalDose = cleanDose;
        let finalUnit = unit;
        
        // Unit conversion logic
        if (unit === 'mg' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'g';
        } else if (unit === 'ml' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'L';
        } else if (unit === 'mcg' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'mg';
        }
        
        // Format the final dose
        if (finalUnit === 'mg') {
            // For mg, only include the number (legacy behavior)
            dose = finalDose.toString();
        } else {
            // For other units, include the unit
            dose = finalDose + finalUnit;
        }
    }
    
    // Enhanced frequency patterns - handles extra words like "scheduled", "as ordered", etc.
    const freqPatterns = [
        // Every X hours patterns
        { pattern: /every\s+(\d+)\s+hours?(?:\s+(?:scheduled|as\s+ordered|prn|as\s+needed))?/i, 
          convert: (match) => `q${match[1]}` },
        { pattern: /q\s*(\d+)\s*h(?:rs?)?(?:\s+(?:scheduled|as\s+ordered|prn|as\s+needed))?/i, 
          convert: (match) => `q${match[1]}` },
        
        // Daily patterns
        { pattern: /(?:once\s+)?daily(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        { pattern: /once\s+(?:a\s+)?day(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        { pattern: /qd(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        
        // BID patterns
        { pattern: /(?:twice\s+(?:a\s+)?day|2\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'bid' },
        { pattern: /bid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'bid' },
        
        // TID patterns
        { pattern: /(?:three\s+times?\s+(?:a\s+)?day|3\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'tid' },
        { pattern: /tid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'tid' },
        
        // QID patterns
        { pattern: /(?:four\s+times?\s+(?:a\s+)?day|4\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qid' },
        { pattern: /qid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qid' },
        
        // PRN patterns
        { pattern: /as\s+needed(?:\s+for.*?)?/i, 
          convert: () => 'prn' },
        { pattern: /prn(?:\s+for.*?)?/i, 
          convert: () => 'prn' },
        
        // Bedtime patterns
        { pattern: /(?:at\s+)?bedtime(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qhs' },
        { pattern: /qhs(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qhs' },
        
        // Single dose patterns
        { pattern: /once(?:\s+only)?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'x1' },
        { pattern: /single\s+dose(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'x1' },
        
        // Weekly patterns
        { pattern: /weekly(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'weekly' },
        { pattern: /once\s+(?:a\s+)?week(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'weekly' },
        
        // Before meals patterns
        { pattern: /before\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'ac' },
        { pattern: /ac(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'ac' },
        
        // After meals patterns
        { pattern: /after\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'pc' },
        { pattern: /pc(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'pc' },
        
        // With meals patterns
        { pattern: /with\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'w/meals' }
    ];
    
    // Try to match frequency patterns
    for (const freqPattern of freqPatterns) {
        const match = line.match(freqPattern.pattern);
        if (match) {
            freq = freqPattern.convert(match);
            break;
        }
    }
    
    // Extract rate for continuous infusions (handles commas in rates too)
    const rateMatch = line.match(/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*mL\/hr/i);
    if (rateMatch) {
        const cleanRate = parseFloat(rateMatch[1].replace(/,/g, ''));
        
        // Convert mL/hr to L/hr when appropriate
        if (cleanRate >= 1000 && cleanRate % 1000 === 0) {
            const convertedRate = cleanRate / 1000;
            freq = '@' + convertedRate + 'L/hr';
        } else {
            freq = '@' + cleanRate;
        }
    }
    
    return { dose, freq };
}





	

    // Process diet order
    if (dietMatch) {
        const diet = dietMatch[1].trim().toLowerCase();
        const dietMap = {
            'npo': 'NPO',
            'nothing by mouth': 'NPO',
            'regular': 'RD',
            'general': 'RD',
            'clear liquid': 'CLD',
            'full liquid': 'FLD',
            'renal': 'renal',
            'cardiac': 'cardiac',
            'diabetic': 'DM diet',
            'diabetes': 'DM diet',
            'soft': 'soft',
            'mechanical soft': 'mech soft',
            'pureed': 'puree',
            'dysphagia': 'dysphagia',
			'IDDSI': 'IDDSI',
			'Pediatric': 'pediatric', 
        };
        
        for (const [key, value] of Object.entries(dietMap)) {
            if (diet.includes(key)) {
                orders['N/F'].push(value);
                break;
            }
        }
    }
    
    // Process medications
    const medLines = medsText.split('\n').filter(line => line.trim());
    const processedMeds = new Set();
    
    medLines.forEach(line => {
        const lineLower = line.toLowerCase();
        
        // Skip non-medication lines
        if (lineLower.includes('scheduled:') || 
            lineLower.includes('prn:') || 
            lineLower.includes('continuous:') ||
            line.trim().length < 3) {
            return;
        }
        
        // Find matching drug
        let matched = false;
        for (const [drug, info] of Object.entries(drugAbbreviations)) {
            if (lineLower.includes(drug)) {
                const { dose, freq } = extractDoseInfo(line);
                
                // Build abbreviation
                let abbr = info.abbr;
                if (dose) {
                    // Special formatting for common doses
                    if (drug === 'acetaminophen' && dose === '975') abbr = 't975';
                    else if (drug === 'acetaminophen' && dose === '1000') abbr = 'T1g';
                    else if (dose && freq) abbr = `${info.abbr}${dose}${freq}`;
                    else if (dose) abbr = `${info.abbr}${dose}`;
                }
                if (freq && !dose) abbr = `${info.abbr}${freq}`;
                
              // Special cases for IV medications
		if (lineLower.includes('iv ') || lineLower.includes('intravenous')) {
		    abbr += 'IV';
		}
		
		// Add asterisks around IV pain medications
		if (info.category === 'Pain' && abbr.includes('IV')) {
		    abbr = `*${abbr}*`;
		}
		
		if (!processedMeds.has(abbr)) {
		    orders[info.category].push(abbr);
		    processedMeds.add(abbr);
		}





		    
                matched = true;
                break;
            }
        }
        
        // Special handling for fluids with rates
        if (!matched && (lineLower.includes('ml/hr') || lineLower.includes('ml per hour'))) {
            const rateMatch = line.match(/(\d+)\s*mL\/hr/i);
            if (rateMatch) {
                const rate = rateMatch[1];
                if (lineLower.includes('lactated ringer')) {
                    orders['N/F'].push(`LR@${rate}`);
                } else if (lineLower.includes('normal saline') || lineLower.includes('0.9%')) {
                    orders['N/F'].push(`NS@${rate}`);
                } else if (lineLower.includes('d5w')) {
                    orders['N/F'].push(`D5W@${rate}`);
                }
            }
        }
    });
    
    // Format final orders
    const formattedOrders = [];
    formattedOrders.push(`N/F: ${orders['N/F'].length > 0 ? orders['N/F'].join(', ') : ''}`);
    formattedOrders.push(`Pain: ${orders['Pain'].length > 0 ? orders['Pain'].join(', ') : ''}`);
    formattedOrders.push(existingLTD ? `LTD: ${existingLTD}` : `LTD:`);
    formattedOrders.push(`Abx: ${orders['Abx'].length > 0 ? orders['Abx'].join(', ') : ''}`);
    formattedOrders.push(`AC: ${orders['AC'].length > 0 ? orders['AC'].join(', ') : '*NO DVT PPX*'}`);
    formattedOrders.push(`dispo: ${existingDispo}`);
    
    return formattedOrders.join('\n');
}




        function extractFullMeds(text) {
            const medsMatch = text.match(/Medications.*?\(\d+\)\s*Active([\s\S]*?)(?=(?:\n\n)?(?:DIET ORDER:|CONSULTATION:|PROCEDURE:|IMAGING:|LABS:|$))/i);
            return medsMatch ? medsMatch[1] : '';
        }


















function showStaffPresentation() {
    if (currentPatientIndex === -1) return;

    const patient = patientData[currentPatientIndex];

    // Check if it's a consult
    if (patient.Type !== 'Consult') {
        alert("This is a regular patient entry. Convert to consult first to generate staff presentation.");
        return;
    }

    // Small helper
    const isBlank = v => v == null || String(v).trim() === '';

    // Extract common data
    const cc     = isBlank(patient.CC) ? '' : patient.CC.trim();
    const violin = isBlank(patient.VIOLIN) ? '' : patient.VIOLIN.trim();
    const pe     = isBlank(patient.PE) ? '' : patient.PE.trim();
    const todo   = isBlank(patient['To do']) ? '' : String(patient['To do']).trim();

    // Identifiers
    const name = isBlank(patient.Name) ? 'Unknown' : patient.Name.trim();
    const rm   = isBlank(patient.RM) ? 'Unknown' : String(patient.RM).trim();
    const mrn  = isBlank(patient.MRN) ? 'Unknown' : String(patient.MRN).trim();

    // Decide which mode to use
    const ageGender = isBlank(patient['A/G']) ? '' : String(patient['A/G']).trim();
    const useProblemsMode = isBlank(ageGender);

    // Build content for each mode
    let middleBlock = '';
    if (useProblemsMode) {
        // Prefer 'Problems', but fall back to a few common variants just in case
        const problems =
            !isBlank(patient.Problems) ? String(patient.Problems).trim() :
            !isBlank(patient.PROBLEMS) ? String(patient.PROBLEMS).trim() :
            !isBlank(patient['Problem List']) ? String(patient['Problem List']).trim() :
            'No problems listed';

        middleBlock = `${problems}\n\n`;
    } else {
        const pmh = isBlank(patient.PMH) ? '' : String(patient.PMH).trim();
        const hpi = isBlank(patient.HPI) ? '' : String(patient.HPI).trim();
        const ros = isBlank(patient.ROS) ? '' : String(patient.ROS).trim();

        // PMH phrase
        const pmhPhrase = pmh ? `with PMH ${pmh}` : 'with no PMH';

        // Assemble the narrative; trim empty parts gracefully
        const parts = [
            `${ageGender} ${pmhPhrase}`,
            hpi,
            ros
        ].filter(s => !isBlank(s));

        middleBlock = parts.join(', ').replace(/\s+,/g, ',') + '\n\n';
    }

    // Build final presentation
    let presentation = `${name}\n${rm}\nMRN: ${mrn}\n\n`;
    presentation += `Consult for ${cc}\n\n`;
    presentation += middleBlock;
    presentation += `${violin}\n\n${pe}\n\n`;
    presentation += `Plan: ${todo}`;

    // Modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Staff</h2>
            <pre style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; white-space: pre-wrap; font-family: monospace; font-size: 0.9rem; line-height: 1.6; color: var(--text-primary);">${presentation}</pre>
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                <button onclick="copyStaffPresentation()">üìã Copy to Clipboard</button>
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);

    // Store presentation for copy function
    window.currentStaffPresentation = presentation;
}



		















		

function copyStaffPresentation() {
    if (window.currentStaffPresentation) {
        navigator.clipboard.writeText(window.currentStaffPresentation).then(() => {
            alert('Presentation copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy:', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = window.currentStaffPresentation;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Presentation copied to clipboard!');
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textArea);
        });
    }
}




	    function showUpdatePatientsSection() {
    document.getElementById('entryTypeSelection').style.display = 'none';
    document.getElementById('updatePatientsSection').style.display = 'block';
    document.getElementById('updateListDataModal').focus();
}



	    function processUpdateListFromModal() {
    const text = document.getElementById('updateListDataModal').value.trim();
    if (!text) {
        alert('Please paste the patient list');
        return;
    }

    const minimal = parseCernerData(text);
    if (minimal.length === 0) {
        alert('No valid patient entries found. Please check the format.');
        return;
    }

    // build lookup maps for your existing patients
    const byMRN  = new Map();
    const byName = new Map();
    patientData.forEach(p => {
        if (p.MRN)           byMRN.set(p.MRN, p);
        if (p.Name?.trim())  byName.set(p.Name.trim().toUpperCase(), p);
    });

    // now create a brand-new array in EXACTLY the pasted order
    const updated = minimal.map(mini => {
        // try MRN match, then Name match
        const key = mini.Name.trim().toUpperCase();
        const existing = byMRN.get(mini.MRN) || byName.get(key);

        if (existing) {
            // keep all existing fields, but update RM/MRN/Att (and A/G if you like)
            existing.RM   = mini.RM;
            existing.MRN  = mini.MRN;
            existing.Att  = mini.Att;
            if (mini['A/G']) existing['A/G'] = mini['A/G'];
            return existing;
        } else {
            // brand new patient: has RM, MRN, Att, Type, plus A/G
            return mini;
        }
    });

    // replace your master list
    patientData = updated;

    saveToLocalStorage();
    displayRows();
    closeAddEntryModal(); // Close the modal after updating

    alert(
        `List updated!\n\n` +
        `Total now: ${patientData.length}\n` +
        `Matched existing: ${minimal.filter(m => byMRN.has(m.MRN) || byName.has(m.Name.toUpperCase())).length}\n` +
        `New patients: ${minimal.filter(m => !(byMRN.has(m.MRN)||byName.has(m.Name.toUpperCase()))).length}`
    );

    // Re-apply sort if one was active
    if (currentSortColumn) {
        reSort();
    }
}

	    
	
function copyPatientInfoImproved(button) {
    const patient = button.patientData;
    const name = patient.Name || 'Unknown';
    const rm = patient.RM || 'Unknown';
    const mrn = patient.MRN || 'Unknown';
    
    // Format the text to copy
    const textToCopy = `${name}\n${rm}\n${mrn}`;
    
    // Store data needed for rebuild
    const columnIndexes = button.columnIndexes;
    const colorClasses = button.colorClasses;
    
    const rebuildOriginalContent = () => {
        button.innerHTML = '';
        
        columnIndexes.forEach((colIndex, idx) => {
            const header = MASTER_HEADERS[colIndex];
            const value = patient[header] || '';
            if (value) {
                const span = document.createElement('span');
                span.className = colorClasses[idx % colorClasses.length];
                span.textContent = value;
                span.style.display = 'block';
                button.appendChild(span);
            }
        });
    };
    
    // Copy to clipboard
    navigator.clipboard.writeText(textToCopy).then(() => {
        button.innerHTML = '<span style="color: var(--success); font-weight: bold;">COPIED!</span>';
        button.classList.add('copied');
        
        setTimeout(() => {
            rebuildOriginalContent();
            button.classList.remove('copied');
        }, 200);
    }).catch(err => {
        // Fallback
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();
        
        try {
            document.execCommand('copy');
            button.innerHTML = '<span style="color: var(--success); font-weight: bold;">COPIED!</span>';
            button.classList.add('copied');
            
            setTimeout(() => {
                rebuildOriginalContent();
                button.classList.remove('copied');
            }, 200);
        } catch (err) {
            alert('Failed to copy. Please copy manually: ' + textToCopy);
        }
        
        document.body.removeChild(textArea);
    });
}

    














function generateFullChecklistHTML() {
  const patient = patientData[currentPatientIndex];
  const patientKey = `${currentPatientIndex}_${patient.Name || 'unnamed'}`;
  const isTrauma = patient.Type !== 'Consult';

  // Initialize patient's checklist state
  if (!tempChecklistStates[patientKey]) {
    tempChecklistStates[patientKey] = {};
  }
  const states = tempChecklistStates[patientKey];

  // ========= DATA (with nested Patient care) =========
  const traumaItems = [
    // ADD TO LIST
    { section: 'ADD TO LIST', color: '#dc2626', text: 'Add to list' },

    // STAFF
    { section: 'STAFF', color: '#d97706', text: 'Staff' },
    { section: 'STAFF', color: '#d97706', text: 'Order Scans' },

    // NOTE
    { section: 'NOTE (include HCP)', color: '#16a34a', text: 'Advanced Directives/Goals of Care/HCP' },

    // F/U SCANS AND LABS
    { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Primary review of imaging' },
    { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Plan by injury: CTH, CT C/T/L Spine, CT chest/abdomen/pelvis, + additional scans (attending reads). <a href="https://docs.google.com/document/d/12lbPO5K7jMPhruuoedT-piCaQSr9dja2OObAeMD2NWk/edit?tab=t.0" target="_blank" rel="noopener noreferrer">Reading CT scans</a>' },
    { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Review labs' },
    { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'If going to OR: NPO at midnight ¬± IVF, Book OR + Call OR, consent, Type & screen within 3 days + historical, order 2U PRBCs on hold, Urine ¬± HCG EKG CXR coags, Order special booking needs/instruments' },

    // DISPO/ADDENDUM
    { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Sign out DISPO to ICU/Floor/ED' },
    { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'EVIDENCE BASED RECOMMENDATIONS FOR THEIR DIAGNOSIS' },
    { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Update family' },
    { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Tertiary Survey' },

    // ORDERS/CONSULTS
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Extra Scans/Consults' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'PSO if admitting - call bed board' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Diet order vs. NPO/IVF' },

    // PATIENT CARE (nested)
    {
      section: 'ORDERS/CONSULTS',
      color: '#0284c7',
      text: 'Patient care',
      children: [
        'Blood glucose monitoring',
		'Cardiac telemetry',
        'Lines/tubes/drains: Drain / NGT / Foley / OGT / chest tube / central line / arterial line / Peripheral IV orders',
        'Intake and output',
		'Intermittent Pneumatic Compression/SCDs',
		'Neurological / neurovascular checks', 
	    'Vital signs',
	    'Daily weight',
        'Code / resuscitation status',
        'Incentive spirometry', 
	    'Continuous pulse oximetry', 
		'Notify provider of abnormal vital signs (SBP >180 or <100, MAP <65, HR >110 or <50, RR >30 or <10, Change in O2 delivery)',
		'Activity: OOB ad lib/with assistance/Bedrest, weight bearing status', 
      ]
    },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Pain meds' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: '<a href="http://www.icucalorie.com/dvt/">DVT prophylaxis</a>' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Home medications' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Daily 2 AM labs (6am txp)' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Interval scans/studies/consults' },
    { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'EVIDENCE BASED MANAGEMENT of their diagnosis' },
  ];

  const consultItems = [
    { section: 'ADD TO LIST', color: '#2563eb', text: 'Add to list' },
    { section: 'STAFF', color: '#2563eb', text: 'Review HX/Vitals/IOs/Labs/Imaging with attending reads' },
    { section: 'STAFF', color: '#16a34a', text: 'Staff' },
    { section: 'NOTE', color: '#9333ea', text: 'Complete consultation note' },
    { section: 'NOTE', color: '#c026d3', text: 'EVIDENCE BASED RECOMMENDATIONS FOR THEIR DIAGNOSIS' },

    // ORDERS
    { section: 'ORDERS', color: '#d97706', text: 'PSO if admitting - call bed board' },
    { section: 'ORDERS', color: '#d97706', text: 'Diet order vs. NPO/IVF' },

    // PATIENT CARE (nested)
    {
      section: 'ORDERS',
      color: '#d97706',
      text: 'Patient care',
      children: [
        'Blood glucose monitoring',
		'Cardiac telemetry',
        'Lines/tubes/drains: Drain / NGT / Foley / OGT / chest tube / central line / arterial line / Peripheral IV orders',
        'Intake and output',
		'Intermittent Pneumatic Compression/SCDs',
		'Neurological / neurovascular checks', 
	    'Vital signs',
	    'Daily weight',
        'Code / resuscitation status',
        'Incentive spirometry', 
	    'Continuous pulse oximetry', 
		'Notify provider of abnormal vital signs (SBP >180 or <100, MAP <65, HR >110 or <50, RR >30 or <10, Change in O2 delivery)',
		'Activity: OOB ad lib/with assistance/Bedrest, weight bearing status', 
      ]
    },
    { section: 'ORDERS', color: '#d97706', text: 'Pain meds' },
    { section: 'ORDERS', color: '#d97706', text: '<a href="http://www.icucalorie.com/dvt/">DVT prophylaxis</a>' },
    { section: 'ORDERS', color: '#d97706', text: 'Home meds' },
    { section: 'ORDERS', color: '#d97706', text: 'Daily 2 AM labs (6am txp)' },
    { section: 'ORDERS', color: '#d97706', text: 'Consultations/Imaging/Interventions' },
    { section: 'ORDERS', color: '#d97706', text: 'EVIDENCE BASED MANAGEMENT of their diagnosis' },
    { section: 'ORDERS', color: '#d97706', text: 'Booking for OR: NPO at midnight ¬± IVF, Book OR + Call OR, consent, Type & screen within 3 days + historical, order 2U PRBCs on hold, Urine ¬± HCG EKG CXR coags, Order special booking needs/instruments' },
  ];

  const items = isTrauma ? traumaItems : consultItems;

  // ========= PROGRESS (count both parents & children) =========
  const totalItems = items.reduce((acc, it, i) => {
    const childrenCount = Array.isArray(it.children) ? it.children.length : 0;
    return acc + 1 + childrenCount;
  }, 0);

  const completed = items.reduce((acc, it, i) => {
    const parentChecked = !!states[`item_${i}`];
    let childChecked = 0;
    if (Array.isArray(it.children)) {
      it.children.forEach((_, idx) => {
        if (states[`item_${i}_child_${idx}`]) childChecked++;
      });
    }
    return acc + (parentChecked ? 1 : 0) + childChecked;
  }, 0);

  const progress = totalItems > 0 ? Math.round((completed / totalItems) * 100) : 0;

  // ========= HEADER & TOP PROGRESS =========
  let html = `
    <div style="margin-bottom: 1.5rem; text-align: center;">
      <div style="display:flex; justify-content:center; align-items:center; gap:0.5rem; margin-bottom:1rem;">
        <strong style="color:${isTrauma ? '#ef4444' : '#3b82f6'}; font-size:1.3em;">
          ${isTrauma ? 'TRAUMA' : 'CONSULT PATIENT'} CHECKLIST
        </strong>
        <button onclick="toggleChecklistType()"
          style="background:linear-gradient(135deg, ${isTrauma ? '#3b82f6' : '#ef4444'}, ${isTrauma ? '#2563eb' : '#dc2626'}); color:white; border:none; padding:0.2rem 0.5rem; border-radius:0.375rem; font-size:0.85rem; cursor:pointer; transition:all .3s; box-shadow:0 2px 4px rgba(0,0,0,.2);"
          onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          Switch to ${isTrauma ? 'Consult' : 'Trauma'}
        </button>
      </div>
    </div>

    <div style="margin-bottom:0.5rem; padding:0.2rem; background:var(--card-bg); border-radius:0.5rem; border:2px solid var(--primary);">
      <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem;">
        <strong style="color:var(--primary);">Progress</strong>
        <span id="progressTextTop" style="color:var(--text-primary);">${completed}/${totalItems} (${progress}%)</span>
      </div>
      <div style="background:var(--dark-bg); border-radius:1rem; height:10px; overflow:hidden;">
        <div id="progressBarTop" style="background:linear-gradient(90deg, var(--primary), var(--secondary)); height:100%; width:${progress}%; transition:width .3s;"></div>
      </div>
    </div>
  `;

  // ========= GROUP BY SECTION =========
  const sections = {};
  items.forEach((item, index) => {
    if (!sections[item.section]) sections[item.section] = [];
    sections[item.section].push({ ...item, index });
  });

  // ========= RENDER EACH SECTION (supports children) =========
  Object.entries(sections).forEach(([sectionName, sectionItems]) => {
    const sectionColor = sectionItems[0].color;
    const isOrders = sectionName.toUpperCase().includes('ORDERS');
    const sectionId = sectionName.replace(/[^a-zA-Z0-9]/g, '_');

    html += `
      <div style="margin-bottom:0.75rem;">
        <h4 style="color:${sectionColor}; margin-bottom:0.25rem; font-size:1.1em; font-weight:bold; cursor:${isOrders ? 'pointer' : 'default'};"
            ${isOrders ? `onclick="toggleSection('${sectionId}')"` : ''}>
          ${sectionName} ${isOrders ? '‚ñ∏' : ''}
        </h4>
        <div id="${isOrders ? sectionId : ''}"
             style="margin-left:1rem; display:grid; gap:0.15rem; ${isOrders ? 'display:none;' : ''}">
    `;

    sectionItems.forEach(item => {
      const parentChecked = !!states[`item_${item.index}`];

      // Parent row
      html += `
        <label style="display:flex; align-items:flex-start; gap:0.5rem; cursor:pointer; padding:0.2rem 0.5rem; border-radius:0.25rem; transition:background .2s; border:1px solid transparent;"
               onmouseover="this.style.background='var(--card-hover)'; this.style.borderColor='${sectionColor}30';"
               onmouseout="this.style.background='transparent'; this.style.borderColor='transparent';">
          <input type="checkbox" ${parentChecked ? 'checked' : ''}
                 onchange="updateFullChecklist('${patientKey}', '${item.index}', this.checked, ${/* total items */ totalItems})"
                 style="width:18px; height:18px; min-width:18px; margin-top:2px; accent-color:${sectionColor}; cursor:pointer;">
          <span style="color:var(--text-primary); font-size:0.95rem; line-height:1.4;">
            ${item.text}
          </span>
        </label>
      `;

      // Children (if any)
      if (Array.isArray(item.children) && item.children.length) {
        html += `<ul style="margin:0.25rem 0 0.5rem 1.5rem; padding-left:0.5rem; list-style:none; border-left:2px solid ${sectionColor}30;">`;
        item.children.forEach((childText, idx) => {
          const childKey = `${item.index}_child_${idx}`;
          const childChecked = !!states[`item_${childKey}`];
          html += `
            <li>
              <label style="display:flex; align-items:flex-start; gap:0.5rem; cursor:pointer; padding:0.15rem 0.5rem; border-radius:0.25rem;">
                <input type="checkbox" ${childChecked ? 'checked' : ''}
                       onchange="updateFullChecklist('${patientKey}', '${childKey}', this.checked, ${totalItems})"
                       style="width:18px; height:18px; min-width:18px; margin-top:2px; accent-color:${sectionColor}; cursor:pointer;">
                <span style="color:var(--text-primary); font-size:0.93rem; line-height:1.35;">
                  ${childText}
                </span>
              </label>
            </li>
          `;
        });
        html += `</ul>`;
      }
    });

    html += `</div></div>`;
  });

  // ========= BOTTOM PROGRESS =========
  html += `
    <div style="margin-top:0.5rem; padding:0.2rem; background:var(--card-bg); border-radius:0.5rem; border:2px solid var(--primary);">
      <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem;">
        <strong style="color:var(--primary);">Progress</strong>
        <span id="progressTextBottom" style="color:var(--text-primary);">${completed}/${totalItems} (${progress}%)</span>
      </div>
      <div style="background:var(--dark-bg); border-radius:1rem; height:10px; overflow:hidden;">
        <div id="progressBarBottom" style="background:linear-gradient(90deg, var(--primary), var(--secondary)); height:100%; width:${progress}%; transition:width .3s;"></div>
      </div>
    </div>
  `;

  return html;
}

// Collapsible helper (unchanged)
function toggleSection(sectionId) {
  const section = document.getElementById(sectionId);
  if (!section) return;
  const nowHidden = section.style.display === 'none';
  section.style.display = nowHidden ? 'grid' : 'none';
  const header = section.previousElementSibling;
  if (!header) return;
  if (header.innerHTML.includes('‚ñ∏')) {
    header.innerHTML = header.innerHTML.replace('‚ñ∏', '‚ñæ');
  } else {
    header.innerHTML = header.innerHTML.replace('‚ñæ', '‚ñ∏');
  }
}

// Update state & progress (supports child keys like "3_child_2")
function updateFullChecklist(patientKey, key, checked, totalItems) {
  if (!tempChecklistStates[patientKey]) tempChecklistStates[patientKey] = {};
  tempChecklistStates[patientKey][`item_${key}`] = !!checked;

  // Persist
  try {
    localStorage.setItem('checklistStates', JSON.stringify(tempChecklistStates));
  } catch (e) {
    console.error('Failed to save checklist states:', e);
  }

  // Recompute progress across all keys for this patient
  const states = tempChecklistStates[patientKey];
  const completed = Object.keys(states).filter(k => k.startsWith('item_') && states[k]).length;
  const progress = totalItems > 0 ? Math.round((completed / totalItems) * 100) : 0;

  // Update BOTH progress bars/texts
  const topBar = document.getElementById('progressBarTop');
  const botBar = document.getElementById('progressBarBottom');
  const topText = document.getElementById('progressTextTop');
  const botText = document.getElementById('progressTextBottom');

  if (topBar) topBar.style.width = `${progress}%`;
  if (botBar) botBar.style.width = `${progress}%`;
  if (topText) topText.textContent = `${completed}/${totalItems} (${progress}%)`;
  if (botText) botText.textContent = `${completed}/${totalItems} (${progress}%)`;
}








		




		

function updateFullChecklist(patientKey, index, checked, totalItems) {
    // Update temporary state
    if (!tempChecklistStates[patientKey]) {
        tempChecklistStates[patientKey] = {};
    }
    tempChecklistStates[patientKey][`item_${index}`] = !!checked;

    // Persist
    try {
        localStorage.setItem('checklistStates', JSON.stringify(tempChecklistStates));
    } catch (e) {
        console.error('Failed to save checklist states:', e);
    }

    // Recompute progress (count only checklist items)
    const states = tempChecklistStates[patientKey];
    const completed = Object.keys(states).filter(k => k.startsWith('item_') && states[k]).length;
    const progress = Math.round((completed / totalItems) * 100);

    // Update BOTH progress bars/texts
    const topBar = document.getElementById('progressBarTop');
    const botBar = document.getElementById('progressBarBottom');
    const topText = document.getElementById('progressTextTop');
    const botText = document.getElementById('progressTextBottom');

    if (topBar) topBar.style.width = `${progress}%`;
    if (botBar) botBar.style.width = `${progress}%`;
    if (topText) topText.textContent = `${completed}/${totalItems} (${progress}%)`;
    if (botText) botText.textContent = `${completed}/${totalItems} (${progress}%)`;
}






		














		function showHelpModal(fieldName) {
    const modal = document.getElementById('helpModal') || createHelpModal();
    const title = document.getElementById('helpModalTitle');
    const body = document.getElementById('helpModalBody');
    
    title.textContent = `${fieldName} - Help & Instructions`;
    
    // Special handling for interactive 'To do' checklist
    if (fieldName === 'To do' && currentPatientIndex !== -1) {
        body.innerHTML = generateFullChecklistHTML();
    } else {
        body.innerHTML = helpContent[fieldName] || 'No help content available.';
    }
    
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
}













		

function closeHelpModal() {
    const modal = document.getElementById('helpModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Restore background scrolling
    }
}


		

function createHelpModal() {
    const modal = document.createElement('div');
    modal.id = 'helpModal';
    modal.className = 'help-modal';
    modal.innerHTML = `
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2 id="helpModalTitle" class="help-modal-title">Help & Instructions</h2>
                <button class="help-modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div id="helpModalBody" class="help-modal-body">
                <!-- Content will be inserted here -->
            </div>
        </div>
    `;
    

    
    document.body.appendChild(modal);
    return modal;
}








		function exportCSV() {
    if (patientData.length === 0) {
        alert('No data to export');
        return;
    }
    
    // Define the fields to export (exclude internal fields)
    const exportFields = MASTER_HEADERS.slice(0, -2); // Exclude ImportedData and LabData
    
    // Create CSV header
    let csvContent = exportFields.join(',') + '\n';
    
    // Add data rows
    patientData.forEach(patient => {
        const row = exportFields.map(field => {
            const value = patient[field] || '';
            // Escape commas and quotes in values
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                return '"' + value.replace(/"/g, '""') + '"';
            }
            return value;
        });
        csvContent += row.join(',') + '\n';
    });
    
    // Create filename with format: list_M.D.YY.csv
    const now = new Date();
    const month = now.getMonth() + 1;
    const day = now.getDate();
    const year = String(now.getFullYear()).slice(-2);
    const filename = `list_${month}.${day}.${year}.csv`;
    
    downloadFile(csvContent, filename, 'text/csv');
}



		
		function parseCSVData(csvText) {
    console.log('Parsing CSV data...');
    
    // Check if Papa Parse is available
    if (typeof Papa === 'undefined') {
        console.error('Papa Parse not loaded, using fallback parser');
        return parseCSVFallback(csvText);
    }
    
    // Parse CSV using Papa Parse with better configuration
    const parsed = Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true,
        trimHeaders: true,
        transform: function(value) {
            return value ? value.trim() : '';
        }
    });
    
    console.log('Papa Parse result:', parsed);
    
    if (parsed.errors.length > 0) {
        console.warn('CSV parsing errors:', parsed.errors);
    }
    
    const csvData = parsed.data;
    if (!csvData || csvData.length === 0) {
        console.error('No data found in CSV');
        return [];
    }
    
    console.log('CSV headers found:', Object.keys(csvData[0]));
    console.log('First row data:', csvData[0]);
    
    // Create header mapping
    const csvHeaders = Object.keys(csvData[0]);
    const headerMap = createHeaderMapping(csvHeaders);
    
    console.log('Header mapping:', headerMap);
    
    // Convert CSV rows to patient objects
    const patients = [];
    csvData.forEach((row, index) => {
        // Skip completely empty rows
        const hasData = Object.values(row).some(val => val && val.toString().trim() !== '');
        if (!hasData) {
            return;
        }
        
        // Create new patient object
        const patient = {};
        MASTER_HEADERS.forEach(header => {
            patient[header] = '';
        });
        
        // Set default type
        patient.Type = 'Patient';
        
        // Map CSV data to patient fields
        Object.entries(headerMap).forEach(([csvHeader, appField]) => {
            if (row[csvHeader] && row[csvHeader].toString().trim()) {
                patient[appField] = row[csvHeader].toString().trim();
            }
        });
        
        // Also try direct field mapping for exact matches
        csvHeaders.forEach(csvHeader => {
            if (MASTER_HEADERS.includes(csvHeader) && row[csvHeader]) {
                patient[csvHeader] = row[csvHeader].toString().trim();
            }
        });
        
        console.log(`Row ${index + 1} mapped to:`, patient);
        
        // Add patient if we have at least a name or MRN
        if (patient.Name || patient.MRN) {
            patients.push(patient);
        }
    });
    
    console.log(`Successfully parsed ${patients.length} patients from CSV`);
    return patients;
}

// Fallback CSV parser in case Papa Parse fails
function parseCSVFallback(csvText) {
    console.log('Using fallback CSV parser');
    
    const lines = csvText.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
        return [];
    }
    
    // Parse headers
    const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
    console.log('Fallback parser headers:', headers);
    
    const headerMap = createHeaderMapping(headers);
    console.log('Fallback header mapping:', headerMap);
    
    const patients = [];
    
    for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        if (values.length === 0) continue;
        
        const patient = {};
        MASTER_HEADERS.forEach(header => {
            patient[header] = '';
        });
        patient.Type = 'Patient';
        
        // Map values to fields
        headers.forEach((header, index) => {
            if (values[index] && headerMap[header]) {
                patient[headerMap[header]] = values[index].trim();
            }
        });
        
        // Direct mapping for exact matches
        headers.forEach((header, index) => {
            if (MASTER_HEADERS.includes(header) && values[index]) {
                patient[header] = values[index].trim();
            }
        });
        
        if (patient.Name || patient.MRN) {
            patients.push(patient);
        }
    }
    
    return patients;
}

// Simple CSV line parser that handles quotes
function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    
    result.push(current);
    return result.map(val => val.replace(/"/g, '').trim());
}



		function createHeaderMapping(csvHeaders) {
    const headerMap = {};
    
    console.log('Creating header mapping for:', csvHeaders);
    
    // Define flexible mappings - more comprehensive
    const fieldMappings = {
        'Name': ['name', 'patient name', 'patient_name', 'full name', 'fullname', 'pt name', 'patient'],
        'RM': ['rm', 'room', 'room number', 'room_number', 'bed', 'room#', 'rm#'],
        'MRN': ['mrn', 'medical record number', 'medical_record_number', 'record number', 'patient id', 'patient_id', 'id', 'record#'],
        'Att': ['att', 'attending', 'physician', 'doctor', 'attending physician', 'attending_physician', 'md', 'provider'],
        'A/G': ['a/g', 'ag', 'age/gender', 'age_gender', 'age gender', 'age', 'gender'],
        'CC': ['cc', 'chief complaint', 'chief_complaint', 'complaint', 'reason'],
        'Problems': ['problems', 'problem list', 'problem_list', 'diagnosis', 'diagnoses', 'dx'],
        'HPI': ['hpi', 'history of present illness', 'history_of_present_illness', 'present illness', 'history'],
        'ROS': ['ros', 'review of systems', 'review_of_systems', 'systems review'],
        'PMH': ['pmh', 'past medical history', 'past_medical_history', 'medical history', 'medical_history', 'past history'],
        'Meds': ['meds', 'medications', 'drugs', 'medicine'],
        'All': ['all', 'allergies', 'allergy', 'allergic'],
        'Surg hx': ['surg hx', 'surgical history', 'surgical_history', 'surgery history', 'surgery_history', 'surgeries'],
        'FSH': ['fsh', 'family social history', 'family_social_history', 'family/social', 'family social', 'family history', 'social history'],
        'ICS': ['ics', 'interval change', 'interval_change', 'changes', 'updates'],
        'VIOLIN': ['violin', 'vitals', 'labs', 'lab values', 'vital signs'],
        'PE': ['pe', 'physical exam', 'physical_exam', 'examination', 'exam', 'physical'],
        'ORDERS': ['orders', 'order', 'medical orders', 'medical_orders', 'plan', 'treatment'],
        'To do': ['to do', 'todo', 'to_do', 'plan', 'action items', 'action_items', 'tasks'],
        'Priority': ['priority', 'urgency', 'level', 'importance']
    };
    
    // Match CSV headers to application fields
    csvHeaders.forEach(csvHeader => {
        const csvHeaderLower = csvHeader.toLowerCase().trim();
        
        console.log(`Checking header: "${csvHeader}" (${csvHeaderLower})`);
        
        // Direct match first (case insensitive)
        const directMatch = MASTER_HEADERS.find(field => 
            field.toLowerCase() === csvHeaderLower
        );
        
        if (directMatch) {
            headerMap[csvHeader] = directMatch;
            console.log(`Direct match: ${csvHeader} -> ${directMatch}`);
            return;
        }
        
        // Check flexible mappings
        for (const [appField, variations] of Object.entries(fieldMappings)) {
            if (variations.some(variation => csvHeaderLower === variation || csvHeaderLower.includes(variation))) {
                headerMap[csvHeader] = appField;
                console.log(`Flexible match: ${csvHeader} -> ${appField}`);
                return;
            }
        }
        
        console.log(`No match found for: ${csvHeader}`);
    });
    
    return headerMap;
}





function pasteFromClipboard() {
    const textarea = document.getElementById('importData');
    const button = event.target;
    const originalText = button.textContent;
    const originalBackground = button.style.background;
    const originalColor = button.style.color;
    
    // Clear any existing content first
    textarea.value = '';
    
    button.textContent = 'Reading clipboard...';
    button.disabled = true;
    
    // Check if clipboard API is available
    if (!navigator.clipboard || !navigator.clipboard.readText) {
        // Fallback for browsers without clipboard API
        button.textContent = 'Manual paste required';
        button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
        button.style.color = 'white';
        button.disabled = false;
        
        setTimeout(() => {
            alert('Automatic clipboard reading not supported.\n\nPlease:\n1. Click in the text area below\n2. Press Ctrl+V (or Cmd+V on Mac) to paste\n3. Click "Process Data" button');
            button.textContent = originalText;
            button.style.background = originalBackground;
            button.style.color = originalColor;
            textarea.focus();
        }, 500);
        return;
    }
    
    // Try to read from clipboard
    navigator.clipboard.readText()
        .then(text => {
            console.log('Clipboard read successful, text length:', text ? text.length : 0);
            
            if (text && text.trim()) {
                // Paste the content
                textarea.value = text;
                button.textContent = 'Processing data...';
                
                // Add a small delay to show the pasted content, then call the existing process function
                setTimeout(() => {
                    try {
                        // Use the existing processImportedData function instead of duplicating logic
                        processImportedData();
                        
                        // Success feedback
                        button.textContent = 'Completed!';
                        button.style.background = 'linear-gradient(135deg, var(--success), #059669)';
                        button.style.color = 'white';
                        button.disabled = false;
                        
                        // Auto-reset button after 3 seconds
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = originalBackground;
                            button.style.color = originalColor;
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Error processing data:', error);
                        button.textContent = 'Processing Error';
                        button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
                        button.style.color = 'white';
                        button.disabled = false;
                        
                        alert('Error processing the pasted data: ' + error.message);
                        
                        // Reset button after error
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = originalBackground;
                            button.style.color = originalColor;
                        }, 3000);
                    }
                }, 300);
                
            } else {
                // Reset button if clipboard is empty
                button.textContent = 'Clipboard Empty';
                button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
                button.style.color = 'white';
                button.disabled = false;
                
                setTimeout(() => {
                    alert('Clipboard appears to be empty.\n\nPlease:\n1. Copy some data first\n2. Try the button again');
                    button.textContent = originalText;
                    button.style.background = originalBackground;
                    button.style.color = originalColor;
                }, 1000);
            }
        })
        .catch(err => {
            console.error('Failed to read clipboard:', err);
            button.textContent = 'Permission Required';
            button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
            button.style.color = 'white';
            button.disabled = false;
            
            // Show helpful message
            setTimeout(() => {
                alert('Clipboard permission required.\n\nPlease:\n1. Allow clipboard access when prompted by your browser\n2. Make sure you have data copied to clipboard\n3. Try the button again\n\nOR paste manually with Ctrl+V in the text area below');
                
                button.textContent = originalText;
                button.style.background = originalBackground;
                button.style.color = originalColor;
                textarea.focus(); // Focus textarea for manual paste
            }, 500);
        });
}


		



		function resetPasteButton() {
    const button = document.querySelector('#importModal button[onclick="pasteFromClipboard()"]');
    if (button) {
        button.textContent = 'üìã‚ö° Paste & Process';
        button.style.background = '';
        button.style.color = '';
        button.disabled = false;
    }
}

		



		function showFormattedVIOLIN() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Formatted VIOLIN Data</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 70vh; overflow-y: auto;">${formattedContent}</div>
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}


		function showFormattedVIOLIN() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Formatted VIOLIN Results</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 70vh; overflow-y: auto;">${formattedContent}</div>
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

		


function showFishbonePopup() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Generate missing values messages
    const missingValues = generateMissingValuesMessages(labData);
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 60vh; overflow-y: auto;">${formattedContent}</div>
            ${missingValues ? `<div style="background: var(--card-bg); margin-top: 1rem; padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border);"><div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 0.5rem;"><strong>Missing Values:</strong></div><div style="font-style: italic; color: var(--text-secondary); font-size: 0.85rem; line-height: 1.4;">${missingValues}</div></div>` : ''}
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="copyFishboneToClipboard()">üìã Copy to Clipboard</button>
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Store fishbone content for copy function
    window.currentFishboneContent = violinText;
}
		



		

		// 3. ADD this function to generate missing values messages:

function generateMissingValuesMessages(data) {
    const missing = [];
    
    // Check vitals
    if (!data.vitals.hr || data.vitals.hr.length === 0) missing.push('No HR');
    if (!data.vitals.sbp || data.vitals.sbp.length === 0) missing.push('No SBP');
    if (!data.vitals.dbp || data.vitals.dbp.length === 0) missing.push('No DBP');
    if (!data.vitals.temp || data.vitals.temp.length === 0) missing.push('No Temp');
    if (!data.vitals.o2 || data.vitals.o2.length === 0) missing.push('No SPO2');
    
    // Check if MAP is missing (would need to be calculated or extracted)
    const hasMAP = lastImportedData && /Mean\s+(?:Arterial\s+)?Pressure/i.test(lastImportedData);
    if (!hasMAP) missing.push('No MAP');
    
    // Check respiratory rate
    const hasRR = lastImportedData && /Respiratory\s+Rate/i.test(lastImportedData);
    if (!hasRR) missing.push('No RR');
    
    // Check O2 therapy
    if (!data.o2therapyCode && !data.o2therapyRaw) missing.push('No O2 therapy documented');
    
    // Check ventilator settings if on vent
    if (data.o2therapyCode === 'Vent') {
        if (!data.ventModeRaw) missing.push('No Vent Mode');
        if (!data.ventFrequencyRaw) missing.push('No Vent RR');
        if (!data.ventTidalRaw) missing.push('No Vt');
        if (!data.ventPeepRaw) missing.push('No PEEP');
        if (!data.ventFiO2Raw) missing.push('No FIO2');
    }
    
    // Check intake/output data if lastImportedData exists
    if (lastImportedData) {
        const ioData = extractIntakeOutputData(lastImportedData);
        
        // Check for specific I/O types
        if (ioData.intakes.bloodProducts.length === 0) {
            const hasBloodProducts = /blood.*product|packed.*cell|plasma|platelet/i.test(lastImportedData);
            if (!hasBloodProducts) missing.push('No blood products');
        }
        
        if (ioData.intakes.other.length === 0) {
            const hasOralIntake = /oral|po\s|by\s+mouth/i.test(lastImportedData);
            if (!hasOralIntake) missing.push('No oral intake');
        }
        
        const hasIVF = /lactated.*ringer|normal.*saline|dextrose.*water|d5w|lr|ns/i.test(lastImportedData);
        if (!hasIVF) missing.push('No IVF');
        
        if (ioData.intakes.enteral.length === 0) {
            const hasTubeFeeds = /tube.*feed|enteral|nasogastric.*feed/i.test(lastImportedData);
            if (!hasTubeFeeds) missing.push('No tube feeds');
        }
        
        // Check outputs
        if (ioData.outputs.urine.length === 0) missing.push('No UOP');
        
        const hasOstomy = /ostomy|colostomy|ileostomy|stoma/i.test(lastImportedData);
        if (!hasOstomy) missing.push('No ostomy output');
        
        const hasBM = /bowel.*movement|bm|stool/i.test(lastImportedData);
        if (!hasBM) missing.push('No BM');
        
        const hasEmesis = /emesis|vomit|nausea.*vomit/i.test(lastImportedData);
        if (!hasEmesis) missing.push('No emesis');
        
        const hasBloodLoss = /blood.*loss|ebl|estimated.*blood/i.test(lastImportedData);
        if (!hasBloodLoss) missing.push('No blood loss');
        
        const hasDialysis = /dialysis|cvvh|crrt/i.test(lastImportedData);
        if (!hasDialysis) missing.push('No dialysis');
    }
    
    // Check labs
    if (!data.labs.wbc || data.labs.wbc.length === 0) missing.push('No WBC');
    if (!data.labs.hgb || data.labs.hgb.length === 0) missing.push('No Hgb');
    if (!data.labs.hct || data.labs.hct.length === 0) missing.push('No Hct');
    if (!data.labs.plt || data.labs.plt.length === 0) missing.push('No Plt');
    
    // BMP
    if (!data.labs.na || data.labs.na.length === 0) missing.push('No Na');
    if (!data.labs.k || data.labs.k.length === 0) missing.push('No K');
    if (!data.labs.cl || data.labs.cl.length === 0) missing.push('No Cl');
    if (!data.labs.co2 || data.labs.co2.length === 0) missing.push('No CO2');
    if (!data.labs.bun || data.labs.bun.length === 0) missing.push('No BUN');
    if (!data.labs.cr || data.labs.cr.length === 0) missing.push('No Cr');
    if (!data.labs.glu || data.labs.glu.length === 0) missing.push('No Glucose');
    
    // Additional electrolytes
    if (!data.labs.ca || data.labs.ca.length === 0) missing.push('No Ca');
    if (!data.labs.mg || data.labs.mg.length === 0) missing.push('No Mg');
    if (!data.labs.phos || data.labs.phos.length === 0) missing.push('No P');
    
    // LFTs
    if (!data.labs.tbil || data.labs.tbil.length === 0) missing.push('No Tbil');
    if (!data.labs.dbil || data.labs.dbil.length === 0) missing.push('No Dbili');
    if (!data.labs.alk || data.labs.alk.length === 0) missing.push('No ALK');
    if (!data.labs.ggt || data.labs.ggt.length === 0) missing.push('No GGT');
    if (!data.labs.ast || data.labs.ast.length === 0) missing.push('No AST');
    if (!data.labs.alt || data.labs.alt.length === 0) missing.push('No ALT');
    
    // Coags
    if (!data.labs.pt || data.labs.pt.length === 0) missing.push('No PT');
    if (!data.labs.ptt || data.labs.ptt.length === 0) missing.push('No PTT');
    if (!data.labs.inr || data.labs.inr.length === 0) missing.push('No INR');
    
    // ABG
    if (!data.labs.ph || data.labs.ph.length === 0) missing.push('No pH');
    if (!data.labs.po2 || data.labs.po2.length === 0) missing.push('No PO2');
    if (!data.labs.pco2 || data.labs.pco2.length === 0) missing.push('No PCO2');
    if (!data.labs.bicarb || data.labs.bicarb.length === 0) missing.push('No Bicarb');
    if (!data.labs.lactate || data.labs.lactate.length === 0) missing.push('No Lactate');
    
    // Other important labs
    if (!data.labs.trop || data.labs.trop.length === 0) missing.push('No Trops');
    
    // Base excess check (would need to be added to extraction)
    const hasBaseExcess = lastImportedData && /base.*excess/i.test(lastImportedData);
    if (!hasBaseExcess) missing.push('No Base excess');
    
    if (missing.length === 0) {
        return null;
    }
    
    return missing.join(', ');
}

// 4. ADD this function for copying fishbone content:

function copyFishboneToClipboard() {
    if (window.currentFishboneContent) {
        navigator.clipboard.writeText(window.currentFishboneContent).then(() => {
            // Change button text briefly to show success
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '‚úÖ Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = window.currentFishboneContent;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textArea);
        });
    }
}



function toggleFishboneDisplay() {
    const fishboneDisplay = document.getElementById('fishboneDisplay');
    const fishboneContent = document.getElementById('fishboneContent');
    
    if (!fishboneDisplay || !fishboneContent) {
        console.error('Fishbone display elements not found');
        return;
    }
    
    if (fishboneDisplay.classList.contains('hidden')) {
        // Show fishbone - generate it if needed
        const patient = patientData[currentPatientIndex];


		
        if (patient && patient.VIOLIN) {
            // Format content with red styling for abnormal values
 fishboneContent.innerHTML = '';
    const preElement = document.createElement('pre');
    preElement.style.margin = '0';
    preElement.style.fontFamily = 'inherit';
    preElement.style.fontSize = 'inherit';
    preElement.style.lineHeight = 'inherit';
    preElement.style.whiteSpace = 'pre-wrap';
    preElement.style.wordWrap = 'break-word';
    
    // Apply red styling while preserving exact spacing
preElement.innerHTML = patient.VIOLIN.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">*$1*</span>');
			
    fishboneContent.appendChild(preElement);
            
            // Add missing values if available
            if (labData && Object.keys(labData).length > 0) {
                const missingValues = generateMissingValuesMessages(labData);
                if (missingValues) {
                    const missingDiv = document.createElement('div');
                    missingDiv.style.marginTop = '1rem';
                    missingDiv.style.padding = '0.75rem';
                    missingDiv.style.background = 'rgba(100, 100, 100, 0.1)';
                    missingDiv.style.borderRadius = '0.25rem';
                    missingDiv.style.fontSize = '0.85rem';
                    missingDiv.innerHTML = `<strong style="color: var(--text-secondary);">Missing Values:</strong><br><span style="font-style: italic; color: var(--text-secondary);">${missingValues}</span>`;
                    fishboneContent.appendChild(missingDiv);
                }
            }
        } else {
            fishboneContent.innerHTML = '<em style="color: var(--text-secondary);">No VIOLIN data available. Import data first.</em>';
        }
        
        fishboneDisplay.classList.remove('hidden');
        
        // Scroll the fishbone into view
        setTimeout(() => {
            fishboneDisplay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    } else {
        // Hide fishbone
        fishboneDisplay.classList.add('hidden');
    }
}

		


		
function showFishboneInline() {
    if (currentPatientIndex === -1 || !patientData[currentPatientIndex]) {
        alert('No patient selected');
        return;
    }
    
    const patient = patientData[currentPatientIndex];
    
    if (!patient.VIOLIN || patient.VIOLIN.trim().length === 0) {
        alert('No VIOLIN data available. Please import data first.');
        return;
    }
    
    // Show the fishbone in a modal with proper formatting
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px; max-height: 80vh;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">VIOLIN (Vitals, Labs, I/O)</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; border: 1px solid var(--border); font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); max-height: 60vh; overflow-y: auto;">
                ${patient.VIOLIN.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>')}
            </div>
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="copyFishboneData()">üìã Copy</button>
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Store for copy function
    window.currentFishboneContent = patient.VIOLIN;
}

function copyFishboneData() {
    if (window.currentFishboneContent) {
        navigator.clipboard.writeText(window.currentFishboneContent).then(() => {
            const btn = event.target;
            btn.textContent = '‚úÖ Copied!';
            setTimeout(() => {
                btn.textContent = 'üìã Copy';
            }, 2000);
        }).catch(() => {
            alert('Failed to copy');
        });
    }
}






























		





	function toggleChecklistType() {
    const patient = patientData[currentPatientIndex];
    const patientKey = `${currentPatientIndex}_${patient.Name || 'unnamed'}`;
    
    // Toggle patient type
    if (patient.Type === 'Consult') {
        patient.Type = 'Patient';
    } else {
        patient.Type = 'Consult';
    }
    
    // Clear the checklist state since items are different
    if (tempChecklistStates[patientKey]) {
        tempChecklistStates[patientKey] = {};
    }
    
    // Save the patient type change
    saveToLocalStorage();
    
    // Regenerate the checklist HTML
    const body = document.getElementById('helpModalBody');
    if (body) {
        body.innerHTML = generateFullChecklistHTML();
    }
    
    // Also update the main list display
    displayRows();
}














		function showChecklistStatus(index) {
    const patient = patientData[index];
    const status = getChecklistStatus(patient, index);
    const isTrauma = patient.Type !== 'Consult';
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                ${patient.Name || 'Unnamed'} - Checklist Status
            </h3>
            <div style="text-align: center; margin: 1.5rem 0;">
                <div style="display: inline-block; width: 80px; height: 80px; border-radius: 50%; 
                           background: ${status.percentage === 100 ? 'var(--success)' : 'var(--danger)'}; 
                           display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <span style="color: white; font-size: 1.5rem; font-weight: bold;">
                        ${status.percentage}%
                    </span>
                </div>
                <div style="color: var(--text-primary); margin-bottom: 0.5rem;">
                    <strong>${isTrauma ? 'Trauma' : 'Consult'} Checklist Progress</strong>
                </div>
                <div style="color: var(--text-secondary);">
                    ${status.completed} of ${status.total} items completed
                </div>
            </div>
            <div style="text-align: center;">
                <button onclick="showDetails(${index}); this.closest('.modal').remove();">
                    View Details
                </button>
                <button onclick="this.closest('.modal').remove();" style="margin-left: 0.5rem;">
                    Close
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function showPriorityStatus(index) {
    const patient = patientData[index];
    const priorityStatus = getPriorityStatus(patient);
    const priority = patient.Priority || 'Not set';
    
    let statusColor = 'var(--card-bg)';
    let statusText = 'No Priority';
    
    switch(priorityStatus) {
        case 'high':
            statusColor = '#ef4444';
            statusText = 'High Priority';
            break;
        case 'medium':
            statusColor = '#f59e0b';
            statusText = 'Medium Priority';
            break;
        case 'low':
            statusColor = '#10b981';
            statusText = 'Low Priority';
            break;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                ${patient.Name || 'Unnamed'} - Priority Status
            </h3>
            <div style="text-align: center; margin: 1.5rem 0;">
                <div style="display: inline-block; width: 80px; height: 80px; border-radius: 50%; 
                           background: ${statusColor}; display: flex; align-items: center; 
                           justify-content: center; margin-bottom: 1rem;">
                    <span style="color: white; font-size: 2rem;">‚óè</span>
                </div>
                <div style="color: var(--text-primary); margin-bottom: 0.5rem;">
                    <strong>${statusText}</strong>
                </div>
                <div style="color: var(--text-secondary);">
                    Priority: ${priority}
                </div>
            </div>
            <div style="text-align: center;">
                <button onclick="showDetails(${index}); this.closest('.modal').remove();">
                    View Details
                </button>
                <button onclick="this.closest('.modal').remove();" style="margin-left: 0.5rem;">
                    Close
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}










	// REPLACE the showStatusSelector function (around line 2990) with this updated version:

function showStatusSelector(patient, index, statusElement) {
    // Updated priority options with new red-to-blue gradient
    const priorityOptions = [
        { num: '', name: 'No Priority', color: '#444444' },                   // Dark gray
       { num: 'C', name: 'Priority C - Complete/Done', color: '#00ff41' },
        { num: '1', name: 'Priority 1 - Urgent', color: '#ff0000' },          // Bright red
        { num: '2', name: 'Priority 2 - High', color: '#ff2400' },            // Red-orange
        { num: '3', name: 'Priority 3 - Medium-High', color: '#ff4900' },     // Orange
        { num: '4', name: 'Priority 4 - Medium', color: '#ff6d00' },          // Orange-yellow
        { num: '5', name: 'Priority 5 - Medium-Low', color: '#ff9200' },      // Yellow
        { num: '6', name: 'Priority 6 - Low-Medium', color: '#ffb600' },      // Dark yellow
        { num: '7', name: 'Priority 7 - Low', color: '#ffdb00' },             // yellow
        { num: '8', name: 'Priority 8 - Very Low', color: '#ffff00' },        // yellow
        { num: '9', name: 'Priority 9 - Minimal', color: '#800080' },         // light purple
        { num: '10', name: 'Priority 10 - Lowest', color: '#bf00bf' },        // Deep blue
    ];
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 450px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                Set Priority for ${patient.Name || 'Unnamed'}
            </h3>
            <div style="display: grid; gap: 0.5rem; margin-bottom: 1rem; max-height: 500px; overflow-y: auto;">
                ${priorityOptions.map(option => `
                    <button onclick="setPatientPriority('${option.num}', ${index}, this.closest('.modal'))" 
                            style="padding: 0.75rem; text-align: left; background: var(--card-bg); 
                                   border: 1px solid var(--border); border-radius: 0.375rem; 
                                   color: var(--text-primary); cursor: pointer; display: flex; 
                                   align-items: center; gap: 0.75rem;"
                            onmouseover="this.style.background='var(--card-hover)'"
                            onmouseout="this.style.background='var(--card-bg)'">
                        <div style="width: 20px; height: 20px; border-radius: 0.25rem; 
                                    background: ${option.color}; border: 2px solid rgba(255,255,255,0.2);"></div>
                        <span style="flex: 1;">${option.name}</span>
                        <div style="width: 8px; height: 30px; background: ${option.color}; 
                                    border-radius: 0.25rem; opacity: 0.8;"></div>
                    </button>
                `).join('')}
            </div>
            <div style="text-align: center;">
                <button onclick="this.closest('.modal').remove()">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}


		



		

function getStatusColor(colorName) {
    const colors = {
        'red': '#ef4444',
        'yellow': '#f59e0b', 
        'green': '#10b981',
        'blue': '#3b82f6',
        'purple': '#8b5cf6',
        'orange': '#f97316',
        'grey': 'var(--card-bg)'
    };
    return colors[colorName] || 'var(--card-bg)';
}




		function setPatientPriority(priorityNum, index, modal) {
    // Set the priority number
    patientData[index].Priority = priorityNum;
    
    // Remove any saved status since we're now using priority-based system
    delete patientData[index].SavedStatus;
    
    // Save to localStorage
    saveToLocalStorage();
    
    // Refresh the display
    displayRows();
    
    // Close the modal
    modal.remove();
}













































// Camera and OCR Functions - Global variables
let currentImageCanvas = null;
let currentRotation = 0;
let baseImageSrc = null;
let extractedData = { name: '', mrn: '' };
let lastOCRText = '';

function showCameraEntry() {
    document.getElementById('entryTypeSelection').style.display = 'none';
    document.getElementById('cameraEntrySection').style.display = 'block';
    resetCameraUI();
}

function resetCameraUI() {
    document.getElementById('capturedImage').style.display = 'none';
    document.getElementById('rotationControls').style.display = 'none';
    document.getElementById('ocrProgress').style.display = 'none';
    document.getElementById('extractedInfo').style.display = 'none';
    document.getElementById('debugInfo').style.display = 'none';
    document.getElementById('processBtn').style.display = 'none';
    document.getElementById('addExtractedBtn').style.display = 'none';
    
    document.getElementById('labelImageInput').value = '';
    
    currentImageCanvas = null;
    currentRotation = 0;
    baseImageSrc = null;
    extractedData = { name: '', mrn: '' };
    lastOCRText = '';
}

function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
        alert('Please select an image file.');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        displayUploadedImage(e.target.result);
    };
    reader.onerror = function() {
        alert('Error reading file. Please try again.');
    };
    reader.readAsDataURL(file);
}

function displayUploadedImage(imageSrc) {
    const previewImg = document.getElementById('previewImage');
    
    previewImg.onload = function() {
        console.log('Image loaded successfully:', previewImg.naturalWidth + 'x' + previewImg.naturalHeight);
        
        baseImageSrc = imageSrc;
        currentRotation = 0;
        
        createCanvasFromImage(previewImg);
        
        document.getElementById('capturedImage').style.display = 'block';
        document.getElementById('rotationControls').style.display = 'block';
        document.getElementById('processBtn').style.display = 'inline-block';
        
        console.log('UI elements shown, ready to process');
    };
    
    previewImg.onerror = function() {
        console.error('Failed to load image');
        alert('Failed to load the image. Please try a different image.');
    };
    
    previewImg.src = imageSrc;
}

function createCanvasFromImage(imgElement) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = imgElement.naturalWidth;
    canvas.height = imgElement.naturalHeight;
    
    ctx.drawImage(imgElement, 0, 0);
    currentImageCanvas = canvas;
    
    console.log('Canvas created:', canvas.width + 'x' + canvas.height);
}

function rotateImage(degrees) {
    if (!currentImageCanvas) {
        console.error('No canvas available for rotation');
        return;
    }
    
    currentRotation = (currentRotation + degrees) % 360;
    if (currentRotation < 0) currentRotation += 360;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const rad = (currentRotation * Math.PI) / 180;
    const sin = Math.abs(Math.sin(rad));
    const cos = Math.abs(Math.cos(rad));
    
    const origWidth = currentImageCanvas.width;
    const origHeight = currentImageCanvas.height;
    
    canvas.width = Math.floor(origWidth * cos + origHeight * sin);
    canvas.height = Math.floor(origWidth * sin + origHeight * cos);
    
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(rad);
    ctx.drawImage(currentImageCanvas, -origWidth / 2, -origHeight / 2);
    
    const rotatedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
    document.getElementById('previewImage').src = rotatedDataUrl;
    
    const img = new Image();
    img.onload = function() {
        createCanvasFromImage(img);
        baseImageSrc = rotatedDataUrl;
    };
    img.src = rotatedDataUrl;
    
    console.log('Image rotated by', degrees, 'degrees. Total rotation:', currentRotation);
}




		async function processCurrentImage() {
    console.log('=== Starting image processing ===');
    
    if (!currentImageCanvas) {
        alert('No image available to process. Please upload an image first.');
        return;
    }
    
    if (!isTesseractAvailable()) {
        alert('OCR system is not loaded. Please refresh the page and try again.');
        return;
    }
    
    const progressDiv = document.getElementById('ocrProgress');
    const progressBar = document.getElementById('ocrProgressBar');
    const progressPercent = document.getElementById('ocrProgressPercent');
    
    progressDiv.style.display = 'block';
    progressPercent.textContent = 'Processing image...';
    progressBar.style.width = '20%';
    
    try {
        const imageData = currentImageCanvas.toDataURL('image/png', 1.0);
        console.log('Starting OCR with image data size:', imageData.length);
        
        progressBar.style.width = '60%';
        progressPercent.textContent = 'Reading text...';
        
        // Use direct recognition without worker management
        const result = await Tesseract.recognize(imageData, 'eng', {
            logger: m => {
                if (m.status === 'recognizing text') {
                    const progress = Math.round(60 + (m.progress * 30));
                    progressBar.style.width = progress + '%';
                    progressPercent.textContent = `Reading text... ${Math.round(m.progress * 100)}%`;
                }
            }
        });
        
        progressBar.style.width = '100%';
        progressPercent.textContent = 'Complete!';
        
        const text = result.data.text;
        const confidence = result.data.confidence;
        
        console.log('OCR completed. Confidence:', confidence);
        console.log('Extracted text:', text);
        
        lastOCRText = text || '';
        updateDebugInfo();
        
        if (!text || text.trim().length < 3) {
            throw new Error('No text could be extracted from the image. Try:\n‚Ä¢ Rotating the image\n‚Ä¢ Taking a clearer photo\n‚Ä¢ Ensuring good lighting');
        }
        
        setTimeout(() => {
            progressDiv.style.display = 'none';
        }, 1500);
        
        extractPatientInfo(text);
        
    } catch (error) {
        console.error('OCR Error:', error);
        progressDiv.style.display = 'none';
        alert('Error processing image: ' + error.message);
    }
}




		








		function extractPatientInfo(text) {
    console.log('=== Extracting patient info ===');
    console.log('Input text:', text);
    
    extractedData = { name: '', mrn: '' };
    
    if (!text || text.trim().length === 0) {
        console.log('No text to process');
        displayExtractedInfo();
        return;
    }
    
    const cleanText = text.replace(/[^\w\s\n,.-]/g, ' ').replace(/\s+/g, ' ');
    const lines = cleanText.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 1);
    
    console.log('Processed lines:', lines);
    
    const fullText = cleanText.replace(/\n/g, ' ');
    
    // Extract MRN - keeping existing logic since it works
    const mrnPatterns = [
        /(?:MRN|Medical\s*Record|Record\s*#?|Patient\s*ID)[:\s#]*([0-9]{5,12})/i,
        /(?:ID|#)\s*([0-9]{6,10})/i,
        /\b([0-9]{7,10})\b/g
    ];
    
    for (const pattern of mrnPatterns) {
        if (pattern.global) {
            const matches = [...fullText.matchAll(pattern)];
            for (const match of matches) {
                const potentialMRN = match[1] || match[0];
                if (potentialMRN && potentialMRN.length >= 6 && potentialMRN.length <= 12) {
                    extractedData.mrn = potentialMRN.replace(/\D/g, '');
                    console.log('Found MRN:', extractedData.mrn);
                    break;
                }
            }
        } else {
            const match = fullText.match(pattern);
            if (match) {
                extractedData.mrn = match[1].replace(/\D/g, '');
                console.log('Found MRN:', extractedData.mrn);
                break;
            }
        }
        if (extractedData.mrn) break;
    }
    
    // ALL CAPS name extraction for medical labels
    console.log('Starting ALL CAPS name extraction...');
    
   // Strategy 1: Look for comma-separated ALL CAPS names (LAST, FIRST) - KEEP SAME FORMAT
const allCapsCommaPattern = /\b([A-Z]{2,20})\s*,\s*([A-Z]{2,20})\b/;
const commaMatch = fullText.match(allCapsCommaPattern);
if (commaMatch) {
    const fullMatch = commaMatch[0].trim(); // Get the entire match as-is
    
    // Skip if it contains numbers
    if (!/\d/.test(fullMatch)) {
        extractedData.name = fullMatch; // Keep original format: "SAWYER, JAMES"
        console.log('Found ALL CAPS comma-separated name:', extractedData.name);
    }
}

			
    
    // Strategy 2: Look for ALL CAPS name patterns (2-3 words)
    if (!extractedData.name) {
        const allCapsNamePattern = /\b([A-Z]{2,20}(?:\s+[A-Z]{2,20}){1,2})\b/g;
        const nameMatches = [...fullText.matchAll(allCapsNamePattern)];
        
        for (const match of nameMatches) {
            const candidate = match[1].trim();
            
            // Skip if contains numbers or MRN
            if (/\d/.test(candidate)) continue;
            if (extractedData.mrn && candidate.includes(extractedData.mrn)) continue;
            
            // Skip only specific label prefixes
            if (/^(DOB|ATT|AKA|FIN|MRN)/.test(candidate)) {
                console.log('Skipping label field:', candidate);
                continue;
            }
            
            // Check if it looks like a name (2-3 words, reasonable length)
            const words = candidate.split(/\s+/);
            if (words.length >= 2 && words.length <= 3 && candidate.length >= 6 && candidate.length <= 40) {
                extractedData.name = candidate;
                console.log('Found ALL CAPS name:', extractedData.name);
                break;
            }
        }
    }
    
    // Strategy 3: Line-by-line search for ALL CAPS names
    if (!extractedData.name) {
        for (let i = 0; i < Math.min(lines.length, 8); i++) {
            const line = lines[i].trim();
            
            // Skip obvious non-name lines
            if (line.length < 6 || line.length > 50) continue;
            if (/^\d/.test(line)) continue;
            if (extractedData.mrn && line.includes(extractedData.mrn)) continue;
            
            // Skip lines that start with label prefixes
            if (/^(DOB:|ATT:|AKA:|FIN:|MRN:)/i.test(line)) continue;
            
            // Check if line is predominantly ALL CAPS letters
            const allCapsLetters = (line.match(/[A-Z]/g) || []).length;
            const totalLetters = (line.match(/[A-Za-z]/g) || []).length;
            const isAllCaps = totalLetters > 0 && (allCapsLetters / totalLetters) > 0.8;
            
            if (isAllCaps && !/\d/.test(line)) {
                const words = line.split(/\s+/).filter(word => word.length > 1);
                
                if (words.length >= 2 && words.length <= 4) {
                    // Clean but keep original case
                    const cleanName = line.replace(/[^\w\s,.-]/g, '').trim();
                    if (cleanName.length >= 6) {
                        extractedData.name = cleanName;
                        console.log('Found ALL CAPS name via line analysis:', extractedData.name);
                        break;
                    }
                }
            }
        }
    }
    
    // Strategy 4: Broader ALL CAPS search as final fallback
    if (!extractedData.name) {
        const broadAllCapsPattern = /\b([A-Z]{3,15})\s+([A-Z]{3,15})\b/g;
        const broadMatches = [...fullText.matchAll(broadAllCapsPattern)];
        
        for (const match of broadMatches) {
            const word1 = match[1];
            const word2 = match[2];
            const candidate = `${word1} ${word2}`;
            
            // Skip if contains numbers or MRN
            if (/\d/.test(candidate)) continue;
            if (extractedData.mrn && candidate.includes(extractedData.mrn)) continue;
            if (candidate.length < 6 || candidate.length > 30) continue;
            
            // Skip only specific label prefixes
            if (/^(DOB|ATT|AKA|FIN|MRN)/.test(candidate)) continue;
            
            extractedData.name = candidate;
            console.log('Found ALL CAPS name via broad search:', extractedData.name);
            break;
        }
    }
    
    console.log('Final extracted data:', extractedData);
    displayExtractedInfo();
}










		










		

function displayExtractedInfo() {
    const extractedDiv = document.getElementById('extractedInfo');
    const nameSpan = document.getElementById('extractedName');
    const mrnSpan = document.getElementById('extractedMRN');
    const addBtn = document.getElementById('addExtractedBtn');
    
    nameSpan.textContent = extractedData.name || 'Not found';
    mrnSpan.textContent = extractedData.mrn || 'Not found';
    
    if (extractedData.name) {
        nameSpan.style.color = '#10b981';
        nameSpan.style.fontWeight = 'bold';
        nameSpan.style.fontStyle = 'normal';
    } else {
        nameSpan.style.color = '#ef4444';
        nameSpan.style.fontStyle = 'italic';
        nameSpan.style.fontWeight = 'normal';
    }
    
    if (extractedData.mrn) {
        mrnSpan.style.color = '#10b981';
        mrnSpan.style.fontWeight = 'bold';
        mrnSpan.style.fontStyle = 'normal';
    } else {
        mrnSpan.style.color = '#ef4444';
        mrnSpan.style.fontStyle = 'italic';
        mrnSpan.style.fontWeight = 'normal';
    }
    
    extractedDiv.style.display = 'block';
    addBtn.style.display = 'inline-block';
    
    console.log('Extraction results displayed');
}

function addExtractedPatient() {
    console.log('Adding extracted patient to list');
    
    const newPatient = {};
    MASTER_HEADERS.forEach(header => {
        newPatient[header] = '';
    });
    
    newPatient.Type = 'Patient';
    newPatient.Name = extractedData.name || 'Unknown Patient - Please Edit';
    newPatient.MRN = extractedData.mrn || '';
    newPatient.RM = 'TBD';
    
    patientData.push(newPatient);
    displayRows();
    saveToLocalStorage();
    updateCensus();
    
    closeAddEntryModal();
    
    const successParts = [];
    if (extractedData.name) successParts.push(`Name: ${extractedData.name}`);
    if (extractedData.mrn) successParts.push(`MRN: ${extractedData.mrn}`);
    
    if (successParts.length > 0) {
        alert(`Patient added successfully!\n\n${successParts.join('\n')}\n\nYou can edit any details by clicking on the patient in the list.`);
    } else {
        alert('Patient added with placeholder information.\n\nPlease click on the patient to edit the name and MRN.');
        setTimeout(() => {
            showDetails(patientData.length - 1);
        }, 100);
    }
}

function toggleDebugInfo() {
    const debugDiv = document.getElementById('debugInfo');
    if (debugDiv.style.display === 'none') {
        updateDebugInfo();
        debugDiv.style.display = 'block';
    } else {
        debugDiv.style.display = 'none';
    }
}

function updateDebugInfo() {
    const debugText = document.getElementById('debugText');
    if (debugText) {
        debugText.textContent = lastOCRText || 'No OCR text available yet';
    }
}

async function testOCRSystem() {
    console.log('=== Testing OCR System ===');
    
    const button = event.target;
    const originalText = button.textContent;
    const originalStyle = button.style.background;
    
    button.textContent = 'Testing...';
    button.disabled = true;
    button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
    
    try {
        if (!isTesseractAvailable()) {
            throw new Error('Tesseract.js is not loaded. Check the script tag.');
        }
        
        console.log('Testing OCR functionality...');
        const success = await testOCRAvailability();
        
        if (success) {
            console.log('OCR system test: SUCCESS');
            button.textContent = 'OCR Working!';
            button.style.background = 'linear-gradient(135deg, var(--success), #059669)';
            alert('OCR system is working correctly!\n\nYou can now upload and process images.');
        } else {
            throw new Error('OCR test failed - could not recognize test text');
        }
        
    } catch (error) {
        console.error('OCR test error:', error);
        button.textContent = 'OCR Failed';
        button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
        alert('OCR test failed: ' + error.message);
    }
    
    setTimeout(() => {
        button.textContent = originalText;
        button.style.background = originalStyle;
        button.disabled = false;
    }, 3000);
}
		






























	
		function showTableView() {
    if (!labData || Object.keys(labData).length === 0) {
        alert('No lab data available. Please import data first using the Import button.');
        return;
    }
    
    document.getElementById('tableModal').style.display = 'block';
    generateTableView();
}

		


		
		
		
		
		
		
		
		
		
		
		

function refreshViolinDisplay() {
    const violinInput = document.getElementById('field_VIOLIN');
    if (!violinInput) return;
    
    const patient = patientData[currentPatientIndex];
    
    if (patient && patient.VIOLIN && patient.VIOLIN.trim()) {
        violinInput.value = patient.VIOLIN;
        autoResizeTextarea(violinInput);
    }
}











		



		function closeGraphModal() {
    const modal = document.getElementById('graphModal');
    if (modal) {
        modal.style.display = 'none';
    }
}

function closeTableModal() {
    const modal = document.getElementById('tableModal');
    if (modal) {
        modal.style.display = 'none';
    }
}




		function ensureChartCheckSync() {
    if (currentViewMode === 'chartcheck' && currentPatientIndex !== -1) {
        const patient = patientData[currentPatientIndex];
        
        // Update all visible fields with current patient data
        const allFields = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'Priority'];
        
        allFields.forEach(field => {
            const element = document.getElementById(`field_${field.replace(/\s+/g, '_')}`);
            if (element && patient[field] !== undefined) {
                element.value = patient[field] || '';
                if (element.tagName === 'TEXTAREA') {
                    autoResizeTextarea(element);
                }
            }
        });
        
        // Refresh violin display if on violin tab
        if (window.chartCheckCurrentTab === 2) {
            setTimeout(refreshViolinDisplay, 100);
        }
    }
}

		
	

















function updateChartCheckProgress() {
    // Only these 4 fields need checkboxes for chart check
    const checkFields = ['Problems', 'ICS', 'VIOLIN', 'ORDERS'];
    const totalFields = checkFields.length;
    
    let checkedCount = 0;
    
    checkFields.forEach(field => {
        const fieldKey = `chartcheck_${field}_${currentPatientIndex}`;
        try {
            if (localStorage.getItem(fieldKey) === 'true') {
                checkedCount++;
            }
        } catch (e) {
            // Silently fail
        }
    });
    
    // Calculate percentage - divide by 4 to reach 100% with 4 fields
    const percentage = Math.round((checkedCount / totalFields) * 100);
    
    // Update the main container with gradient border color based on progress
    const mainContainer = document.getElementById('chartCheckMainContainer');
    if (mainContainer) {
        // Create gradient from current border color to green based on percentage
        let borderColor;
        
        if (percentage === 0) {
            borderColor = 'var(--border)';
        } else if (percentage < 100) {
            // Gradient from current color to green
            const hue = Math.round((percentage / 100) * 120); // 0 (red) to 120 (green)
            borderColor = `hsl(${hue}, 100%, 50%)`;
        } else {
            // Fully green when 100%
            borderColor = 'var(--success)';
        }
        
        mainContainer.style.borderColor = borderColor;
        
        // Update box shadow based on progress
        if (percentage === 100) {
            mainContainer.style.boxShadow = `0 0 20px rgba(16, 185, 129, 0.6)`;
            mainContainer.style.borderWidth = '4px';
        } else if (percentage > 0) {
            const alpha = 0.2 + (percentage / 100) * 0.4;
            mainContainer.style.boxShadow = `0 0 ${10 + (percentage / 100) * 10}px rgba(16, 185, 129, ${alpha})`;
            mainContainer.style.borderWidth = '3px';
        } else {
            mainContainer.style.boxShadow = 'none';
            mainContainer.style.borderWidth = '3px';
        }
        
        // Add percentage text at bottom center of container
        let percentageDisplay = mainContainer.querySelector('.chart-check-percentage');
        if (!percentageDisplay) {
            percentageDisplay = document.createElement('div');
            percentageDisplay.className = 'chart-check-percentage';
            percentageDisplay.style.cssText = `
                position: absolute;
                bottom: -25px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--card-bg);
                color: ${borderColor};
                padding: 0.5rem 1rem;
                border-radius: 0.5rem;
                font-weight: bold;
                font-size: 0.9rem;
                white-space: nowrap;
                border: 2px solid ${borderColor};
                transition: color 0.3s ease, border-color 0.3s ease;
            `;
            mainContainer.style.position = 'relative';
            mainContainer.appendChild(percentageDisplay);
        } else {
            percentageDisplay.style.color = borderColor;
            percentageDisplay.style.borderColor = borderColor;
        }
        
        percentageDisplay.textContent = `${percentage}% Complete`;
    }
}


let violinEditMode = false;

function toggleViolinMode() {
    violinEditMode = !violinEditMode;
    const violinTextarea = document.getElementById('field_VIOLIN');
    const violinDisplay = document.getElementById('violinDisplay');
    const btn = document.getElementById('violinToggleBtn');
    
    if (violinEditMode) {
        // Switch to edit mode
        if (violinDisplay) violinDisplay.style.display = 'none';
        if (violinTextarea) violinTextarea.style.display = 'block';
        btn.textContent = 'üìù Back to View';
    } else {
        // Switch to view mode
        if (violinDisplay) violinDisplay.style.display = 'block';
        if (violinTextarea) violinTextarea.style.display = 'none';
        btn.textContent = 'üêü Fishbone';
    }
}




















































































































































// ========= DATE + KEY HELPERS =========
function parseMDYWithOptionalTime(dstr) {
  if (!dstr || typeof dstr !== 'string') return null;
  const m = dstr.trim().match(
    /^(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2}|\d{4})(?:\s+(\d{2}):(\d{2})(?::(\d{2}))?)?$/
  );
  if (!m) return null;
  let [, mm, dd, yy, HH='00', MM='00', SS='00'] = m;
  mm = +mm; dd = +dd;
  let yyyy = (yy.length === 2) ? (+yy + (+yy >= 70 ? 1900 : 2000)) : +yy;
  const dt = new Date(yyyy, mm - 1, dd, +HH, +MM, +SS);
  return Number.isNaN(dt.getTime()) ? null : dt;
}

function mostRecentByKeys(keys, datesObj) {
  let best = null;
  for (const k of keys) {
    const raw = datesObj?.[k];
    const d = parseMDYWithOptionalTime(raw);
    if (d && (!best || d > best.dt)) best = { key: k, dt: d, raw };
  }
  return best;
}

function isSameCalendarDay(a, b) {
  return a && b &&
    a.getFullYear() === b.getFullYear() &&
    a.getMonth() === b.getMonth() &&
    a.getDate() === b.getDate();
}

const KEY_ALIASES = {
  ph:     ['ph','pH'],
  pco2:   ['pco2','pCO2','pc02','pC02'],
  po2:    ['po2','pO2','PO2'],
  bicarb: ['bicarb','Bicarb','bicarbonate','Bicarbonate'],
  wbc: ['wbc','WBC'],
  hgb: ['hgb','Hgb','HGB'],
  hct: ['hct','Hct','HCT'],
  plt: ['plt','Plt','PLT','Platelet Count','Platelets'],
  na:  ['na','Na','sodium','Sodium','Sodium (Resp)'],
  k:   ['k','K','potassium','Potassium','Potassium (Resp)'],
  cl:  ['cl','Cl','chloride','Chloride'],
  co2: ['co2','CO2'],
  bun: ['bun','BUN'],
  cr:  ['cr','Cr','creatinine','Creatinine'],
  glu: ['glu','Glu','glucose','Glucose','Glucose (Perf)'],
  ast: ['ast','AST'],
  alt: ['alt','ALT'],
  tbil:['tbil','Tbil','Total Bilirubin'],
  dbil:['dbil','Dbil','Direct Bilirubin'],
  alk: ['alk','Alk','Alkaline Phosphatase','Alk Phos'],
  ggt: ['ggt','GGT'],
  pt:  ['pt','PT','Prothrombin Time'],
  ptt: ['ptt','PTT','APTT'],
  inr: ['inr','INR'],
  fib: ['fib','FIB','Fibrinogen'],
};

function resolveKeys(preferredKeys, obj) {
  const out = [];
  for (const base of preferredKeys) {
    const aliases = KEY_ALIASES[base] || [base];
    const hit = aliases.find(a => Object.prototype.hasOwnProperty.call(obj || {}, a));
    out.push(hit || base);
  }
  return out;
}

// ========= MAIN UPDATE FUNCTION =========
function updateViolinDisplay(ctx = {}) {
  const _patientData = ctx.patientData || patientData;
  const _currentIdx = Number.isInteger(ctx.currentPatientIndex) ? ctx.currentPatientIndex : currentPatientIndex;
  const _labData = ctx.labData || labData;
  const _lastImportedData = ctx.lastImportedData || lastImportedData;

  if (!_patientData || _currentIdx < 0 || !_patientData[_currentIdx]) return;
  const patient = _patientData[_currentIdx];
  if (!patient || !patient.VIOLIN) return;

  // Extract I/O data
  const _ioData = _lastImportedData ? extractIntakeOutputData(_lastImportedData) : null;

  // Parse fishbone to extract vitals/I/O section
  const fishboneLines = String(patient.VIOLIN).split('\n');
  const output = [];
  
  // Collect warnings at the top
  const warningsToAdd = [];
  
  if (_labData?.labs) {
    const eWarns = electrolyteWarnings(_labData);
    warningsToAdd.push(...eWarns);
  }
  
  if (_ioData?.outputs) {
    const ioWarns = buildIOWarnings(_ioData, patient);
    warningsToAdd.push(...ioWarns);
  }
  
  const preDateWarnings = [];
  const _cbcWarn = getCBCDateWarning(_labData); if (_cbcWarn) preDateWarnings.push(_cbcWarn);
  const _bmpWarn = getBMPDateWarning(_labData); if (_bmpWarn) preDateWarnings.push(_bmpWarn);
  const _lftWarn = getLFTsDateWarning(_labData); if (_lftWarn) preDateWarnings.push(_lftWarn);
  const _coagWarn = getCoagsDateWarning(_labData); if (_coagWarn) preDateWarnings.push(_coagWarn);
  const _abgWarn = getABGDateWarning(_labData); if (_abgWarn) preDateWarnings.push(_abgWarn);
  warningsToAdd.push(...preDateWarnings);
  
  if (warningsToAdd.length) {
    output.push('=== ‚ö†Ô∏è WARNINGS ===');
    output.push('');
    warningsToAdd.forEach(w => output.push(w));
    output.push('');
  }

  // Extract vitals/I/O section (up to and including Fluid Balance line)
// SKIP the first line (vitals line) since we show it in the graph
let i = 1; // START AT 1 instead of 0 to skip vitals line
let foundFluidBalance = false;

while (i < fishboneLines.length && !foundFluidBalance) {
  const line = fishboneLines[i];
  output.push(line);
  
  if (line.trim().startsWith('Fluid Balance:')) {
    foundFluidBalance = true;
  }
  i++;
}


  // Create display container
  let violinDisplay = document.getElementById('violinDisplay');
  if (!violinDisplay) {
    violinDisplay = document.createElement('div');
    violinDisplay.id = 'violinDisplay';
    violinDisplay.style.cssText = `
      background: var(--dark-bg); color: var(--text-primary);
      border: 1px solid var(--border); padding: 0.75rem; border-radius: 0.25rem;
      font-family: monospace; font-size: 0.9rem; line-height: 1.6;
      white-space: pre-wrap; word-wrap: break-word; margin-top: 0.5rem; overflow-x: auto;
    `;
    const textarea = document.getElementById('field_VIOLIN');
    if (textarea?.parentNode) textarea.parentNode.insertBefore(violinDisplay, textarea.nextSibling);
    else document.body.appendChild(violinDisplay);
  }

  violinDisplay.innerHTML = '';

  // ADD VITALS VISUALIZATION FIRST (before fishbone text)
  if (_labData?.vitals && Object.keys(_labData.vitals).length > 0) {
    const vitalsViz = createVitalsVisualization(_labData.vitals);
    violinDisplay.appendChild(vitalsViz);
  }

  

// ADD I/O DASHBOARD (replaces fishbone text)
if (_ioData) {
  const ioDashboard = createIODashboard(_ioData, _labData);
  violinDisplay.appendChild(ioDashboard);
}



  // Generate and append lab values table
  if (_labData && Object.keys(_labData.labs || {}).length > 0) {
    const tableHTML = generateModernLabTable(_labData);
    const tableDiv = document.createElement('div');
    tableDiv.style.marginTop = '0.5rem'; // Small margin only
    tableDiv.innerHTML = tableHTML;
    violinDisplay.appendChild(tableDiv);
    
    // Ensure tooltips work
    const labTable = tableDiv.querySelector('.modern-lab-table');
    if (labTable) {
      labTable.style.pointerEvents = 'auto';
      labTable.querySelectorAll('td').forEach(td => {
        td.style.pointerEvents = 'auto';
      });
    }
  }

  violinDisplay.style.display = 'block';

  const violinTextarea = document.getElementById('field_VIOLIN');
  if (violinTextarea) violinTextarea.style.display = 'none';
  window.violinEditMode = false;
}





// Create interactive vitals visualization - WITH OXYGEN INFO
function createVitalsVisualization(vitalsData) {
  const container = document.createElement('div');
  container.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    background: rgba(30, 30, 30, 0.5);
    padding: 1rem;
    border-radius: 0.5rem;
    border: 1px solid var(--border);
    margin-bottom: 1rem;
    max-width: 900px;
  `;
  
  // OXYGEN THERAPY SECTION - ADD THIS AT THE TOP
  const o2Section = document.createElement('div');
  o2Section.style.cssText = `
    display: grid;
    grid-template-columns: auto 1fr;
    gap: 1rem;
    padding: 0.75rem;
    background: rgba(139, 92, 246, 0.1);
    border: 2px solid #8b5cf6;
    border-radius: 0.375rem;
  `;
  
  const o2Label = document.createElement('div');
  o2Label.style.cssText = `
    font-weight: bold;
    color: #8b5cf6;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
  `;
  o2Label.textContent = 'ü´Å O2 THERAPY:';
  
  const o2Info = document.createElement('div');
  o2Info.style.cssText = `
    font-family: monospace;
    font-size: 0.9rem;
    color: var(--text-primary);
  `;
  
  // Extract O2 therapy info from labData (which should have it from extractLabValues)
  if (labData?.o2therapyCode || labData?.o2therapyRaw) {
    const therapyCode = labData.o2therapyCode || 'Unknown';
    const flowRate = labData.o2flowRaw || '';
    const isAbnormal = therapyCode !== 'RA';
    
    let o2Text = '';
    if (therapyCode === 'RA') {
      o2Text = `<span style="color: #10b981;">Room Air</span>`;
    } else {
      o2Text = `<span style="color: #ff4444; font-weight: bold;">${therapyCode}</span>`;
      if (flowRate && therapyCode !== 'Vent') {
        o2Text += ` @ ${flowRate}`;
      }
    }
    
    // If on ventilator, show vent settings
    if (therapyCode === 'Vent' && (labData.ventModeRaw || labData.ventFrequencyRaw)) {
      const mode = labData.ventModeRaw ? labData.ventModeRaw.replace(/[\s\/\+]+/g, '') : '';
      const freq = labData.ventFrequencyRaw || '';
      const tv = labData.ventTidalRaw || '';
      const peep = labData.ventPeepRaw || '';
      const fio2 = labData.ventFiO2Raw || '';
      
      const settings = [
        freq ? `RR:${freq}` : '',
        tv ? `Vt:${tv}mL` : '',
        peep ? `PEEP:${peep}` : '',
        fio2 ? `FiO2:${fio2}%` : ''
      ].filter(x => x).join(' | ');
      
      o2Text += `<br><span style="color: #a78bfa; font-size: 0.85rem;">Mode: ${mode}</span>`;
      if (settings) {
        o2Text += `<br><span style="color: #a78bfa; font-size: 0.85rem;">${settings}</span>`;
      }
    }
    
    o2Info.innerHTML = o2Text;
  } else {
    o2Info.innerHTML = '<span style="color: var(--text-secondary); font-style: italic;">No O2 therapy data</span>';
  }
  
  o2Section.appendChild(o2Label);
  o2Section.appendChild(o2Info);
  container.appendChild(o2Section);
  
  // VITALS GRAPH SECTION
  const graphSection = document.createElement('div');
  graphSection.style.cssText = `
    display: grid;
    grid-template-columns: 180px 1fr;
    gap: 1rem;
  `;
  
  const vitalsList = document.createElement('div');
  vitalsList.style.cssText = `
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  `;
  
  const graphContainer = document.createElement('div');
  graphContainer.style.cssText = `
    position: relative;
    height: 300px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 0.25rem;
    border: 1px solid rgba(255, 255, 255, 0.1);
  `;
  
  const canvas = document.createElement('canvas');
  canvas.width = 700;
  canvas.height = 300;
  canvas.style.cssText = 'width: 100%; height: 100%;';
  graphContainer.appendChild(canvas);
  
  const vitals = [
    { key: 'temp', label: 'T', unit: '¬∞C', color: '#ef4444', min: 35, max: 38 },
    { key: 'hr', label: 'HR', unit: 'bpm', color: '#f59e0b', min: 60, max: 100 },
    { key: 'sbp', label: 'SBP', unit: 'mmHg', color: '#10b981', min: 90, max: 180 },
    { key: 'dbp', label: 'DBP', unit: 'mmHg', color: '#3b82f6', min: 60, max: 120 },
    { key: 'o2', label: 'O2', unit: '%', color: '#8b5cf6', min: 94, max: 100 }
  ];
  
  let selectedVital = 'temp';
  const buttons = [];
  
  vitals.forEach(vital => {
    const data = vitalsData[vital.key];
    if (!data || data.length === 0) return;
    
    const minVal = Math.min(...data);
    const maxVal = Math.max(...data);
    const avgVal = data.reduce((a, b) => a + b, 0) / data.length;
    
    // Check if any values are abnormal
    const hasAbnormal = data.some(v => v < vital.min || v > vital.max);
    
    // Format with asterisks if abnormal
    const formatValue = (val) => {
      const formatted = val.toFixed(1);
      return (val < vital.min || val > vital.max) ? `*${formatted}*` : formatted;
    };
    
    const minStr = formatValue(minVal);
    const maxStr = formatValue(maxVal);
    const avgStr = formatValue(avgVal);
    
    const button = document.createElement('button');
    button.setAttribute('data-vital', vital.key);
    button.style.cssText = `
      padding: 0.5rem 0.65rem;
      background: ${selectedVital === vital.key ? vital.color : 'rgba(60, 60, 60, 0.5)'};
      border: 1px solid ${vital.color}50;
      border-radius: 0.25rem;
      color: ${selectedVital === vital.key ? 'white' : 'var(--text-primary)'};
      cursor: pointer;
      text-align: left;
      font-size: 0.85rem;
      font-family: monospace;
      transition: all 0.2s ease;
      line-height: 1.4;
      white-space: nowrap;
    `;
    
    button.innerHTML = `<strong style="color: ${vital.color}; font-size: 0.9rem;">${vital.label}</strong> ${minStr}-${maxStr} ${vital.unit}<br><span style="font-size: 0.75rem; opacity: 0.8;">avg: ${avgStr} ${vital.unit}</span>`;
    
    button.onmouseenter = () => {
      if (button.getAttribute('data-vital') !== selectedVital) {
        button.style.background = 'rgba(80, 80, 80, 0.6)';
      }
    };
    
    button.onmouseleave = () => {
      if (button.getAttribute('data-vital') !== selectedVital) {
        button.style.background = 'rgba(60, 60, 60, 0.5)';
      }
    };
    
    button.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      
      try {
        selectedVital = vital.key;
        
        // Update all button styles
        buttons.forEach(btn => {
          const btnVital = vitals.find(v => v.key === btn.getAttribute('data-vital'));
          if (btnVital) {
            btn.style.background = 'rgba(60, 60, 60, 0.5)';
            btn.style.color = 'var(--text-primary)';
          }
        });
        
        // Highlight selected button
        button.style.background = vital.color;
        button.style.color = 'white';
        
        // Draw graph
        drawVitalGraph(canvas, vitalsData[vital.key], vital);
      } catch (err) {
        console.error('Error updating vital graph:', err);
      }
    };
    
    buttons.push(button);
    vitalsList.appendChild(button);
  });
  
  graphSection.appendChild(vitalsList);
  graphSection.appendChild(graphContainer);
  container.appendChild(graphSection);
  
  // Draw initial graph (temperature)
  const tempVital = vitals.find(v => v.key === 'temp');
  if (vitalsData.temp && vitalsData.temp.length > 0 && tempVital) {
    try {
      drawVitalGraph(canvas, vitalsData.temp, tempVital);
    } catch (err) {
      console.error('Error drawing initial graph:', err);
    }
  }
  
  return container;
}




function drawVitalGraph(canvas, data, vital) {
  const ctx = canvas.getContext('2d');
  const width = canvas.width;
  const height = canvas.height;
  
  ctx.clearRect(0, 0, width, height);
  
  if (!data || data.length === 0) {
    ctx.fillStyle = '#666';
    ctx.font = '14px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('No data', width/2, height/2);
    return;
  }
  
  const min = Math.min(...data, vital.min);
  const max = Math.max(...data, vital.max);
  const range = max - min || 1;
  const padding = 35;
  
  const xStep = (width - padding * 2) / (data.length - 1 || 1);
  const yScale = (height - padding * 2) / range;
  
  // Draw grid
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
  ctx.lineWidth = 0.5;
  for (let i = 0; i <= 4; i++) {
    const y = padding + (height - padding * 2) * i / 4;
    ctx.beginPath();
    ctx.moveTo(padding, y);
    ctx.lineTo(width - padding, y);
    ctx.stroke();
  }
  
  // Draw normal range zone
  if (vital.min && vital.max) {
    const normalMinY = height - padding - (vital.min - min) * yScale;
    const normalMaxY = height - padding - (vital.max - min) * yScale;
    ctx.fillStyle = 'rgba(16, 185, 129, 0.12)';
    ctx.fillRect(padding, normalMaxY, width - padding * 2, normalMinY - normalMaxY);
    
    // Draw normal range lines
    ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]);
    ctx.beginPath();
    ctx.moveTo(padding, normalMinY);
    ctx.lineTo(width - padding, normalMinY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(padding, normalMaxY);
    ctx.lineTo(width - padding, normalMaxY);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  
  // Draw line with gradient
  ctx.strokeStyle = vital.color;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  
  data.forEach((value, i) => {
    const x = padding + i * xStep;
    const y = height - padding - (value - min) * yScale;
    
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  });
  
  ctx.stroke();
  
  // Fill area under curve
  if (data.length > 1) {
    ctx.lineTo(padding + (data.length - 1) * xStep, height - padding);
    ctx.lineTo(padding, height - padding);
    ctx.closePath();
    ctx.fillStyle = vital.color + '25';
    ctx.fill();
  }
  
  // Draw points
  data.forEach((value, i) => {
    const x = padding + i * xStep;
    const y = height - padding - (value - min) * yScale;
    
    // Check if abnormal
    const isAbnormal = value < vital.min || value > vital.max;
    
    // Draw point
    ctx.fillStyle = isAbnormal ? '#ff4444' : vital.color;
    ctx.beginPath();
    ctx.arc(x, y, isAbnormal ? 4 : 3, 0, Math.PI * 2);
    ctx.fill();
    
    // Add white border for abnormal values
    if (isAbnormal) {
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.stroke();
    }
  });
  
  // Draw Y-axis labels
  ctx.fillStyle = '#aaa';
  ctx.font = 'bold 11px monospace';
  ctx.textAlign = 'right';
  ctx.fillText(max.toFixed(1), padding - 5, padding + 4);
  ctx.fillText(min.toFixed(1), padding - 5, height - padding + 4);
  ctx.fillText(((max + min) / 2).toFixed(1), padding - 5, height / 2 + 4);
  
  // Draw title with count
  ctx.fillStyle = vital.color;
  ctx.font = 'bold 13px monospace';
  ctx.textAlign = 'left';
  const abnormalCount = data.filter(v => v < vital.min || v > vital.max).length;
  const titleText = abnormalCount > 0 
    ? `${vital.label} - ${data.length} readings (*${abnormalCount} abnormal*)`
    : `${vital.label} - ${data.length} readings`;
  ctx.fillText(titleText, padding, 15);
}




// ========= HELPER FUNCTIONS FOR LAB TABLE =========

function formatDateTime(date, time) {
  if (!date) return 'No date available';
  
  // Format the date and time nicely
  let timeStr = '';
  if (time) {
    // Extract just HH:MM from time string (remove seconds if present)
    const timeMatch = time.match(/(\d{2}:\d{2})/);
    timeStr = timeMatch ? ` at ${timeMatch[1]}` : '';
  }
  
  return `${date}${timeStr}`;
}

function getCellClass(value, min, max) {
  if (value === '--' || value === undefined || value === null) {
    return 'lab-value';
  }
  
  const numValue = parseFloat(value);
  if (isNaN(numValue)) {
    return 'lab-value';
  }
  
  // Check if value is outside normal range
  if (numValue < min || numValue > max) {
    return 'lab-value abnormal';
  }
  
  return 'lab-value normal';
}



// ========= MODERN LAB TABLE GENERATOR =========

function generateModernLabTable(data) {
  console.log('üîç Generating lab table, data:', data); // Debug
  
  const num = (v) => (v === null || v === undefined || v === '' ? undefined : Number(v));
  const fmt = (v) => v !== undefined ? v.toFixed(1) : '--';
  
  // Determine max columns available across all labs (up to 5)
  let maxColumns = 1;
  Object.values(data.labs || {}).forEach(arr => {
    if (Array.isArray(arr)) {
      maxColumns = Math.max(maxColumns, Math.min(arr.length, 5));
    }
  });

  // Helper to get up to 5 values from array WITH DATES
  const getValuesWithDates = (arr, labKey) => {
    const results = [];
    
    if (!Array.isArray(arr)) {
      for (let i = 0; i < maxColumns; i++) {
        results.push({ value: '--', date: null, time: null });
      }
      return results;
    }

    let dates = [];
    let times = [];
    
    const keysToTry = [labKey];
    if (KEY_ALIASES[labKey]) {
      keysToTry.push(...KEY_ALIASES[labKey]);
    }
    
    // Find dates
    for (const key of keysToTry) {
      if (data.datesArray?.[key]) {
        dates = data.datesArray[key];
        break;
      }
    }
    if (dates.length === 0) {
      for (const key of keysToTry) {
        if (data.dates?.[key]) {
          dates = [data.dates[key]];
          break;
        }
      }
    }
    
    // Find times
    for (const key of keysToTry) {
      if (data.timesArray?.[key]) {
        times = data.timesArray[key];
        break;
      }
    }
    if (times.length === 0) {
      for (const key of keysToTry) {
        if (data.times?.[key]) {
          times = [data.times[key]];
          break;
        }
      }
    }
    
    console.log(`üìä ${labKey}: dates=${JSON.stringify(dates)}, times=${JSON.stringify(times)}`); // Debug
    
    for (let i = 0; i < maxColumns; i++) {
      if (i < arr.length) {
        results.push({
          value: fmt(num(arr[i])),
          date: dates[i] || dates[0] || null,
          time: times[i] || times[0] || null
        });
      } else {
        results.push({ value: '--', date: null, time: null });
      }
    }
    
    return results;
  };

  const columnHeaders = ['Latest'];
  for (let i = 1; i < maxColumns; i++) {
    columnHeaders.push(`-${i}`);
  }

  let html = `
    <style>
.modern-lab-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.85rem;
    background: #000000;
    border-radius: 0.5rem;
    overflow: hidden;
    border: 1px solid #2a2a2a;
    pointer-events: auto; /* ADD THIS */
    position: relative; /* ADD THIS */
}
      .modern-lab-table thead {
        background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
      }
      .modern-lab-table th {
        padding: 0.4rem 0.3rem;
        text-align: center;
        font-weight: 700;
        color: #b0b0b0;
        border-bottom: 2px solid #404040;
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      .modern-lab-table th:first-child {
        text-align: left;
        width: 60px;
        padding-left: 0.5rem;
      }
.modern-lab-table td {
    padding: 0.35rem 0.3rem;
    border-bottom: 1px solid #1a1a1a;
    background: #000000;
    text-align: center;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: help;
    position: relative;
    pointer-events: auto; /* ADD THIS */
    z-index: 1; /* ADD THIS */
}
      .modern-lab-table td:first-child {
        width: 60px;
        padding-left: 0.5rem;
        text-align: left;
        font-weight: bold;
      }
      .modern-lab-table tbody tr {
        background: #000000;
      }
      .modern-lab-table tbody tr:hover {
        background: rgba(59, 130, 246, 0.08);
      }

      .modern-lab-table td.abnormal {
        background: rgba(239, 68, 68, 0.2);
        color: #ff6b6b;
        font-weight: 700;
      }
      
      .modern-lab-table td.normal {
        color: #6ee7b7;
      }
    </style>
    
    <table class="modern-lab-table">
      <thead>
        <tr>
          <th style="text-align: left;">Lab</th>
          ${columnHeaders.map(h => `<th>${h}</th>`).join('')}
        </tr>
      </thead>
      <tbody>
  `;

  


// Helper function to generate row HTML
const generateLabRow = (lab) => {
  if (!data.labs[lab.key]) return '';
  
  const values = getValuesWithDates(data.labs[lab.key], lab.key);
  
  console.log(`üéØ Generating row for ${lab.label}, got values:`, values);
  
  const cells = values.map((v, idx) => {
    const numValue = parseFloat(v.value);
    const abnormal = !isNaN(numValue) && (numValue < lab.min || numValue > lab.max);
    const normalClass = !abnormal && v.value !== '--' ? 'normal' : '';
    
    // DEBUG: Log what we're working with for this cell
    console.log(`  Cell ${idx} for ${lab.label}:`, {
      value: v.value,
      date: v.date,
      time: v.time,
      dateType: typeof v.date,
      timeType: typeof v.time
    });
    
    // Create tooltip text
    let tooltipText = 'No date available';
    
    if (v.date) {
      tooltipText = v.date;
      if (v.time) {
        const timeMatch = v.time.match(/(\d{2}:\d{2})/);
        if (timeMatch) {
          tooltipText += ` at ${timeMatch[1]}`;
        }
      }
    }
    
    console.log(`    ‚Üí Tooltip: "${tooltipText}"`);
    
    // Escape quotes
    const escapedTooltip = String(tooltipText).replace(/"/g, '&quot;');
    
    return `<td class="${abnormal ? 'abnormal' : normalClass}" title="${escapedTooltip}">${v.value}</td>`;
  }).join('');
  
  return `
    <tr>
      <td><strong>${lab.label}</strong></td>
      ${cells}
    </tr>
  `;
};




  // All lab definitions
  const cbcLabs = [
    { label: 'WBC', key: 'wbc', min: 4.5, max: 11 },
    { label: 'Hgb', key: 'hgb', min: 8, max: 11 },
    { label: 'Hct', key: 'hct', min: 24, max: 36 },
    { label: 'Plt', key: 'plt', min: 150, max: 400 }
  ];

  const bmpLabs = [
    { label: 'Na', key: 'na', min: 135, max: 145 },
    { label: 'K', key: 'k', min: 4.0, max: 5.0 },
    { label: 'Cl', key: 'cl', min: 96, max: 106 },
    { label: 'CO2', key: 'co2', min: 23, max: 29 },
    { label: 'BUN', key: 'bun', min: 7, max: 20 },
    { label: 'Cr', key: 'cr', min: 0.7, max: 1.3 },
    { label: 'Glu', key: 'glu', min: 70, max: 100 }
  ];

  const electrolyteLabs = [
    { label: 'Ca', key: 'ca', min: 8.5, max: 10.2 },
    { label: 'Mg', key: 'mg', min: 1.7, max: 2.2 },
    { label: 'Phos', key: 'phos', min: 2.5, max: 4.5 }
  ];

  const lftLabs = [
    { label: 'AST', key: 'ast', min: 10, max: 40 },
    { label: 'ALT', key: 'alt', min: 10, max: 40 },
    { label: 'TBil', key: 'tbil', min: 0.1, max: 1.2 },
    { label: 'DBil', key: 'dbil', min: 0, max: 0.3 },
    { label: 'Alk', key: 'alk', min: 30, max: 120 },
    { label: 'GGT', key: 'ggt', min: 9, max: 48 }
  ];

  const coagLabs = [
    { label: 'PT', key: 'pt', min: 11, max: 13.5 },
    { label: 'PTT', key: 'ptt', min: 25, max: 35 },
    { label: 'INR', key: 'inr', min: 0.8, max: 1.1 },
    { label: 'Fib', key: 'fib', min: 200, max: 400 }
  ];

  const abgLabs = [
    { label: 'pH', key: 'ph', min: 7.35, max: 7.45 },
    { label: 'pCO2', key: 'pco2', min: 35, max: 45 },
    { label: 'pO2', key: 'po2', min: 80, max: 100 },
    { label: 'HCO3', key: 'bicarb', min: 22, max: 28 },
    { label: 'Lactate', key: 'lactate', min: 0.5, max: 2.0 }
  ];

  const miscLabs = [
    { label: 'Trop', key: 'trop', min: 0, max: 0.04 },
    { label: 'Amylase', key: 'amylase', min: 30, max: 110 },
    { label: 'Lipase', key: 'lipase', min: 30, max: 140 },
    { label: 'Albumin', key: 'albumin', min: 3.5, max: 5.5 },
    { label: 'Prealbumin', key: 'prealbumin', min: 15, max: 36 }
  ];

  // Generate all rows
  cbcLabs.forEach(lab => { html += generateLabRow(lab); });
  bmpLabs.forEach(lab => { html += generateLabRow(lab); });
  electrolyteLabs.forEach(lab => { html += generateLabRow(lab); });
  lftLabs.forEach(lab => { html += generateLabRow(lab); });
  coagLabs.forEach(lab => { html += generateLabRow(lab); });
  abgLabs.forEach(lab => { html += generateLabRow(lab); });
  miscLabs.forEach(lab => { html += generateLabRow(lab); });

  html += `
      </tbody>
    </table>
  `;

  return html;
}


// ========= WARNING FUNCTIONS =========
function getCBCDateWarning(labData) {
  if (!labData?.dates) return null;
  const keys = resolveKeys(['wbc','hgb','hct','plt'], labData.dates);
  const latest = mostRecentByKeys(keys, labData.dates);
  if (!latest) return null;
  const today = new Date();
  if (!isSameCalendarDay(latest.dt, today)) {
    const t = labData.times?.[latest.key] || '';
    return `Last CBC from ${latest.raw}${t ? ' ' + t : ''}!!`;
  }
  return null;
}

function getBMPDateWarning(labData) {
  if (!labData?.dates) return null;
  const keys = resolveKeys(['na','k','cl','co2','bun','cr','glu'], labData.dates);
  const latest = mostRecentByKeys(keys, labData.dates);
  if (!latest) return null;
  const today = new Date();
  if (!isSameCalendarDay(latest.dt, today)) {
    const t = labData.times?.[latest.key] || '';
    return `Last BMP from ${latest.raw}${t ? ' ' + t : ''}!!`;
  }
  return null;
}

function getLFTsDateWarning(labData) {
  if (!labData?.dates) return null;
  const keys = resolveKeys(['ast','alt','tbil','dbil','alk','ggt'], labData.dates);
  const latest = mostRecentByKeys(keys, labData.dates);
  if (!latest) return null;
  const today = new Date();
  if (!isSameCalendarDay(latest.dt, today)) {
    const t = labData.times?.[latest.key] || '';
    return `Last LFTs from ${latest.raw}${t ? ' ' + t : ''}!!`;
  }
  return null;
}

function getCoagsDateWarning(labData) {
  if (!labData?.dates) return null;
  const keys = resolveKeys(['pt','ptt','inr','fib'], labData.dates);
  const latest = mostRecentByKeys(keys, labData.dates);
  if (!latest) return null;
  const today = new Date();
  if (!isSameCalendarDay(latest.dt, today)) {
    const t = labData.times?.[latest.key] || '';
    return `Last Coags from ${latest.raw}${t ? ' ' + t : ''}!!`;
  }
  return null;
}

function getABGDateWarning(labData) {
  if (!labData?.dates) return null;
  const keys = resolveKeys(['ph','pco2','po2','bicarb'], labData.dates);
  const latest = mostRecentByKeys(keys, labData.dates);
  if (!latest) return null;
  const today = new Date();
  if (!isSameCalendarDay(latest.dt, today)) {
    const t = labData.times?.[latest.key] || '';
    return `Last ABG from ${latest.raw}${t ? ' ' + t : ''}!!`;
  }
  return null;
}

function electrolyteWarnings(data) {
  const out = [];
  if (!data?.labs) return out;
  
  const num = (v) => (v === null || v === undefined || v === '' ? undefined : Number(v));
  const first = (arr) => (Array.isArray(arr) ? arr[0] : undefined);
  const second = (arr) => (Array.isArray(arr) ? arr[1] : undefined);

  // Sodium
  if (data.labs.na && first(data.labs.na) !== undefined) {
    const na = num(first(data.labs.na)), naPrev = num(second(data.labs.na));
    const naStr = naPrev !== undefined ? `*${na}* (*${naPrev}*)` : `*${na}*`;
    if (na < 135) {
      out.push(`Hyponatremic! 1L FWR, Salt tabs 2g BID, Na: ${naStr}`);
    }
    else if (na > 145) {
      out.push(`Hypernatremic! Na: ${naStr} -> FWB/D5W/0.45 NS`);
    }
  }

  // Potassium
  if (data.labs.k && first(data.labs.k) !== undefined) {
    const k = num(first(data.labs.k)), kPrev = num(second(data.labs.k));
    const kStr = (k < 4.0 || k > 5.0) ? `*${k}*` : String(k);
    const kPrevStr = kPrev !== undefined ? `(${kPrev})` : '(--) ';
    if (k >= 3.3 && k <= 3.9) {
      out.push(`Give 40 meq K PO or IV, K=${kStr}${kPrevStr}`);
    }
    else if (k >= 3.0 && k <= 3.2) {
      out.push(`Give 60 meq K IV, K=${kStr}${kPrevStr}`);
    }
    else if (k > 0 && k <= 2.6) {
      out.push(`Give 100 meq K and NHO, K=${kStr}${kPrevStr}`);
    }
    else if (k > 5) {
      out.push(`Hyperkalemic!!, K=${kStr}${kPrevStr}`);
    }
  }

  // Calcium
  if (data.labs.ca && first(data.labs.ca) !== undefined) {
    const ca = num(first(data.labs.ca)), caPrev = num(second(data.labs.ca));
    const caStr = caPrev !== undefined ? `*${ca}* (*${caPrev}*)` : `*${ca}*`;
    if (ca >= 3.5 && ca < 4) {
      out.push(`Give 4g calcium gluconate, 2g/hr, iCa=${caStr}`);
    }
    else if (ca >= 3 && ca <= 3.4) {
      out.push(`Give 6g calcium gluconate 2g/hr, iCa=${caStr}`);
    }
    else if (ca >= 2.5 && ca <= 2.9) {
      out.push(`Give 8g calcium gluconate 2g/hr, iCa=${caStr}`);
    }
    else if (ca > 0 && ca < 2.5) {
      out.push(`Give 10g calcium gluconate 2g/hr, notify senior! iCa=${caStr}`);
    }
  }

  // Magnesium
  if (data.labs.mg && first(data.labs.mg) !== undefined) {
    const mg = num(first(data.labs.mg)), mgPrev = num(second(data.labs.mg));
    const mgStr = mgPrev !== undefined ? `*${mg}* (*${mgPrev}*)` : `*${mg}*`;
    if (mg >= 1.6 && mg <= 1.9) {
      out.push(`Give 4g mag sulfate IV/2hr@2g/hr, Mg: ${mgStr}`);
    }
    else if (mg >= 1 && mg <= 1.5) {
      out.push(`Give 6g mag sulfate IV/3hr@2g/hr, Mg: ${mgStr}`);
    }
    else if (mg > 0 && mg <= 1) {
      out.push(`Give 8g mag sulfate IV/4hr@2g/hr, Mg: ${mgStr}`);
    }
  }

  // Phosphorus
  if (data.labs.phos && first(data.labs.phos) !== undefined) {
    const p = num(first(data.labs.phos)), pPrev = num(second(data.labs.phos));
    const pStr = pPrev !== undefined ? `*${p}* (*${pPrev}*)` : `*${p}*`;
    if (p >= 2 && p < 2.5) {
      out.push(`Give 15 mmol phos (22.5 Meq K IV), P=${pStr}`);
    }
    else if (p >= 1.6 && p <= 1.9) {
      out.push(`Give 30 mmol phos (45 Meq K IV), P=${pStr}`);
    }
    else if (p > 0 && p <= 1.6) {
      out.push(`Give 40 mmol phos (60 Meq K IV), P=${pStr}`);
    }
  }

  return out;
}

function buildIOWarnings(ioData, patient) {
  const out = [];
  const elapsedHours = Math.max(1, Number(ioData.elapsedHours || 24));
  const elapsedHoursDisplay = Math.round(elapsedHours);
  const num = (v) => (v === null || v === undefined || v === '' ? undefined : Number(v));

  // Urine output check
  const urine = Array.isArray(ioData.outputs?.urine) ? ioData.outputs.urine : [];
  
  if (urine.length > 0) {
    const totalUrine = urine.reduce((s, e) => s + (num(e.volume) || 0), 0);
    const hourly = totalUrine / elapsedHours;
    
    if (patient?.weight) {
      const upkh = (hourly / patient.weight).toFixed(2);
      if (+upkh < 0.1) {
        out.push(`ANURIA! *${upkh} mL/kg/hr* - total *${Math.round(totalUrine)} mL* in ${elapsedHoursDisplay}hr`);
      } else if (+upkh < 0.5) {
        out.push(`LOW URINE OUTPUT! *${upkh} mL/kg/hr* (goal ‚â•0.5) - total *${Math.round(totalUrine)} mL* in ${elapsedHoursDisplay}hr`);
      }
    }
  } else {
    out.push(`No urine output recorded!`);
  }

  // Drain output check
  const drains = ioData.outputs?.drains || {};
  Object.entries(drains).forEach(([type, entries]) => {
    const arr = Array.isArray(entries) ? entries : [];
    if (arr.length > 0) {
      const total = arr.reduce((s, e) => s + (num(e.volume) || 0), 0);
      if (total > (30 * elapsedHours)) {
        out.push(`${type}: *${Math.round(total)} mL* (HIGH OUTPUT) in ${elapsedHoursDisplay}hr`);
      }
    }
  });

  // Estimated blood loss check
  const eblArr = ioData.outputs?.other?.['Estimated Blood Loss'] || [];
  if (Array.isArray(eblArr) && eblArr.length > 0) {
    const total = eblArr.reduce((s, e) => s + (num(e.volume) || 0), 0);
    if (total > 500) {
      out.push(`Estimated Blood Loss: *${Math.round(total)} mL* - monitor hemoglobin`);
    }
  }

  // Intake check
  const enteral = Array.isArray(ioData.intakes?.enteral) ? ioData.intakes.enteral : [];
  const blood = Array.isArray(ioData.intakes?.bloodProducts) ? ioData.intakes.bloodProducts : [];
  const otherIntake = Array.isArray(ioData.intakes?.other) ? ioData.intakes.other : [];

  if (enteral.length === 0 && blood.length === 0 && otherIntake.length === 0) {
    out.push(`No intake recorded in last ${elapsedHoursDisplay}hr!`);
  }

  return out;
}






















// Create modern I/O Dashboard - COMPACT VERSION
function createIODashboard(ioData, data) {
  const container = document.createElement('div');
  container.style.cssText = `
    margin: 0.5rem 0;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  `;
  
  const elapsedHours = Math.round(ioData.elapsedHours || 24);
  
  // Get totals from summary
  let totalIntake = 0;
  let totalOutput = 0;
  
  const intakeSummaryMatch = lastImportedData?.match(/Total\s+Summary[\s\S]*?Intake\s+mL\s+([\d,]+(?:\.\d+)?)/i);
  const outputSummaryMatch = lastImportedData?.match(/Total\s+Summary[\s\S]*?Output\s+mL\s+([\d,]+(?:\.\d+)?)/i);
  
  if (intakeSummaryMatch) {
    totalIntake = parseFloat(intakeSummaryMatch[1].replace(/,/g, ''));
  } else {
    totalIntake += ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.other.reduce((sum, entry) => sum + entry.volume, 0);
  }
  
  if (outputSummaryMatch) {
    totalOutput = parseFloat(outputSummaryMatch[1].replace(/,/g, ''));
  } else {
    totalOutput += ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    Object.values(ioData.outputs.drains).forEach(entries => {
      totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
    Object.values(ioData.outputs.other).forEach(entries => {
      totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
  }
  
  const fluidBalance = totalIntake - totalOutput;
  
  // Check for Foley
  const hasFoley = ioData.outputs.urinaryCatheter;
  
  // Main metrics cards - COMPACT
  const metricsRow = document.createElement('div');
  metricsRow.style.cssText = `
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.4rem;
  `;
  
  // Intake Card
  metricsRow.appendChild(createMetricCard(
    'üíß IN',
    totalIntake,
    'mL',
    `${elapsedHours}hr`,
    '#3b82f6',
    false
  ));
  
  // Output Card - with Foley indicator
  metricsRow.appendChild(createMetricCard(
    hasFoley ? 'üî¥ OUT' : 'üö∞ OUT',
    -totalOutput,
    'mL',
    `${elapsedHours}hr`,
    '#ef4444',
    false
  ));
  
  // Balance Card
  const balanceAbnormal = Math.abs(fluidBalance) > 100;
  metricsRow.appendChild(createMetricCard(
    '‚öñÔ∏è BAL',
    fluidBalance,
    'mL',
    fluidBalance >= 0 ? '+' : '-',
    fluidBalance >= 0 ? '#10b981' : '#f59e0b',
    balanceAbnormal
  ));
  
  container.appendChild(metricsRow);
  
  // Detailed breakdown section - COMPACT
  const detailsSection = document.createElement('div');
  detailsSection.style.cssText = `
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.4rem;
  `;
  
  

// INTAKES DETAIL
const intakesCard = createDetailCard('IN', '#3b82f6');

if (ioData.intakes.enteral.length > 0) {
  // Group by description to avoid duplicates
  const groupedEnteral = {};
  ioData.intakes.enteral.forEach(entry => {
    const desc = entry.description || 'Enteral';
    if (!groupedEnteral[desc]) {
      groupedEnteral[desc] = [];
    }
    groupedEnteral[desc].push(entry);
  });
  
  // Show each unique enteral feed with its latest rate
  Object.entries(groupedEnteral).forEach(([desc, entries]) => {
    const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
    const rate = latest.volume; // This is the hourly rate for continuous feeds
    
    // Clean up description - remove redundant "Enteral" text
    let cleanDesc = desc.replace(/Percutaneous endo gastrostomy/i, 'PEG')
                        .replace(/Abdominal wall -/i, '')
                        .replace(/Enteral Tube Feed Continuous:/i, 'Tube Feed')
                        .replace(/Enteral/i, '')
                        .trim();
    
    intakesCard.appendChild(createDetailItem(
      `üçº ${cleanDesc}`,
      `${rate} mL/hr`,
      `${latest.dateTimeStr}`,
      '#60a5fa'
    ));
  });
}

if (ioData.intakes.bloodProducts.length > 0) {
  const totalBlood = ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
  const latest = ioData.intakes.bloodProducts.sort((a, b) => b.dateTime - a.dateTime)[0];
  intakesCard.appendChild(createDetailItem(
    'ü©∏ Blood',
    `${totalBlood} mL`,
    `${latest.dateTimeStr}`,
    '#ef4444'
  ));
}

if (ioData.intakes.other.length > 0) {
  const groupedIntakes = {};
  ioData.intakes.other.forEach(entry => {
    const type = entry.description || 'Other';
    if (!groupedIntakes[type]) groupedIntakes[type] = [];
    groupedIntakes[type].push(entry);
  });
  
  Object.entries(groupedIntakes).forEach(([type, entries]) => {
    const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
    const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
    intakesCard.appendChild(createDetailItem(
      `üíß ${type}`,
      `${total} mL`,
      `${latest.dateTimeStr}`,
      '#3b82f6'
    ));
  });
}

if (!ioData.intakes.enteral.length && !ioData.intakes.bloodProducts.length && !ioData.intakes.other.length) {
  intakesCard.appendChild(createEmptyState('No intake'));
}

detailsSection.appendChild(intakesCard);


  
  // OUTPUTS DETAIL
  const outputsCard = createDetailCard('OUT', '#ef4444');
  
  // Urine
  if (ioData.outputs.urine.length > 0) {
    const totalUrine = ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    const hourlyOutput = Math.round(totalUrine / ioData.elapsedHours);
    
    let urineLabel = 'üíß UOP';
    let urineValue = `${totalUrine} mL (${hourlyOutput}/hr)`;
    let isAbnormal = false;
    
    if (ioData.outputs.urinaryCatheter) {
      urineLabel = 'üî¥ Foley';
    }
    
    if (data.weight) {
      const urinePerKgHr = (hourlyOutput / data.weight).toFixed(2);
      urineValue += ` ‚Ä¢ ${urinePerKgHr} mL/kg/hr`;
      if (urinePerKgHr < 0.5) {
        isAbnormal = true;
      }
    }
    
    outputsCard.appendChild(createDetailItem(
      urineLabel,
      urineValue,
      `${ioData.outputs.lastUrineTimeStr}`,
      isAbnormal ? '#ff4444' : '#fbbf24',
      isAbnormal
    ));
  } else {
    outputsCard.appendChild(createDetailItem(
      '‚ö†Ô∏è NO URINE',
      'Not recorded',
      '',
      '#ff4444',
      true
    ));
  }
  
  // Drains
  Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
    if (entries.length > 0) {
      const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
      const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
      const isHighOutput = total > (30 * ioData.elapsedHours);
      
      outputsCard.appendChild(createDetailItem(
        `ü©π ${drainType}`,
        `${total} mL`,
        `${latest.dateTimeStr}`,
        isHighOutput ? '#ff4444' : '#f97316',
        isHighOutput
      ));
    }
  });
  
  // Other outputs
  Object.entries(ioData.outputs.other).forEach(([outputType, entries]) => {
    if (entries.length > 0) {
      const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
      const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
      const isBloodLoss = outputType.includes('Blood Loss');
      
      outputsCard.appendChild(createDetailItem(
        `${isBloodLoss ? 'ü©∏' : 'üíß'} ${outputType}`,
        `${total} mL`,
        `${latest.dateTimeStr}`,
        isBloodLoss ? '#ff4444' : '#f97316',
        isBloodLoss
      ));
    }
  });
  
  detailsSection.appendChild(outputsCard);
  container.appendChild(detailsSection);
  
  // COUNTS Section (if any) - COMPACT
  if (Object.keys(ioData.counts || {}).length > 0) {
    const countsCard = createDetailCard('COUNTS', '#8b5cf6');
    
    Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
      if (entries.length > 0) {
        const totalCount = entries.reduce((sum, entry) => sum + entry.count, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        const isAbnormal = (countType.toLowerCase().includes('stool') && totalCount > 3) ||
                          (countType.toLowerCase().includes('vomit') && totalCount > 0);
        
        countsCard.appendChild(createDetailItem(
          `üìä ${countType}`,
          `${totalCount}x`,
          `${latest.dateTimeStr}`,
          isAbnormal ? '#ff4444' : '#a78bfa',
          isAbnormal
        ));
      }
    });
    
    container.appendChild(countsCard);
  }
  
  return container;
}

// Helper: Create metric card - COMPACT
function createMetricCard(title, value, unit, subtitle, color, isAbnormal) {
  const card = document.createElement('div');
  card.style.cssText = `
    background: ${isAbnormal ? 'rgba(239, 68, 68, 0.1)' : 'rgba(30, 30, 30, 0.5)'};
    border: 2px solid ${isAbnormal ? '#ff4444' : color}40;
    border-radius: 0.375rem;
    padding: 0.4rem;
    text-align: center;
  `;
  
  const titleEl = document.createElement('div');
  titleEl.style.cssText = `
    font-size: 0.65rem;
    font-weight: bold;
    color: ${color};
    margin-bottom: 0.2rem;
    letter-spacing: 0.3px;
  `;
  titleEl.textContent = title;
  
  const valueEl = document.createElement('div');
  valueEl.style.cssText = `
    font-size: 1.1rem;
    font-weight: bold;
    color: ${isAbnormal ? '#ff4444' : 'var(--text-primary)'};
    font-family: monospace;
    line-height: 1;
  `;
  const sign = value >= 0 ? '+' : '';
  valueEl.textContent = `${sign}${Math.round(value)}`;
  
  const unitEl = document.createElement('div');
  unitEl.style.cssText = `
    font-size: 0.6rem;
    color: var(--text-secondary);
    margin-top: 0.15rem;
  `;
  unitEl.textContent = `${unit}/${subtitle}`;
  
  card.appendChild(titleEl);
  card.appendChild(valueEl);
  card.appendChild(unitEl);
  
  return card;
}

// Helper: Create detail card - COMPACT
function createDetailCard(title, color) {
  const card = document.createElement('div');
  card.style.cssText = `
    background: rgba(30, 30, 30, 0.5);
    border: 1px solid ${color}30;
    border-radius: 0.375rem;
    padding: 0.5rem;
  `;
  
  const titleEl = document.createElement('div');
  titleEl.style.cssText = `
    font-size: 0.75rem;
    font-weight: bold;
    color: ${color};
    margin-bottom: 0.4rem;
    padding-bottom: 0.3rem;
    border-bottom: 1px solid ${color}20;
    letter-spacing: 0.3px;
  `;
  titleEl.textContent = title;
  
  card.appendChild(titleEl);
  return card;
}

// Helper: Create detail item - COMPACT
function createDetailItem(label, value, timeInfo, color, isAbnormal = false) {
  const item = document.createElement('div');
  item.style.cssText = `
    padding: 0.3rem;
    margin-bottom: 0.3rem;
    background: ${isAbnormal ? 'rgba(239, 68, 68, 0.1)' : 'rgba(0, 0, 0, 0.2)'};
    border-left: 3px solid ${color};
    border-radius: 0.25rem;
    font-size: 0.75rem;
  `;
  
  const labelEl = document.createElement('div');
  labelEl.style.cssText = `
    font-weight: bold;
    color: ${isAbnormal ? '#ff4444' : color};
    margin-bottom: 0.15rem;
  `;
  labelEl.textContent = label;
  
  const valueEl = document.createElement('div');
  valueEl.style.cssText = `
    color: var(--text-primary);
    font-family: monospace;
    font-size: 0.75rem;
  `;
  valueEl.textContent = value;
  
  item.appendChild(labelEl);
  item.appendChild(valueEl);
  
  if (timeInfo) {
    const timeEl = document.createElement('div');
    timeEl.style.cssText = `
      color: var(--text-secondary);
      font-size: 0.65rem;
      margin-top: 0.15rem;
    `;
    timeEl.textContent = timeInfo;
    item.appendChild(timeEl);
  }
  
  return item;
}

// Helper: Create empty state - COMPACT
function createEmptyState(message) {
  const empty = document.createElement('div');
  empty.style.cssText = `
    padding: 0.5rem;
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
    font-size: 0.75rem;
  `;
  empty.textContent = message;
  return empty;
}

    </script>
</body>
</html>
