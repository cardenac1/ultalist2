<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>Ultimate Patient List</title>
    
    <!-- Check if running as extension -->
    <script>
    let IS_EXTENSION = false;
    try {
        IS_EXTENSION = typeof chrome !== 'undefined' && chrome.storage && chrome.storage.sync;
    } catch (e) {
        IS_EXTENSION = false;
    }
    </script>


	
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3b82f6;
            --primary-dark: #2563eb;
            --secondary: #06b6d4;
            --danger: #ef4444;
            --success: #10b981;
            --dark-bg: #121212;
            --card-bg: #1e1e1e;
            --card-hover: #333333;
            --border: #444444;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --accent-1: #00e5ff;
            --accent-2: #f26363;
            --accent-3: #79e89f;
            --accent-4: #ffffff;
            --accent-5: #ff8000;
        }

        body {
            background-color: var(--dark-bg);
            color: var(--text-primary);
            font-family: monospace;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        /* Header */
        .header {
            background: var(--card-bg);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            margin-bottom: 1rem;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .census {
            font-size: 1.2rem;
            color: var(--text-secondary);
        }

        .census-number {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 1rem 2rem 1rem;
        }

        /* File Input */
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 0.75rem 1.5rem;
            background: var(--card-bg);
            border: 2px dashed var(--primary);
            border-radius: 0.5rem;
            transition: all 0.3s ease;
            text-align: center;
            width: 100%;
        }

        .controls .file-input-label {
            padding: 0.75rem 1rem;
            border: none;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            font-weight: 500;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .controls .file-input-wrapper:hover .file-input-label {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        /* Controls */
  /* Controls */
.controls {
    display: grid;
    grid-template-columns: repeat(3, 1fr);  
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

/* Navigation buttons */
.nav-buttons {
    display: grid;
    grid-template-columns: repeat(4, 1fr);  /* Changed to exact 4-column grid */
    gap: 0.75rem;
    margin: 1rem 0;
}

        /* Buttons */
        button {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            font-family: inherit;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Select */
        select {
            background: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid var(--border);
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: inherit;
        }

        /* Row List */
        .row-list {
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .row-item {
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border-left: 4px solid transparent;
            font-size: 1rem;
            position: relative;
        }

        .row-item:hover {
            background: var(--card-hover);
            transform: translateX(5px);
            border-left-color: var(--primary);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* Colored Text */
        .colored-text-1 { color: var(--accent-1); }
        .colored-text-2 { color: var(--accent-2); }
        .colored-text-3 { color: var(--accent-3); }
        .colored-text-4 { color: var(--accent-4); }
        .colored-text-5 { color: var(--accent-5); }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
            transition: all 0.3s ease;
            z-index: 1000;
            border: none;
        }

        .fab:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: var(--card-bg);
            margin: 5% auto;
            padding: 1.5rem;
            border-radius: 0.5rem;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease;
        }


.modal-content.large-modal {
    max-width: 95%;
    width: 95%;
    max-height: 90vh;
}


		#helpModal input[type="checkbox"] {
    cursor: pointer;
    transform: scale(1.1);
    transition: transform 0.2s ease;
}

#helpModal input[type="checkbox"]:hover {
    transform: scale(1.2);
}

#helpModal label:hover {
    transform: translateX(2px);
}

		


        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }



		#cropInterface {
    text-align: center;
}

#cropCanvas {
    display: block;
    margin: 0 auto;
}

.crop-instructions {
    color: var(--text-secondary);
    font-size: 0.9rem;
    margin: 0.5rem 0;
}
		

        /* Details View */
        .details-view {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
            z-index: 1500;
            overflow-y: auto;
	     padding: 0.5rem; 
        }

        .details-header {
            background: var(--card-bg);
            padding: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .sticky-text {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary);
        }

        .view-selector {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .view-button {
            padding: 0.5rem 1rem;
            background: var(--card-bg);
            border: 2px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .view-button.active {
            background: var(--primary);
            border-color: var(--primary);
        }

        #editForm {
   		 padding: 0.5rem;
    		max-width: none;
    		margin: 0;
   		 width: 100%;
        }



        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
        }

        label {
            display: block;
            margin-top: 0.75rem;
            color: var(--text-secondary);
            font-weight: 500;
            font-size: 0.9rem;
            text-transform: uppercase;
        }



        .delete-button {
            background: linear-gradient(135deg, var(--danger), #dc2626);
        }

        /* Chart Check Mode Specific */
        .chart-check-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }

        .warning-messages {
            background: var(--card-bg);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid var(--danger);
        }

        .warning-message {
            color: var(--danger);
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 1.2em;
        }

        /* Search Container */
        .search-wrapper {
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
            position: relative;
        }

        .search-wrapper.expanded {
            margin-bottom: 4rem;
        }

        .search-container {
            display: flex;
            gap: 0.5rem;
            background: var(--card-bg);
            padding: 0.75rem;
            border-radius: 0.5rem;
            opacity: 0;
            transform: translateY(-10px);
            visibility: hidden;
            transition: all 0.3s ease;
            position: absolute;
            width: 100%;
            z-index: 10;
        }

        .search-container.active {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }

        #searchInput {
            flex: 1;
            padding: 0.5rem;
            background: var(--dark-bg);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            color: var(--text-primary);
            font-size: 0.9rem;
            font-family: inherit;
        }






textarea, input[type="text"] {
    width: 100%;
    padding: 0.75rem;
    background: var(--card-bg);
    color: var(--text-primary);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    font-size: 1rem;
    font-family: inherit;
    margin: 0.5rem 0 1rem;
    resize: none;
    transition: all 0.3s ease;
    overflow-y: hidden;  /* ← CHANGED FROM auto TO hidden */
    text-align: left;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
}
	    
/* Desktop view selector improvements - add this before the mobile media query */
.view-selector {
    display: grid;
    gap: 0.5rem;
    margin-top: 1rem;
    max-width: 600px;
    grid-template-columns: repeat(3,1fr);
    grid-template-rows: repeat(1,1fr);
    justify-content: center;
}

.view-button {
    padding: 0.6rem 1rem;
    background: var(--card-bg);
    border: 2px solid var(--border);
    border-radius: 0.375rem;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.85rem;
    text-align: center;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 40px;
    white-space: nowrap;
}

.view-button:hover {
    border-color: var(--primary);
    background: var(--card-hover);
}

.view-button.active {
    background: var(--primary);
    border-color: var(--primary);
    color: white;
}






/* Column Selector Styles - MUST BE BEFORE MEDIA QUERIES */
.column-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 0.5rem;
    padding: 0.5rem;
    background: var(--dark-bg);
    border-radius: 0.5rem;
    margin-top: 0.5rem;
}

.column-button {
    padding: 0.5rem;
    background: var(--card-bg);
    border: 2px solid var(--border);
    border-radius: 0.25rem;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    font-size: 0.9rem;
    color: var(--text-primary);
    font-family: inherit;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.column-button:hover {
    border-color: var(--primary);
    background: var(--card-hover);
}

.column-button.selected {
    background: var(--success);
    border-color: var(--success);
    color: white;
    font-weight: bold;
}

/* Orders section */
.orders-section {
    background: var(--card-bg);
    padding: 1rem;
    border-radius: 0.5rem;
    margin-bottom: 1rem;
    white-space: pre-wrap;
    font-family: monospace;
    font-size: 0.9rem;
    border: 1px solid var(--border);
}

/* Table view */
.data-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
    font-size: 0.85em;
    overflow-x: auto;
    display: block;
}

.data-table th,
.data-table td {
    padding: 8px;
    border: 1px solid var(--border);
    text-align: left;
    white-space: nowrap;
}

.data-table th {
    background: var(--card-bg);
    color: var(--accent-4);
    position: sticky;
    left: 0;
    z-index: 1;
}

.data-table tr:nth-child(even) {
    background: var(--card-bg);
}

/* Import textarea */
.import-textarea {
    width: 100%;
    min-height: 300px;
    background: var(--card-bg);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 10px;
    font-family: 'Courier New', monospace;
    border-radius: 5px;
    font-size: 0.9em;
}

.hidden {
    display: none !important;
}


	    /* Clipboard Button */
.clipboard-btn {
    position: absolute;
    right: 2px;  /* Small gap from edge */
    top: 50%;
    transform: translateY(-50%);
    background: var(--card-bg);
    border: 1px solid var(--border);  /* Thinner border */
    border-radius: 0.25rem;
    padding: 0.25rem;  /* Reduced padding */
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 1rem;  /* Slightly smaller icon */
    line-height: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 30px;  /* Smaller minimum width */
    min-height: 30px;  /* Smaller minimum height */
}
	    

.clipboard-btn:hover {
    background: var(--primary);
    border-color: var(--primary);
    transform: translateY(-50%) scale(1.1);
    box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
}

.clipboard-btn.copied {
    background: var(--success);
    border-color: var(--success);
}

	  



/* Chart Check Mode Split Layout */
.chart-check-layout {
    display: flex;
    gap: 1rem;
    height: calc(100vh - 200px);
}

.chart-check-left {
    flex: 2;
    overflow-y: auto;
    padding-right: 1rem;
}

.chart-check-right {
    flex: 1;
    display: flex;
    flex-direction: column;
    background: var(--card-bg);
    border-radius: 0.5rem;
    padding: 1rem;
    border: 2px solid var(--primary);
}

.chart-check-right h3 {
    color: var(--primary);
    margin-bottom: 0.5rem;
    font-size: 1.1rem;
}

.chart-check-right textarea {
    flex: 1;
    resize: none;
    background: var(--dark-bg);
    border: 1px solid var(--border);
    border-radius: 0.25rem;
    padding: 0.75rem;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 0.9rem;
}









.help-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: var(--secondary);
    color: white;
    border: none;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 0.65rem;
    margin-left: 6px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
    padding: 0;
    line-height: 1;
    font-family: monospace;
    vertical-align: middle;
}


		

.help-button:hover {
    background: var(--primary);
    transform: scale(1.05);
}

/* Help Modal */
.help-modal {
    display: none;
    position: fixed;
    z-index: 2500;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.8);
    animation: fadeIn 0.3s ease;
}

.help-modal-content {
    background: var(--card-bg);
    margin: 5% auto;
    padding: 2rem;
    border-radius: 1rem;
    width: 90%;
    max-width: 900px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
    animation: slideIn 0.3s ease;
    position: relative;
}

.help-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--border);
}

.help-modal-title {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--primary);
    margin: 0;
}

.help-modal-close {
    background: var(--danger);
    color: white;
    border: none;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    font-size: 1.5rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
}

.help-modal-close:hover {
    transform: scale(1.1);
    background: #dc2626;
}

.help-modal-body {
    font-size: 1rem;
    line-height: 1.6;
    color: var(--text-primary);
}

.help-modal-body ul {
    margin: 1rem 0;
    padding-left: 1.5rem;
}

.help-modal-body li {
    margin: 0.5rem 0;
}

.help-modal-body strong {
    color: var(--accent-4);
}

.help-modal-body a {
    color: var(--primary);
    text-decoration: none;
}

.help-modal-body a:hover {
    text-decoration: underline;
}

/* Custom scrollbar for modal */
.help-modal-content::-webkit-scrollbar {
    width: 12px;
}

.help-modal-content::-webkit-scrollbar-track {
    background: var(--dark-bg);
    border-radius: 6px;
}

.help-modal-content::-webkit-scrollbar-thumb {
    background: var(--primary);
    border-radius: 6px;
}

.help-modal-content::-webkit-scrollbar-thumb:hover {
    background: var(--primary-dark);
}








/* Mobile-specific help button adjustments */
@media (max-width: 768px) {
    .help-button {
        width: 20px;
        height: 20px;
        min-width: 20px;
        min-height: 20px;
        max-width: 20px;
        max-height: 20px;
        font-size: 0.7rem;
        margin-left: 4px;
    }
}



/* FIX: Force left alignment for details view form elements */
  #editForm label,
  #editForm input[type="text"],
  #editForm textarea,
  #editForm .violin-field,
  #editForm div[contenteditable="true"] {
    text-align: left !important;
  }
  
  /* Also ensure labels are properly left-aligned */
  .details-view label {
    text-align: left !important;
    display: block;
  }
  
  /* Fix chart check layout text alignment */
  .chart-check-left label,
  .chart-check-left input,
  .chart-check-left textarea,
  .chart-check-left .violin-field,
  .chart-check-right textarea {
    text-align: left !important;
  }









/* Chart Check Mode Colorful Borders */
.chart-check-left input[type="text"],
.chart-check-left textarea {
    transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.chart-check-left label:nth-of-type(1) + input,
.chart-check-left label:nth-of-type(1) + textarea {
    border-color: var(--accent-1);
    box-shadow: 0 0 0 1px rgba(0, 229, 255, 0.2);
}

.chart-check-left label:nth-of-type(2) + input,
.chart-check-left label:nth-of-type(2) + textarea {
    border-color: var(--accent-2);
    box-shadow: 0 0 0 1px rgba(242, 99, 99, 0.2);
}

.chart-check-left label:nth-of-type(3) + input,
.chart-check-left label:nth-of-type(3) + textarea {
    border-color: var(--accent-3);
    box-shadow: 0 0 0 1px rgba(121, 232, 159, 0.2);
}

.chart-check-left label:nth-of-type(4) + input,
.chart-check-left label:nth-of-type(4) + textarea {
    border-color: var(--accent-4);
    box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.2);
}

.chart-check-left label:nth-of-type(5) + input,
.chart-check-left label:nth-of-type(5) + textarea {
    border-color: var(--accent-5);
    box-shadow: 0 0 0 1px rgba(255, 128, 0, 0.2);
}

.chart-check-left label:nth-of-type(6) + input,
.chart-check-left label:nth-of-type(6) + textarea {
    border-color: var(--primary);
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2);
}

.chart-check-left label:nth-of-type(7) + input,
.chart-check-left label:nth-of-type(7) + textarea {
    border-color: var(--secondary);
    box-shadow: 0 0 0 1px rgba(6, 182, 212, 0.2);
}

.chart-check-left label:nth-of-type(8) + input,
.chart-check-left label:nth-of-type(8) + textarea {
    border-color: var(--success);
    box-shadow: 0 0 0 1px rgba(16, 185, 129, 0.2);
}

.chart-check-left input[type="text"]:focus,
.chart-check-left textarea:focus {
    box-shadow: 0 0 0 2px currentColor !important;
}

/* Right panel textarea gets a special color too */
.chart-check-right textarea {
    border-color: var(--primary) !important;
    box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.3) !important;
}

.chart-check-right textarea:focus {
    box-shadow: 0 0 0 2px var(--primary) !important;
}








@media (max-width: 768px) {
    .chart-check-layout {
        flex-direction: column;
        height: auto;
    }
    
    .chart-check-left {
        padding-right: 0;
    }
    
    .chart-check-right {
        margin-top: 1rem;
        max-height: 300px;
    }
}



  


	    /* ===== TABLET AND MOBILE STYLES ===== */
@media (max-width: 768px) {
  /* MAIN PAGE BUTTON GRIDS – 2-column snap grid */
  .controls {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.5rem;
    margin-bottom: 0.75rem;
    padding: 0.5rem;
    background: rgba(30, 30, 30, 0.2);
  }
  .controls > * {
    width: 100%;
  }
  .controls button,
  .controls .file-input-label,
  .controls select {
    padding: 0.4rem 0.3rem;
    font-size: 0.75rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: flex;
    align-items: center;
    justify-content: center;
  }



.row-item {
    padding-right: 1rem; /* Increased padding to prevent text overlap */
}
	.violin-button-container {
    display: grid !important;
    grid-template-columns: repeat(3, 1fr) !important;
    gap: 0.25rem !important;
    margin: 0.5rem 0 !important;
    width: 100% !important;
  }
  
  .violin-button-container button {
    padding: 0.4rem 0.2rem !important;
    font-size: 0.7rem !important;
    margin: 0 !important;
    white-space: nowrap !important;
    overflow: hidden !important;
    text-overflow: ellipsis !important;
  }
	






  /* NAV BUTTONS – leave as 2×2 */
  .nav-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.4rem;
    margin: 1rem 0;
    padding: 0.5rem;
    background: rgba(30, 30, 30, 0.3);
    border: 1px solid var(--border);
    border-radius: 0.5rem;
  }
	
input[type="text"],
input[type="number"],
input[type="email"],
input[type="tel"],
input[type="password"],
input[type="search"],
input,
textarea,
select,


  /* Universal mobile button styling */
  button,
  .file-input-label {
    padding: 0.7rem 0.5rem;
    font-size: 0.8rem;
    min-height: 44px;
    border-radius: 0.3rem;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  select {
    min-height: 44px;
    padding: 0.7rem;
    font-size: 0.8rem;
  }

  /* MODAL BUTTON GRIDS */
  #entryTypeSelection .nav-buttons { grid-template-columns: 1fr; grid-template-rows: repeat(3,1fr); }
  .modal-content .nav-buttons   { grid-template-columns: 1fr; grid-template-rows: repeat(2,1fr); }
  #consultControls .nav-buttons   { grid-template-columns: repeat(2, 1fr); grid-template-rows: repeat(2, 1fr); }
  .chart-check-controls           { display: grid; grid-template-columns: 1fr; grid-template-rows: repeat(3,1fr); gap:0.4rem; margin:1rem 0; }

.details-header {
    padding: 0.75rem;
    position: sticky;  /* Changed from relative to sticky */
    top: 0;           /* Add this to ensure it sticks to top */
    z-index: 100;     /* Add this to ensure it stays above content */
    background: var(--card-bg);
    border-bottom: 1px solid var(--border);
  }

	
  .sticky-text {
    font-size: 1.2rem;
    margin-bottom: 0.5rem;
  }

/* MOBILE VIEW SELECTOR */
.view-selector {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 0.3rem;
  margin-top: 0.5rem;
  width: 100%;
  padding: 0.4rem;
  background: rgba(30, 30, 30, 0.2);

  /* remove any fixed height so it will shrink-wrap to its contents */
  height: auto;
  /* you can also drop grid-template-rows entirely—it defaults to one auto-sized row */
}

/* make the buttons small and equal-height */
.view-button {
  padding: 0.25rem;
  font-size: 0.7rem;
  text-align: center;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;

  display: flex;
  align-items: center;
  justify-content: center;

  border-radius: 0.25rem;
  box-sizing: border-box;

  /* fix the height to something compact */
  height: 30px;
  /* let width fill its grid cell evenly */
  width: 100%;
}


  /* REST OF MOBILE FORM & TABLE STYLES (unchanged) */
  #editForm {
    padding: 1rem 1rem 0;
    max-width: 100%;
    margin: 0;
  }



	textarea, input[type="text"] {
        font-size: 16px;
        padding: 0.75rem;
        margin: 0.25rem 0 0.75rem;
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
        overflow-y: hidden;  /* ← CHANGED FROM auto TO hidden */
    }

.violin-field {
    font-size: 16px !important;
  }
  
	

  label {
    margin-top: 0.5rem;
    font-size: 0.85rem;
  }
  label button {
    margin-top: 0.5rem;
    width: 100%;
    padding: 0.5rem;
    font-size: 0.8rem;
  }
  .modal-content {
    margin: 2% auto;
    width: 95%;
    padding: 1rem;
    max-height: 95vh;
  }
  .search-container {
    flex-direction: column;
    gap: 0.25rem;
  }
  #searchInput {
    margin-bottom: 0.25rem;
  }
  .column-selector {
    grid-template-columns: repeat(3,1fr);
    gap: 0.25rem;
  }
  .column-button {
    padding: 0.5rem 0.25rem;
    font-size: 0.8rem;
    min-height: 40px;
  }
  .row-list {
    gap: 0.75rem;
  }
  .row-item {
    padding: 0.75rem;
    font-size: 0.9rem;
  }
  .fab {
    bottom: 1rem;
    right: 1rem;
    width: 50px;
    height: 50px;
    font-size: 1.5rem;
  }
  .header {
    padding: 0.75rem;
  }
  .census-number {
    font-size: 1.5rem;
  }
  .container {
    padding: 0 0.75rem 2rem;
  }
  .warning-messages {
    padding: 0.75rem;
    margin-bottom: 1rem;
    font-size: 0.9rem;
  }
  .warning-message {
    font-size: 0.95rem;
    margin-bottom: 0.25rem;
  }
  .orders-section {
    padding: 0.75rem;
    font-size: 0.85rem;
    margin-bottom: 0.75rem;
  }
  .data-table {
    font-size: 0.75rem;
    display: block;
    width: 100%;
    overflow-x: auto;
    white-space: nowrap;
  }
  .data-table th,
  .data-table td {
    padding: 0.5rem 0.25rem;
    min-width: 80px;
  }
  .import-textarea {
    min-height: 200px;
    font-size: 0.85rem;
  }
}





.clipboard-btn {
    min-width: 28px;  /* Smaller on mobile */
    min-height: 28px;
    padding: 0.2rem;  /* Less padding */
    font-size: 0.9rem;  /* Slightly smaller icon */
    right: 2px;  /* Small gap from edge */
}
/* Adjust row item padding to make room for clipboard button */
.row-item {
        padding-right: 1rem; /* Less padding needed with smaller button */

}


		


		/* Fishbone display container */
.fishbone-display {
    background: var(--card-bg);
    border: 2px solid var(--secondary);
    border-radius: 0.5rem;
    padding: 1rem;
    margin: 1rem 0;
    font-family: monospace;
    font-size: 0.9rem;
    line-height: 1.6;
    white-space: pre-wrap;
    color: var(--text-primary);
}

.fishbone-display.hidden {
    display: none;
}

.fishbone-display h4 {
    color: var(--secondary);
    margin: 0 0 0.5rem 0;
    font-size: 1rem;
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .fishbone-display {
        /* Remove this line too: */
        /* max-height: 300px; */
        font-size: 0.85rem;
        padding: 0.75rem;
    }

	
}


		/* Mobile touch improvements */
#cropCanvas {
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;
}

/* Improve button sizing for mobile */
@media (max-width: 768px) {
    #cameraEntrySection button {
        min-height: 44px;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
    }
    
    #cropInterface button {
        min-height: 44px;
        padding: 0.75rem 1rem;
        font-size: 0.9rem;
        margin: 0.25rem;
    }
}



















/* Replace the existing .status-dot CSS (around line 2818 in your HTML) with this: */

.status-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    transition: all 0.3s ease;
    border: 2px solid currentColor;
    position: relative;
    cursor: pointer;
    /* Multi-layer glow effect */
    box-shadow: 
        0 0 4px currentColor,
        0 0 8px currentColor,
        0 0 12px currentColor,
        inset 0 0 4px rgba(255,255,255,0.3);
    /* Subtle pulse animation */
    animation: ledPulse 2s ease-in-out infinite alternate;
}

.status-dot:hover {
    transform: scale(1.3);
    /* Enhanced glow on hover */
    box-shadow: 
        0 0 6px currentColor,
        0 0 12px currentColor,
        0 0 18px currentColor,
        0 0 24px currentColor,
        inset 0 0 6px rgba(255,255,255,0.4);
    animation: ledPulseHover 0.5s ease-in-out infinite alternate;
}

/* Pulsing animation for LED effect */
@keyframes ledPulse {
    0% {
        box-shadow: 
            0 0 4px currentColor,
            0 0 8px currentColor,
            0 0 12px currentColor,
            inset 0 0 4px rgba(255,255,255,0.3);
    }
    100% {
        box-shadow: 
            0 0 6px currentColor,
            0 0 10px currentColor,
            0 0 16px currentColor,
            inset 0 0 6px rgba(255,255,255,0.4);
    }
}

/* Faster pulse on hover */
@keyframes ledPulseHover {
    0% {
        box-shadow: 
            0 0 6px currentColor,
            0 0 12px currentColor,
            0 0 18px currentColor,
            0 0 24px currentColor,
            inset 0 0 6px rgba(255,255,255,0.4);
    }
    100% {
        box-shadow: 
            0 0 8px currentColor,
            0 0 16px currentColor,
            0 0 24px currentColor,
            0 0 32px currentColor,
            inset 0 0 8px rgba(255,255,255,0.5);
    }
}

/* Special urgent/critical pulsing for priority 1 */
.status-dot[style*="#ff0040"] {
    animation: urgentPulse 1s ease-in-out infinite alternate;
}

@keyframes urgentPulse {
    0% {
        box-shadow: 
            0 0 6px #ff0040,
            0 0 12px #ff0040,
            0 0 18px #ff0040,
            inset 0 0 6px rgba(255,255,255,0.3);
    }
    100% {
        box-shadow: 
            0 0 10px #ff0040,
            0 0 20px #ff0040,
            0 0 30px #ff0040,
            0 0 40px #ff0040,
            inset 0 0 8px rgba(255,255,255,0.5);
    }
}

/* Mobile adjustments */
@media (max-width: 768px) {
    .status-dot {
        width: 10px;
        height: 10px;
        box-shadow: 
            0 0 1px currentColor,
            0 0 3px currentColor;
    }
    
    .status-dot:hover {
        box-shadow: 
            0 0 2px currentColor,
            0 0 4px currentColor;
    }
}





		
		


    </style>
</head>






	<!-- Replace the existing Tesseract script tag with this updated one -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.5/dist/tesseract.min.js"></script>
	
<script>
// Simple function to check if Tesseract is available
function isTesseractAvailable() {
    return typeof Tesseract !== 'undefined';
}

// Test function for OCR availability
async function testOCRAvailability() {
    if (!isTesseractAvailable()) {
        throw new Error('Tesseract.js not loaded');
    }
    
    try {
        // Create a simple test canvas with text
        const canvas = document.createElement('canvas');
        canvas.width = 200;
        canvas.height = 50;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, 200, 50);
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText('TEST', 50, 30);
        
        const imageData = canvas.toDataURL();
        const { data: { text } } = await Tesseract.recognize(imageData, 'eng');
        
        return text.toLowerCase().includes('test');
    } catch (error) {
        console.error('OCR test failed:', error);
        return false;
    }
}
</script>




	
<body>
    <!-- Header with Census -->
    <div class="header">
        <div class="header-content">
            <div class="census">
                Census: <span class="census-number" id="censusCount">0</span>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Controls -->
        <div class="controls">
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".json,.csv">
                <label for="fileInput" class="file-input-label">
                    📁 Import
                </label>
            </div>
            <button onclick="toggleColumnDropdown()">Column Options</button>
            <select id="columnSelect" onchange="sortRows()">
                <option value="">Sort by</option>
            </select>
               <button id="resortBtn" onclick="reSort()" style="display: none;">↻ Re-sort</button>
            <button onclick="toggleSearch()">🔍</button>
            <button id="exportButtonMain" onclick="exportData()">Export</button>
        </div>

        <!-- Column Dropdown -->
        <div id="columnDropdown" style="display: none;">
            <div id="columnSelector" class="column-selector"></div>
        </div>

        <!-- Search Container -->
        <div class="search-wrapper">
            <div id="searchContainer" class="search-container">
                <input type="text" id="searchInput" placeholder="Search entries..." />
                <button onclick="searchRows()">Search</button>
                <button onclick="clearSearch()">Clear</button>
            </div>
        </div>

        <!-- Row List -->
        <ul class="row-list" id="rowList"></ul>

        <!-- Floating Action Button -->
        <button class="fab" onclick="showAddEntryModal()">+</button>

       <!-- Add Entry Modal -->
<div id="addEntryModal" class="modal">
    <div class="modal-content">
        <h2>Add New Entry</h2>
        
        <div id="entryTypeSelection" class="nav-buttons">
            <button type="button" onclick="showManualEntry()">Manual Entry</button>
            <button type="button" onclick="showPasteEntry()">Paste Entry</button>
            <button type="button" onclick="showUpdatePatientsSection()">🔄 Update Patients</button>
            <button type="button" onclick="closeAddEntryModal()">Cancel</button>
			<button type="button" onclick="showCameraEntry()">📸 Scan Label</button>
        </div>

        <form id="addEntryForm" onsubmit="addEntry(event)" style="display: none;">
            <div id="newEntryFields"></div>
            <div class="nav-buttons">
                <button type="submit">Save Entry</button>
                <button type="button" onclick="backToEntrySelection()">← Back</button>
            </div>
        </form>

        <div id="pasteEntrySection" style="display: none;">
            <label for="pasteTextArea">Paste Cerner patient list data:</label>
            <textarea id="pasteTextArea" class="import-textarea" placeholder="Paste patient list here..." rows="10"></textarea>
            <div class="nav-buttons">
                <button type="button" onclick="processPastedEntry()">Process & Add</button>
                <button type="button" onclick="backToEntrySelection()">← Back</button>
            </div>
        </div>

        <!-- Add the Update Patients section -->
        <div id="updatePatientsSection" style="display: none;">
            <h3 style="color: var(--accent-4); margin-bottom: 10px;">Update Patient List</h3>
            <p style="color: var(--text-secondary); margin-bottom: 10px;">Paste the patient list below to update room assignments and attending physicians:</p>
            <textarea id="updateListDataModal" class="import-textarea" placeholder="Paste patient list here..." rows="10"></textarea>
            <div class="nav-buttons">
                <button type="button" onclick="processUpdateListFromModal()">Update List</button>
                <button type="button" onclick="backToEntrySelection()">← Back</button>
            </div>
        </div>


		









		<div id="cameraEntrySection" style="display: none;">
    <h3 style="color: var(--accent-4); margin-bottom: 10px;">Scan Patient Label</h3>
    <p style="color: var(--text-secondary); margin-bottom: 15px;">Upload a photo of the patient label sticker:</p>
    
    <!-- Test OCR System Button -->
    <div style="margin-bottom: 1rem; text-align: center;">
        <button type="button" onclick="testOCRSystem()" style="background: linear-gradient(135deg, var(--secondary), #0891b2); margin-bottom: 0.5rem;">
            🔧 Test OCR System
        </button>
        <div style="font-size: 0.8rem; color: var(--text-secondary);">Click to verify OCR is working before scanning</div>
    </div>
    
    <!-- File upload section -->
    <div style="margin: 1rem 0;">
        <div class="file-input-wrapper" style="margin-bottom: 1rem;">
            <input type="file" id="labelImageInput" accept="image/*" onchange="handleImageUpload(event)">
            <label for="labelImageInput" class="file-input-label" style="text-align: center; padding: 1rem; border: 2px dashed var(--primary);">
                📁 Upload or Take Photo
            </label>
        </div>
    </div>
    
    <!-- Image preview -->
    <div style="text-align: center;">
        <div id="capturedImage" style="display: none; margin: 1rem 0;">
            <img id="previewImage" style="max-width: 100%; max-height: 400px; border: 2px solid var(--border); border-radius: 0.5rem;">
        </div>
        
        <!-- Simple rotation controls -->
        <div id="rotationControls" style="display: none; margin: 1rem 0;">
            <button type="button" onclick="rotateImage(-90)" style="margin: 0 0.5rem;">↺ Rotate Left</button>
            <button type="button" onclick="rotateImage(90)" style="margin: 0 0.5rem;">↻ Rotate Right</button>
        </div>
    </div>
    
    <!-- Processing progress -->
    <div id="ocrProgress" style="display: none; text-align: center; color: var(--primary); margin: 1rem 0; padding: 1rem; background: var(--card-bg); border-radius: 0.5rem;">
        <div style="margin-bottom: 0.5rem;">Processing image...</div>
        <div style="background: var(--dark-bg); border-radius: 1rem; height: 8px; overflow: hidden; margin-bottom: 0.5rem;">
            <div id="ocrProgressBar" style="background: var(--primary); height: 100%; width: 0%; transition: width 0.3s;"></div>
        </div>
        <span id="ocrProgressPercent">0%</span>
    </div>
    
    <!-- Extracted information display -->
    <div id="extractedInfo" style="display: none; background: var(--card-bg); padding: 1rem; border-radius: 0.5rem; margin: 1rem 0; border: 1px solid var(--success);">
        <h4 style="color: var(--success); margin-bottom: 0.5rem;">📋 Extracted Information:</h4>
        <div style="margin-bottom: 0.5rem;"><strong>Name:</strong> <span id="extractedName">-</span></div>
        <div><strong>MRN:</strong> <span id="extractedMRN">-</span></div>
    </div>
    
    <!-- Debug info -->
    <div id="debugInfo" style="display: none; background: var(--dark-bg); padding: 0.75rem; border-radius: 0.25rem; margin: 1rem 0; font-family: monospace; font-size: 0.8rem; max-height: 200px; overflow-y: auto;">
        <div style="color: var(--text-secondary); margin-bottom: 0.5rem;"><strong>Raw OCR Text:</strong></div>
        <div id="debugText" style="color: var(--text-primary);"></div>
    </div>
    
    <!-- Action buttons -->
    <div class="nav-buttons">
        <button id="processBtn" type="button" onclick="processCurrentImage()" style="display: none;">🔍 Process Image</button>
        <button id="addExtractedBtn" type="button" onclick="addExtractedPatient()" style="display: none; background: linear-gradient(135deg, var(--success), #059669);">➕ Add Patient</button>
        <button type="button" onclick="toggleDebugInfo()">🐛 Toggle Debug</button>
        <button type="button" onclick="backToEntrySelection()">← Back</button>
    </div>
</div>
		

		







		

		
    </div>
</div>

		






















		




	    


        <!-- Details View -->
        <div class="details-view" id="detailsView">
            <div class="details-header">
                <div id="stickyTextContainer" class="sticky-text"></div>
                <div class="view-selector">
                    <button class="view-button active" onclick="switchView('basic')">Details</button>
                    <button class="view-button" onclick="switchView('chartcheck')">📊 Chart Check</button>
                    <button class="view-button" onclick="switchView('consult')">Consult Mode</button>
                </div>
            </div>

            <form id="editForm"></form>

            <div class="nav-buttons">
                <button id="prevButton" onclick="navigateDetails(-1)">← Previous</button>
                <button id="nextButton" onclick="navigateDetails(1)">Next →</button>
                <button onclick="backToList()">Back to List</button>
                <button class="delete-button" onclick="deleteCurrentEntry()">🗑️ Delete Entry</button>
            </div>

            <!-- Consult-specific buttons (shown in consult mode) -->
            <div id="consultControls" class="hidden">
                <div class="nav-buttons">
                    <button id="convertTypeBtn" onclick="convertEntryType()">Convert to Patient</button>
                    <button onclick="exportToRTF('consult')"> Consult Note</button>
                    <button onclick="exportToRTF('trauma')"> Trauma Note</button>
		    <button onclick="showStaffPresentation()">Staff</button>

                </div>
            </div>
        </div>
    </div>



	<!-- Import Data Modal -->
<div id="importModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeImportModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
        <h2>Import Lab Data</h2>
        <div class="nav-buttons" style="margin-bottom: 1rem;">
            <button onclick="pasteFromClipboard()">📋⚡ Paste & Process</button>
            <button onclick="processImportedData()">Process Data</button>
        </div>
        <textarea id="importData" class="import-textarea" placeholder="Paste your vitals, labs, and meds data here..."></textarea>
    </div>
</div>

	


	
    <!-- Table View Modal -->
    <div id="tableModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeTableModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2>Lab Values Table</h2>
            <div id="tableContainer"></div>
        </div>
    </div>














<!-- Graph View Modal -->
<div id="graphModal" class="modal">
        <div class="modal-content large-modal">
        <span class="close" onclick="closeGraphModal()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
        <h2>Vital Signs Table</h2> <!-- Changed from "Vital Signs Graphs" -->
        <!-- Remove the button div -->
        <div id="vitalChart" style="width: 100%; overflow-x: auto;"></div> <!-- Changed to div for table -->
    </div>
</div>
	
<!-- Help Modal -->
<div id="helpModal" class="help-modal">
    <div class="help-modal-content">
        <div class="help-modal-header">
            <h2 id="helpModalTitle" class="help-modal-title">Help & Instructions</h2>
            <button class="help-modal-close" onclick="closeHelpModal()">&times;</button>
        </div>
        <div id="helpModalBody" class="help-modal-body">
            <!-- Content will be inserted here -->
        </div>
    </div>
</div>











    <!-- Include Papa Parse and Chart.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>

    <script>
        // ============ GLOBAL VARIABLES ============
        let patientData = [];
        let currentPatientIndex = -1;
        let currentViewMode = 'basic'; // basic, chartcheck, consult
        let selectedColumns = [1, 2, 3, 19]; // Default to Name, RM, MRN, To do
        let filteredIndexes = [];
        let labData = {};
        let lastImportedData = '';
        let fullOrdersText = '';
        let showFullOrders = false;
        let currentChart = null;
		let currentSortColumn = ''; // Track current sort column
		let violinRedStylingApplied = false; // Add this flag
		let tempChecklistStates = {}; // Temporary checklist states


        // Master headers structure
        const MASTER_HEADERS = [
            'Type',      // "Patient" or "Consult"
            'Name',      
            'RM',        
            'MRN',       
            'Att',       
            'A/G',       // Age/Gender - Consult only
            'CC',        // Chief Complaint - Consult only
            'Problems',  // Patient only (maps to HPI for consults)
            'HPI',       // Consult only
            'ROS',       // Consult only
            'PMH',       // Consult only
            'Meds',      // Consult only
            'All',       // Allergies - Consult only
            'Surg hx',   // Consult only
            'FSH',       // Family/Social History - Consult only
            'ICS',       
            'VIOLIN',    
            'PE',        // Physical Exam - Consult only
            'ORDERS',    
            'To do',     
            'Priority',
            // Chart Check specific fields (stored but not shown in basic view)
            'ImportedData', // Store raw imported data
            'LabData'       // Store processed lab data
        ];

        const PATIENT_COLUMNS = [0, 1, 2, 3, 4, 7, 15, 16, 18, 19, 20];
        const CONSULT_COLUMNS = [0, 1, 2, 3, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20];

        const colors = [
            'colored-text-1', 'colored-text-2', 'colored-text-3',
            'colored-text-4', 'colored-text-5'
        ];


// Help Tips for Modal 
const helpContent = {
    'Problems': '<b>A/G</b><br><br>• DX<br> HPI <br> PMH:<br>',
    'ICS': '<ul><li><strong>Diagnostic imaging</strong></li><li><strong>Pathology + Microbiology</strong></li>  <li><strong>Overnight events</strong></li><li><strong>Latest consult notes</strong></li><li><strong>Procedures/Interventions</strong></li><li><strong>Non Primary: plan of care</strong></li></ul>',
    'VIOLIN': '<ul><li><strong>Vitals (HR, SBP, DBP, MAP, Temp, RR, SPO2, O2 therapy, Vent: Mode, RR, Vt, PEEP, FIO2, PIP, ETCO2, Cardiac: CVP, PASP/PADP, PAMAP, CO, CI, SvO2, SV, SVI, SVR) </strong></li> <li><strong> Intake (Blood products, oral, IVF, meds, tube feeds) and Outputs (BM, ostomy, urostomy, drains/tubes, UOP, emesis, blood loss, dialysis), Fluid balance </strong></li> <li><strong> CBC and left shift, BMP, Ca, Mg, P, Tbil, Dbili, ALK, GGT, AST/ALT, PT, PTT, INR, pH, PO2, PCO2, Bicarb, Base excess, Lactate, Trops, Misc: albumin, prealbumin, Procal, UA, Urine studies</strong></li><li><strong>Replete electrolytes: electrolytes</strong></li></ul> <strong><li> Primary review of imaging: https://docs.google.com/document/d/12lbPO5K7jMPhruuoedT-piCaQSr9dja2OObAeMD2NWk/edit?tab=t.0 </li> </strong>',
'ORDERS': '<ul><li><strong>Renew orders</strong></li><li><strong>Nutrition/fluids:</strong><ul><li><strong>Diet order/IVFs/tube feeds/TPN</strong></li></ul></li><li><strong>Pain medications:</strong></li><li><strong>LTD:</strong><ul><li><strong>Orders for any lines (central line, PICC, peripheral IVs, arterial line, chest tubes, drains, ports, NG tubes, respiratory support NC or facemask, ETT)</strong></li><li><strong>Inc. Types of trach and size ex. #8 cuffed subglottic tracheostomy, date placed</strong></li><li><strong>Record accurate outputs, suction/maintenance settings ex. CT -20 mmHg suction, quality of output</strong></li></ul></li><li><strong>Antibiotics/special medications/home meds:</strong><ul><li><strong>Note any IV or oral antibiotics or special therapies and the duration required.</strong></li><li><strong>Record doses of all pressors and sedation</strong></li></ul></li><li><strong>Anticoagulation/DVT prophylaxis:</strong><ul></ul></li><li><strong>Disposition</strong></li></ul>',   
	'Priority': '',
    'CC': '<b>Chief Complaint/Level</b><br><br>• Primary reason for consultation<br>• Trauma level if applicable<br>• Brief description of problem',
'HPI': '<ul><li><strong>Trauma</strong><ul><li><strong>Time of injury</strong></li><li><strong>Mechanism:</strong> MVC/MCC: Speed, Location of force transfer</li><li><strong>Seatbelt / helmet / airbags / protective devices</strong></li><li><strong>Post-injury course</strong></li><li><strong>Identified injuries</strong></li><li><strong>Therapies/interventions</strong></li></ul></li><li><strong>STORY → !!FOCUS ON WHAT IS RELEVANT TO THE SURGICAL CONSULTATION!! → WHAT IS THE DDX before seeing, and what possible surgical interventions or assistance may actually be required?</strong><ul><li><strong>Onset</strong><ul><li><strong>Sequence of events and why presenting today, Preceding Events</strong></li><li><strong>Where coming from</strong></li><li><strong>What did they do there? Interventions, medications, studies, consultations</strong></li><li><strong>If they have tubes, drains or devices are they functioning? What has the outputs been?</strong></li></ul></li><li><strong>Palliating, provoking</strong></li><li><strong>Quality, radiation, severity</strong></li><li><strong>Prior episodes, evolution over time</strong></li></ul></li></ul>',
	'ROS': '<ul><li><strong>ROS</strong></li><li><strong>Constitutional: fever, chills, night sweats, weight loss, anorexia (last MEAL), travel, sick contacts, diet changes (traveling guy, sun overhead, get tired, vacation)</strong></li><li><strong>Neurologic: headache, dizziness, numbness, tingling, weakness, presyncope/syncope, tremors, convulsions/ seizures, unsteady gait (head)</strong></li><li><strong>Skin: Jaundice, rash, lesions, petechiae, itching (sunburnt)</strong></li><li><strong>ENMT: vision changes, hearing changes, ear or eye pain, sore throat, congestion, runny nose, hoarseness, dysphagia (eyes/ears)</strong></li><li><strong>Respiratory: shortness of breath, cough, wheezing (chest)</strong></li><li><strong>Cardiovascular: chest pain, palpitations (chest)</strong></li><li><strong>Gastrointestinal: nausea, vomiting, last BM and gas: change in bowel habits, abdominal pain, (stomach, colon)</strong></li><li><strong>Genitourinary: dysuria, urine retention (last void: ), hematuria, discharge (groin)</strong></li><li><strong>Musculoskeletal: pain, joint swelling, stiffness, myalgias, trauma</strong></li><li><strong>Psychiatric: anxiety, depression, restlessness, suicidal ideation</strong></li><li><strong>Heme/Lymph: bleeding tendency, bruising tendency, petechiae, swollen nodes</strong></li><li><strong>Menstrual: LMP, menopausal</strong></li></ul>',
    'PMH': '<b>Past Medical History</b><br><br>• Previous diagnoses<br>• Chronic conditions<br>• Previous surgeries',
    'Meds': '<b>Current Medications</b><br><br>• Home medications<br>• Current hospital medications<br>• Allergies',
    'All': '<b>Allergies</b><br><br>• Drug allergies<br>• Environmental allergies<br>• Type of reaction',
	'PE': '<strong>Clinical Examination:</strong></div><ul><li><strong>Gen: Well appearing in no acute distress. Alert and oriented x3.</strong></li><li><strong>Neuro: strength and sensation intact BUE+BLE, CN II-XII grossly intact, EOMI</strong></li><li><strong>Resp: Non-labored breathing. No use of accessory muscles, no retractions.</strong></li><li><strong>CV: Hemodynamically stable</strong></li><li><strong>Pulse: palpable b/l DP/PT pulses, radial/ulnar pulses</strong></li><li><strong>Abd: soft, non tender, non distended, no voluntary or involuntary guarding, no rebound or jolt tenderness</strong></li><li><strong>Wound: Incisions clean, dry, intact.</strong></li><li><strong>LTD:</strong></li></ul><div><strong>Trauma Examination:</strong></div><ul><li><strong>Head: Normocephalic, atraumatic, no deformities, abrasions, tenderness, oropharynx clear, no blood in nares or ears, hearing intact</strong></li><li><strong>Neuro: GCS 15, Pupils equal and reactive to light bilaterally, extraocular muscles intact. gross motor and sensory intact in all 4 extremities.</strong></li><li><strong>Face: Atraumatic, no deformities, abrasions, tenderness</strong></li><li><strong>Chest: clear to auscultation bilaterally, non-tender, atraumatic, Pulling _ On incentive spirometer</strong></li><li><strong>CVS: RRR, hemodynamically stable</strong></li><li><strong>Abdomen: soft, non-tender, non-distended, no voluntary or involuntary guarding, no jolt or rebound tenderness</strong></li><li><strong>Pelvis: Stable</strong></li><li><strong>Upper Extremities: Atraumatic, no deformities, abrasions, tenderness, Bilateral radial pulses palpable, brisk capillary refill</strong></li><li><strong>Lower Extremities: Atraumatic, no deformities, abrasions, tenderness, brisk capillary refill, Bilateral femoral, DP, PT pulses palpable.</strong></li><li><strong>Spine: No obvious cervical, lumbar, or thoracic spine deformities, no step offs, no tenderness, trachea midline</strong></li><li><strong>Perineum: No gross blood in the perineum, rectal exam deferred, anal wink reflex intact</strong></li>',
'To do': 'INTERACTIVE_CHECKLIST', 
'Plan': '<h3>Nutrition/Fluids</h3><ul><li><strong>NPO considerations</strong><ul><li><strong>if NPO may need fluids</strong></li><li><strong>Speech and swallow consult for concern for dysphagia or older patients with cervical spine injury</strong></li></ul></li><li><strong>TPN/PPN</strong><ul><li><strong>Used when there are contraindications to EN</strong></li><li><strong>Critically Ill: Within 36 to 48 hours</strong></li><li><strong>Noncritically ill postoperative patients: After at least five days, usually at 14 days</strong></li><li><strong>Chronic malnutrition and anticipated prolonged bowel rest: Can be earlier than five to seven days</strong></li><li><strong>Daily order needs to be cosigned</strong></li><li><strong>Ensure fat emulsion is ordered</strong></li><li><strong>Need central access for TPN</strong></li><li><strong>Note rate</strong></li></ul></li><li><strong>TF</strong><ul><li><strong>Indications</strong></li><li><strong>Severe dysphagia (may need postpyloric access to reduce aspiration risk)</strong></li><li><strong>Persisted for at least two weeks and expected to persist for at least four weeks</strong></li><li><strong>Requirement of mechanical ventilation for 4 weeks or more (NG tube 4 weeks or more)</strong></li><li><strong>Note feeding rate versus goal rate</strong></li><li><strong>If via cortrack consider PEG</strong></li></ul></li><li><strong>Maintenance fluid rate: <a href="https://www.mdcalc.com/calc/72/maintenance-fluids-calculations" target="_blank">https://www.mdcalc.com/calc/72/maintenance-fluids-calculations</a></strong></li></ul><h3>Pain Management</h3><ul><li><strong>Convert all IV pain meds to oral when possible</strong></li><li><strong>Check MAR for frequency of requests for pain meds</strong></li><li><strong>Order standing non opioid pain meds for all patients on PRN opioids.</strong></li></ul><h3>LTD</h3><ul><li><strong>Make plan to remove drains/tubes.</strong></li><li><strong>Tracheostomy indicated for prolonged mechanical ventilation (&gt;10 days) unlikely to wean (max duration 3 weeks on ETT)</strong></li></ul><h3>Antibiotics/Special Meds</h3><ul><li><strong>Order Vancomycin/medication trough levels</strong></li><li><strong>Find out end date of antibiotics, wean off pressors and sedation. Otherwise set up long term antibiotic IV access if needed</strong></li><li><strong>Ensure all home meds are restarted if appropriate</strong></li></ul><h3>Anticoagulation</h3><ul><li><strong>Check/start dvt prophylaxis or home AC ex. aspirin/plavix when appropriate</strong></li><li><strong>.dvt_url for trauma patients</strong></li></ul><h3>Discharge</h3><ul><li><strong>PT/OT consult for all elderly debilitated patients postoperatively</strong></li><li><strong>Text SW/IDT daily with update for all primary patients</strong></li><li><strong>Special orders</strong><ul><li><strong>VNS: help with dressing changes, wound vacs, home medication review, vital signs monitoring</strong></li><li><strong>Home wound vac services</strong></li><li><strong>Home PT/OT</strong></li><li><strong>Home infusion services</strong></li><li><strong>Transportation/Medical</strong></li></ul></li></ul><h3>Adjuncts</h3><ul><li><strong>Urine retention-&gt; Foley, bladder scan, flomax</strong></li><li><strong>Constipation-&gt; senna, colace, miralax, suppository, enema</strong></li><li><strong>Nausea/vomiting-&gt; zofran, reglan, compazine, NGT</strong></li><li><strong>CXRs/KUBs</strong></li></ul>', 
	
};

		
		

        // ============ INITIALIZATION ============
        window.onload = function() {
            loadFromLocalStorage();
            setupEventListeners();
            updateCensus();
            
           
        };

        function setupEventListeners() {
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        }



	

        // ============ DATA MANAGEMENT ============
        function saveToLocalStorage() {
            try {
                const dataToSave = {
                    version: '2.0',
                    timestamp: new Date().toISOString(),
                    patients: patientData
                };
                localStorage.setItem('ultimatePatientList', JSON.stringify(dataToSave));
                

            } catch (e) {
                console.error('Error saving to localStorage:', e);
            }
        }










		function loadFromLocalStorage() {
    try {
        const saved = localStorage.getItem('ultimatePatientList');
        if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.patients && Array.isArray(parsed.patients)) {
                patientData = parsed.patients;
                displayRows();
                populateColumnSelector();
                populateColumnSelect();
                updateCensus();
            }
        }
        
        // LOAD CHECKLIST STATES
        const savedChecklists = localStorage.getItem('checklistStates');
        if (savedChecklists) {
            tempChecklistStates = JSON.parse(savedChecklists);
        }
    } catch (e) {
        console.error('Error loading from localStorage:', e);
    }
}




		



		function handleFileUpload(event) {
    const file = event.target.files[0];
    if (file) {
        const fileName = file.name.toLowerCase();
        const reader = new FileReader();
        
        if (fileName.endsWith('.csv')) {
            // Handle CSV file
            reader.onload = function(e) {
                try {
                    const csvText = e.target.result;
                    const importedPatients = parseCSVData(csvText);
                    
                    if (importedPatients && importedPatients.length > 0) {
                        // Ask user if they want to replace or append
                        const replace = confirm(`Found ${importedPatients.length} patients in CSV.\n\nClick OK to REPLACE current list, or Cancel to ADD to current list.`);
                        
                        if (replace) {
                            patientData = importedPatients;
                        } else {
                            patientData = patientData.concat(importedPatients);
                        }
                        
                        displayRows();
                        populateColumnSelector();
                        populateColumnSelect();
                        saveToLocalStorage();
                        updateCensus();
                        alert(`Successfully imported ${importedPatients.length} patients from CSV!`);
                    } else {
                        alert('No valid patient data found in CSV file.');
                    }
                } catch (error) {
                    alert('Error parsing CSV file: ' + error.message);
                    console.error('Error parsing CSV:', error);
                }
            };
            reader.readAsText(file);
        } else if (fileName.endsWith('.json')) {
            // Handle JSON file (existing logic)
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    
                    if (jsonData.patients && Array.isArray(jsonData.patients)) {
                        patientData = jsonData.patients;
                    } else if (Array.isArray(jsonData)) {
                        patientData = jsonData;
                    } else {
                        alert('Invalid JSON format');
                        return;
                    }
                    
                    displayRows();
                    populateColumnSelector();
                    populateColumnSelect();
                    saveToLocalStorage();
                    updateCensus();
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                    console.error('Error parsing JSON:', error);
                }
            };
            reader.readAsText(file);
        } else {
            alert('Please select a JSON or CSV file.');
        }
    }
}



		

        function exportData() {
    // Show export options modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content">
            <h2>Export Data</h2>
            <div class="nav-buttons">
                <button onclick="exportJSON(); this.closest('.modal').remove()">Export as JSON</button>
                <button onclick="exportCSV(); this.closest('.modal').remove()">Export as CSV</button>
                <button onclick="this.closest('.modal').remove()">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}











function exportJSON() {
    if (patientData.length === 0) {
        alert('No data to export');
        return;
    }
    
    const dataToExport = {
        version: '2.0',
        exportDate: new Date().toISOString(),
        patients: patientData
    };
    
    // Create filename with format: list_M.D.YY
    const now = new Date();
    const month = now.getMonth() + 1; // No padding, just the number
    const day = now.getDate();
    const year = String(now.getFullYear()).slice(-2); // Last 2 digits of year
    const filename = `list_${month}.${day}.${year}.json`;
    
    downloadFile(JSON.stringify(dataToExport, null, 2), filename, 'application/json');
}

















	    



	    

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============ UI FUNCTIONS ============
        function updateCensus() {
            document.getElementById('censusCount').textContent = patientData.length;
        }

























		// Function to calculate checklist completion status
function getChecklistStatus(patient, patientIndex) {
    const patientKey = `${patientIndex}_${patient.Name || 'unnamed'}`;
    const isTrauma = patient.Type !== 'Consult';
    
    // Define item counts for each checklist type
    const traumaItemCount = 17; // Based on your traumaItems array
    const consultItemCount = 11; // Based on your consultItems array
    const totalItems = isTrauma ? traumaItemCount : consultItemCount;
    
    // Check if patient has any checklist state
    if (!tempChecklistStates[patientKey]) {
        return { completed: 0, total: totalItems, percentage: 0 };
    }
    
    const states = tempChecklistStates[patientKey];
    const completed = Object.values(states).filter(Boolean).length;
    const percentage = Math.round((completed / totalItems) * 100);
    
    return { completed, total: totalItems, percentage };
}











		function getPriorityStatus(patient) {
    const priority = patient.Priority || '';
    
    if (!priority.trim()) {
        return { color: 'var(--card-bg)', title: 'No priority set' }; // Gray
    }
    
    const priorityNum = parseInt(priority);
    if (!isNaN(priorityNum)) {
        if (priorityNum === 0) {
            return { color: '#10b981', title: `Priority ${priorityNum} - Complete` }; // Green
        } else if (priorityNum === 1) {
            return { color: '#ef4444', title: `Priority ${priorityNum} - Urgent` }; // Red
        } else if (priorityNum === 2) {
            return { color: '#f97316', title: `Priority ${priorityNum} - High` }; // Orange
        } else if (priorityNum === 3) {
            return { color: '#f59e0b', title: `Priority ${priorityNum} - Medium-High` }; // Amber
        } else if (priorityNum === 4) {
            return { color: '#eab308', title: `Priority ${priorityNum} - Medium` }; // Yellow
        } else if (priorityNum === 5) {
            return { color: '#84cc16', title: `Priority ${priorityNum} - Medium-Low` }; // Lime
        } else if (priorityNum === 6) {
            return { color: '#22c55e', title: `Priority ${priorityNum} - Low-Medium` }; // Light Green
        } else if (priorityNum === 7) {
            return { color: '#06b6d4', title: `Priority ${priorityNum} - Low` }; // Cyan
        } else if (priorityNum === 8) {
            return { color: '#3b82f6', title: `Priority ${priorityNum} - Very Low` }; // Blue
        } else if (priorityNum === 9) {
            return { color: '#8b5cf6', title: `Priority ${priorityNum} - Minimal` }; // Purple
        } else if (priorityNum === 10) {
            return { color: '#a855f7', title: `Priority ${priorityNum} - Lowest` }; // Violet
        } else if (priorityNum > 10) {
            return { color: 'var(--card-bg)', title: `Priority ${priorityNum} - Out of range` }; // Gray
        }
    }
    
    // Text-based priority fallback
    const priorityLower = priority.toLowerCase();
    if (priorityLower.includes('done') || priorityLower.includes('complete')) {
        return { color: '#10b981', title: `${priority} - Complete` }; // Green
    } else if (priorityLower.includes('urgent') || priorityLower.includes('stat')) {
        return { color: '#ef4444', title: `${priority} - Urgent` }; // Red
    } else if (priorityLower.includes('high')) {
        return { color: '#f97316', title: `${priority} - High` }; // Orange
    } else if (priorityLower.includes('medium')) {
        return { color: '#f59e0b', title: `${priority} - Medium` }; // Amber
    } else if (priorityLower.includes('low')) {
        return { color: '#22c55e', title: `${priority} - Low` }; // Light Green
    }
    
    return { color: 'var(--card-bg)', title: `${priority}` }; // Default gray
}











function generateStatusIndicator(patient, index) {
    // Check if this should be grey (not a consult and no priority)
    const consultFields = ['CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'PE'];
    const hasConsultData = consultFields.some(field => patient[field] && patient[field].trim());
    const hasPriority = patient.Priority && patient.Priority.trim();
    
    // If no consult data and no priority, show grey
    if (!hasConsultData && !hasPriority) {
        return `
            <div class="status-dot" 
                 style="background: var(--card-bg); border: none;" 
                 title="No consult data or priority assigned">
            </div>`;
    }
    
    // STATUS IS NOW BASED PURELY ON PRIORITY NUMBER
    const priority = patient.Priority || '';
    const priorityNum = parseInt(priority);
    
    let color = 'var(--card-bg)'; // Default grey
    let title = 'No priority set';
    
   if (!isNaN(priorityNum)) {
    if (priorityNum === 0) {
        color = '#00ff41'; // Bright neon green - Complete
        title = `Priority ${priorityNum} - Complete`;
    } else if (priorityNum === 1) {
        color = '#ff0040'; // Bright neon red - Urgent  
        title = `Priority ${priorityNum} - Urgent`;
    } else if (priorityNum === 2) {
        color = '#ff6600'; // Bright neon orange - High
        title = `Priority ${priorityNum} - High`;
    } else if (priorityNum === 3) {
        color = '#ffaa00'; // Bright neon amber - Medium-High
        title = `Priority ${priorityNum} - Medium-High`;
    } else if (priorityNum === 4) {
        color = '#ffff00'; // Bright neon yellow - Medium
        title = `Priority ${priorityNum} - Medium`;
    } else if (priorityNum === 5) {
        color = '#ccff00'; // Bright neon lime - Medium-Low
        title = `Priority ${priorityNum} - Medium-Low`;
    } else if (priorityNum === 6) {
        color = '#66ff00'; // Bright neon chartreuse - Low-Medium
        title = `Priority ${priorityNum} - Low-Medium`;
    } else if (priorityNum === 7) {
        color = '#00ffff'; // Bright neon cyan - Low
        title = `Priority ${priorityNum} - Low`;
    } else if (priorityNum === 8) {
        color = '#0080ff'; // Bright neon blue - Very Low
        title = `Priority ${priorityNum} - Very Low`;
    } else if (priorityNum === 9) {
        color = '#8000ff'; // Bright neon purple - Minimal
        title = `Priority ${priorityNum} - Minimal`;
    } else if (priorityNum === 10) {
        color = '#ff00ff'; // Bright neon magenta - Lowest
        title = `Priority ${priorityNum} - Lowest`;
    } else {
        color = 'var(--card-bg)'; // Dark grey for out of range
        title = `Priority ${priorityNum} - Out of range`;
    }
} else if (priority.trim()) {
    // Text-based priority fallback with neon colors
    const priorityLower = priority.toLowerCase();
    if (priorityLower.includes('done') || priorityLower.includes('complete')) {
        color = '#00ff41'; // Bright neon green
        title = `${priority} - Complete`;
    } else if (priorityLower.includes('urgent') || priorityLower.includes('stat')) {
        color = '#ff0040'; // Bright neon red
        title = `${priority} - Urgent`;
    } else if (priorityLower.includes('high')) {
        color = '#ff6600'; // Bright neon orange
        title = `${priority} - High`;
    } else if (priorityLower.includes('medium')) {
        color = '#ffaa00'; // Bright neon amber
        title = `${priority} - Medium`;
    } else if (priorityLower.includes('low')) {
        color = '#00ffff'; // Bright neon cyan
        title = `${priority} - Low`;
    } else {
        color = 'var(--card-bg)'; // Medium grey for unrecognized text
        title = `${priority}`;
    }
}
    
    return `
        <div class="status-dot" 
             style="background: ${color};" 
             title="${title}">
        </div>`;
}
		
		











		






  function displayRows() {
    const rowList = document.getElementById('rowList');
    rowList.innerHTML = '';
    
    patientData.forEach((patient, index) => {
        const listItem = document.createElement('li');
        listItem.className = 'row-item';
        
        // Create content container
        const contentContainer = document.createElement('div');
        contentContainer.style.width = '100%';
        contentContainer.style.display = 'flex';
        contentContainer.style.alignItems = 'center';
        contentContainer.style.position = 'relative';
        contentContainer.style.paddingRight = '3.5rem'; // Space for clipboard button
        
        // Add status dot at the beginning (left side)
        const statusDot = document.createElement('div');
        statusDot.innerHTML = generateStatusIndicator(patient, index);
        statusDot.style.position = 'absolute';
        statusDot.style.left = '0rem'; // Left justified
        statusDot.style.top = '50%';
        statusDot.style.transform = 'translateY(-50%)';
        statusDot.style.cursor = 'pointer';
        statusDot.style.zIndex = '10';
        statusDot.title = 'Click to change status';
        statusDot.onclick = (e) => {
            e.stopPropagation();
            showStatusSelector(patient, index, statusDot);
        };
        contentContainer.appendChild(statusDot);
        
        // Display the selected columns vertically with proper left margin
        const columnsDiv = document.createElement('div');
        columnsDiv.style.flex = '1';
        columnsDiv.style.marginLeft = '0.9rem'; // THIS IS THE KEY - creates space between dot and text
        columnsDiv.style.paddingLeft = '0rem'; // Additional padding for visual comfort
        
        selectedColumns.forEach((colIndex, idx) => {
            const header = MASTER_HEADERS[colIndex];
            const value = patient[header] || '';
            if (value) {
                const span = document.createElement('span');
                span.className = colors[idx % colors.length];
                span.textContent = value;
                span.style.display = 'block';
                columnsDiv.appendChild(span);
            }
        });
        
        contentContainer.appendChild(columnsDiv);
        
        // Add clipboard button
        const clipboardBtn = document.createElement('button');
        clipboardBtn.className = 'clipboard-btn';
        clipboardBtn.innerHTML = '📋';
        clipboardBtn.title = 'Copy patient info';
        clipboardBtn.onclick = (e) => {
            e.stopPropagation();
            copyPatientInfo(patient, clipboardBtn);
        };
        
        contentContainer.appendChild(clipboardBtn);
        listItem.appendChild(contentContainer);
        
        // Make the row clickable
        columnsDiv.onclick = () => showDetails(index);
        
        rowList.appendChild(listItem);
    });
    
    updateCensus();
}















        function displayFilteredRows(filteredData) {
            const rowList = document.getElementById('rowList');
            rowList.innerHTML = '';

            if (filteredData.length === 0) {
                const noResultsItem = document.createElement('li');
                noResultsItem.className = 'row-item';
                noResultsItem.style.textAlign = 'center';
                noResultsItem.style.color = 'var(--text-secondary)';
                noResultsItem.textContent = 'No results found';
                rowList.appendChild(noResultsItem);
            } else {
                filteredData.forEach((patient, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'row-item';
                    
                    // Display the selected columns vertically
                    selectedColumns.forEach((colIndex, idx) => {
                        const header = MASTER_HEADERS[colIndex];
                        const value = patient[header] || '';
                        if (value) {
                            const span = document.createElement('span');
                            span.className = colors[idx % colors.length];
                            span.textContent = value;
                            span.style.display = 'block';
                            listItem.appendChild(span);
                        }
                    });
                    
                    const originalIndex = filteredIndexes[index];
                    listItem.onclick = () => showDetails(originalIndex);
                    
                    rowList.appendChild(listItem);
                });
            }
        }

        function populateColumnSelector() {
            const columnSelector = document.getElementById('columnSelector');
            columnSelector.innerHTML = '';
            MASTER_HEADERS.slice(0, -2).forEach((header, colIndex) => {
                const button = document.createElement('div');
                button.className = 'column-button';
                button.textContent = header;
                if (selectedColumns.includes(colIndex)) {
                    button.classList.add('selected');
                }
                button.onclick = () => toggleColumnSelection(colIndex, button);
                columnSelector.appendChild(button);
            });
        }

        function toggleColumnSelection(colIndex, button) {
            if (selectedColumns.includes(colIndex)) {
                selectedColumns = selectedColumns.filter(col => col !== colIndex);
                button.classList.remove('selected');
            } else {
                if (selectedColumns.length < 5) { // Limit to 5 columns
                    selectedColumns.push(colIndex);
                    selectedColumns.sort((a, b) => a - b);
                    button.classList.add('selected');
                } else {
                    alert('Maximum 5 columns can be selected');
                }
            }
            displayRows();
        }

        function populateColumnSelect() {
            const columnSelect = document.getElementById('columnSelect');
            columnSelect.innerHTML = '<option value="">Sort by</option>';
            MASTER_HEADERS.slice(0, -2).forEach((header, index) => {
                const option = document.createElement('option');
                option.value = header;
                option.textContent = header;
                columnSelect.appendChild(option);
            });
        }









	    function sortRows() {
    const column = document.getElementById('columnSelect').value;
    if (column) {
        // Save the current sort column and show re-sort button
        currentSortColumn = column;
        document.getElementById('resortBtn').style.display = 'inline-block';
        
        patientData.sort((a, b) => {
            const valueA = a[column] || '';
            const valueB = b[column] || '';
            
            // Special handling for Priority column - numerical sort
            if (column === 'Priority') {
                // Convert to numbers, treating empty/non-numeric as Infinity (sort to end)
                const numA = valueA === '' || isNaN(valueA) ? Infinity : parseInt(valueA, 10);
                const numB = valueB === '' || isNaN(valueB) ? Infinity : parseInt(valueB, 10);
                return numA - numB;
            }
            
            // Regular string comparison for other columns
            return valueA.toString().toLowerCase().localeCompare(valueB.toString().toLowerCase());
        });
        displayRows();
    } else {
        // Hide re-sort button if no sort selected
        document.getElementById('resortBtn').style.display = 'none';
        currentSortColumn = '';
    }
}




	    function reSort() {
    if (currentSortColumn) {
        // Set the dropdown to the current sort column
        document.getElementById('columnSelect').value = currentSortColumn;
        // Call the existing sort function
        sortRows();
        
        // Optional: Show a brief confirmation
        const btn = document.getElementById('resortBtn');
        const originalText = btn.textContent;
        btn.textContent = '✓ Sorted!';
        setTimeout(() => {
            btn.textContent = originalText;
        }, 1000);
    }
}


	    




	    

        function resortRows() {
            sortRows();
        }

        function toggleColumnDropdown() {
            const dropdown = document.getElementById('columnDropdown');
            dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
        }

        // ============ SEARCH FUNCTIONS ============
        function toggleSearch() {
            const searchContainer = document.getElementById('searchContainer');
            const searchWrapper = document.querySelector('.search-wrapper');
            
            searchContainer.classList.toggle('active');
            if (searchContainer.classList.contains('active')) {
                searchWrapper.classList.add('expanded');
                document.getElementById('searchInput').focus();
            } else {
                searchWrapper.classList.remove('expanded');
            }
        }

        function searchRows() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
            
            if (!searchTerm) {
                alert("Please enter a search term.");
                return;
            }

            filteredIndexes = [];
            const filteredData = [];

            patientData.forEach((patient, index) => {
                const matchFound = Object.values(patient).some(value => {
                    return (value || '').toString().toLowerCase().includes(searchTerm);
                });
                
                if (matchFound) {
                    filteredIndexes.push(index);
                    filteredData.push(patient);
                }
            });

            displayFilteredRows(filteredData);
        }

        function clearSearch() {
            document.getElementById('searchInput').value = '';
            filteredIndexes = [];
            displayRows();
            const searchWrapper = document.querySelector('.search-wrapper');
            searchWrapper.classList.remove('expanded');
            document.getElementById('searchContainer').classList.remove('active');
        }

        // ============ DETAILS VIEW ============
        function showDetails(index) {
            currentPatientIndex = index;
            const detailsView = document.getElementById('detailsView');
            const patient = patientData[index];
            
            document.getElementById('stickyTextContainer').textContent = patient.Name || 'Unnamed Patient';
            
            // Show appropriate view based on current mode
            switchView(currentViewMode);
            
            detailsView.style.display = 'block';
            updateNavButtons();
        }

        function switchView(mode) {
            currentViewMode = mode;
            const patient = patientData[currentPatientIndex];
            
            // Update active button
            document.querySelectorAll('.view-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`.view-button[onclick*="${mode}"]`).classList.add('active');
            
            // Hide all mode-specific controls
            document.getElementById('consultControls').classList.add('hidden');
            
            // Generate form based on mode
            const form = document.getElementById('editForm');
            form.innerHTML = '';
            
            let fieldsToShow = [];
            
            switch(mode) {
                case 'basic':
                    // Show basic fields for both patient and consult types
                    fieldsToShow = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'To do', 'Priority'];
                    break;








                    
case 'chartcheck':
    // Show chart check fields in split layout
    const chartCheckContainer = document.createElement('div');
    chartCheckContainer.className = 'chart-check-layout';
    
    const leftPanel = document.createElement('div');
    leftPanel.className = 'chart-check-left';
    
    const rightPanel = document.createElement('div');
    rightPanel.className = 'chart-check-right';
    rightPanel.innerHTML = `
        <h3>Plan<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('Plan')">?</button></h3>
        <textarea id="field_To_do" placeholder="Enter patient plan...">${patient['To do'] || ''}</textarea>
    `;
    
    fieldsToShow = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'Priority'];
    
    // Create fields for left panel
    fieldsToShow.forEach(header => {
        // Skip 'To do' as it's in the right panel
        if (header === 'To do') return;
        
        const label = document.createElement('label');
        
        if (helpContent[header]) {
            label.innerHTML = `${header}<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
        } else {
            label.textContent = header;
        }
        
        // CRITICAL: Add warning messages and fishbone BEFORE VIOLIN field
        if (header === 'VIOLIN') {
            // Add warning messages container
            const warningDiv = document.createElement('div');
            warningDiv.id = 'warningMessages';
            warningDiv.className = 'warning-messages hidden';
            leftPanel.appendChild(warningDiv);
            
            // Add fishbone display container
            const fishboneDiv = document.createElement('div');
            fishboneDiv.id = 'fishboneDisplay';
            fishboneDiv.className = 'fishbone-display hidden';
            fishboneDiv.innerHTML = '<h4>VIOLIN Fishbone Diagram</h4><div id="fishboneContent"></div>';
            leftPanel.appendChild(fishboneDiv);
            
            // Create button container
            const btnContainer = document.createElement('div');
            btnContainer.className = 'violin-button-container';
            btnContainer.style.marginLeft = '10px';

            const importBtn = document.createElement('button');
            importBtn.textContent = '⬇️ Import';
            importBtn.onclick = function(e) {
                e.preventDefault();
                showImportModal();
            };
            
            const tableBtn = document.createElement('button');
            tableBtn.textContent = '📊 Labs';
            tableBtn.onclick = function(e) {
                e.preventDefault();
                showTableView();
            };
            
            const graphBtn = document.createElement('button');
            graphBtn.textContent = '📊 Vitals';
            graphBtn.onclick = function(e) {
                e.preventDefault();
                showVitalsTable();
            };

            const fishboneBtn = document.createElement('button');
            fishboneBtn.textContent = '🐟 Fishbone';
            fishboneBtn.onclick = function(e) {
                e.preventDefault();
                toggleFishboneDisplay();
            };
            
            btnContainer.appendChild(importBtn);
            btnContainer.appendChild(tableBtn);
            btnContainer.appendChild(graphBtn);
            btnContainer.appendChild(fishboneBtn);
            label.appendChild(btnContainer);
        }
        else if (header === 'ORDERS') {
            const btnContainer = document.createElement('span');
            btnContainer.style.marginLeft = '10px';
            
            const abbrevBtn = document.createElement('button');
            abbrevBtn.textContent = 'Abbrev Orders';
            abbrevBtn.style.margin = '0 2px';
            abbrevBtn.style.padding = '0.3rem 0.6rem';
            abbrevBtn.style.fontSize = '0.8rem';
            abbrevBtn.onclick = function(e) {
                e.preventDefault();
                updateOrders();
            };
            
            const fullBtn = document.createElement('button');
            fullBtn.textContent = 'Full Orders';
            fullBtn.style.margin = '0 2px';
            fullBtn.style.padding = '0.3rem 0.6rem';
            fullBtn.style.fontSize = '0.8rem';
            fullBtn.onclick = function(e) {
                e.preventDefault();
                toggleOrdersView();
            };
            
            btnContainer.appendChild(abbrevBtn);
            btnContainer.appendChild(fullBtn);
            label.appendChild(btnContainer);
        }
        
        let input;
        if (header === 'Name' || header === 'RM' || header === 'MRN' || header === 'Att' || header === 'Priority') {
            input = document.createElement('input');
            input.type = 'text';
		}
else if (header === 'VIOLIN') {
    input = document.createElement('textarea');
    // Remove contentEditable and inline styles - let CSS handle it
}
        else {
            input = document.createElement('textarea');
        }
            
        input.id = `field_${header.replace(/\s+/g, '_')}`;
        if (header === 'VIOLIN') {
            input.className = 'violin-field';
        }
        
        input.value = patient[header] || '';

        input.addEventListener('input', function() {
            if (header === 'VIOLIN') {
                const plainText = this.textContent || this.innerText || '';
                patient[header] = plainText;
            } else {
                patient[header] = this.value;
            }
            
            if (header === 'Name') {
                const nameValue = header === 'VIOLIN' ? (this.textContent || this.innerText) : this.value;
                document.getElementById('stickyTextContainer').textContent = nameValue || 'Unnamed Patient';
            }
            saveToLocalStorage();
            
            if (input.tagName === 'TEXTAREA') {
                autoResizeTextarea(this);
            }
        });
        
        leftPanel.appendChild(label);
        
        // Add full orders display above ORDERS field
        if (header === 'ORDERS') {
            const fullOrdersDiv = document.createElement('div');
            fullOrdersDiv.id = 'fullOrdersDisplay';
            fullOrdersDiv.className = 'orders-section hidden';
            leftPanel.appendChild(fullOrdersDiv);
        }
        
        leftPanel.appendChild(input);
        
        if (input.tagName === 'TEXTAREA') {
            setTimeout(() => autoResizeTextarea(input), 0);
        } else if (input.contentEditable === 'true' && header === 'VIOLIN') {
            setTimeout(() => autoResizeContentEditable(input), 0);
        }
    });
    
    // Set up To Do textarea event listener
    const todoTextarea = rightPanel.querySelector('#field_To_do');
    todoTextarea.addEventListener('input', function() {
        patient['To do'] = this.value;
        saveToLocalStorage();
    });
    
    chartCheckContainer.appendChild(leftPanel);
    chartCheckContainer.appendChild(rightPanel);
    form.appendChild(chartCheckContainer);
    
    // Load lab data if stored
    if (patient.ImportedData) {
        lastImportedData = patient.ImportedData;
    }
    if (patient.LabData) {
        try {
            labData = JSON.parse(patient.LabData);
        } catch (e) {
            labData = {};
        }
    }
    return; // Exit early to prevent duplicate field creation






                    
                case 'consult':
                    // Show consult fields
                    if (patient.Type === 'Consult') {
                        fieldsToShow = ['Name', 'RM', 'MRN', 'A/G', 'CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'VIOLIN', 'PE', 'To do', 'Priority'];
                    } else {
                        fieldsToShow = ['Name', 'RM', 'MRN', 'Att', 'Problems', 'ICS', 'VIOLIN', 'ORDERS', 'To do', 'Priority'];
                    }
                    document.getElementById('consultControls').classList.remove('hidden');
                    updateConvertButton();
                    break;
            }


			fieldsToShow.forEach(header => {
    const label = document.createElement('label');

if (currentViewMode === 'consult' && CONSULT_MODE_LABELS[header]) {
    if (helpContent[header]) {
        label.innerHTML = `${CONSULT_MODE_LABELS[header]}<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
    } else {
        label.textContent = CONSULT_MODE_LABELS[header];
    }
} else {
    if (helpContent[header]) {
        label.innerHTML = `${header}<button class="help-button" onclick="event.stopPropagation(); event.preventDefault(); showHelpModal('${header}')">?</button>`;
    } else {
        label.textContent = header;
    }
}

				
				


		    
                
                // Add buttons for specific fields in chart check mode
                if (currentViewMode === 'chartcheck') {
                    if (header === 'Problems') {
                        const podBtn = document.createElement('button');
                        podBtn.textContent = 'Update POD';
                        podBtn.style.marginLeft = '10px';
                        podBtn.style.padding = '0.3rem 0.6rem';
                        podBtn.style.fontSize = '0.8rem';
                        podBtn.onclick = function(e) {
                            e.preventDefault();
                            updatePOD();
                        };
                        label.appendChild(podBtn);
                    
						
					
					} else if (header === 'VIOLIN') {
    // Add warning messages before VIOLIN field
    const warningDiv = document.createElement('div');
    warningDiv.id = 'warningMessages';
    warningDiv.className = 'warning-messages hidden';
    leftPanel.appendChild(warningDiv);
    
    // Create button container with special class for mobile styling
    const btnContainer = document.createElement('div');
    btnContainer.className = 'violin-button-container';
    btnContainer.style.marginLeft = '10px';
    
    const importBtn = document.createElement('button');
    importBtn.textContent = '⬇️ Import';
    importBtn.onclick = function(e) {
        e.preventDefault();
        showImportModal();
    };
    
    const tableBtn = document.createElement('button');
    tableBtn.textContent = '📊 Labs';
    tableBtn.onclick = function(e) {
        e.preventDefault();
        showTableView();
    };
    
    const graphBtn = document.createElement('button');
    graphBtn.textContent = '📊 Vitals';
    graphBtn.onclick = function(e) {
        e.preventDefault();
        showVitalsTable();
    };
    
    btnContainer.appendChild(importBtn);
    btnContainer.appendChild(tableBtn);
    btnContainer.appendChild(graphBtn);
    label.appendChild(btnContainer);
}
					
					else if (header === 'ORDERS') {
                        const btnContainer = document.createElement('span');
                        btnContainer.style.marginLeft = '10px';
                        
                        const abbrevBtn = document.createElement('button');
                        abbrevBtn.textContent = 'Abbrev Orders';
                        abbrevBtn.style.margin = '0 2px';
                        abbrevBtn.style.padding = '0.3rem 0.6rem';
                        abbrevBtn.style.fontSize = '0.8rem';
                        abbrevBtn.onclick = function(e) {
                            e.preventDefault();
                            updateOrders();
                        };
                        
                        const fullBtn = document.createElement('button');
                        fullBtn.textContent = 'Full Orders';
                        fullBtn.style.margin = '0 2px';
                        fullBtn.style.padding = '0.3rem 0.6rem';
                        fullBtn.style.fontSize = '0.8rem';
                        fullBtn.onclick = function(e) {
                            e.preventDefault();
                            toggleOrdersView();
                        };
                        
                        btnContainer.appendChild(abbrevBtn);
                        btnContainer.appendChild(fullBtn);
                        label.appendChild(btnContainer);
                    }
                }
                
let input;
if (header === 'Name' || header === 'RM' || header === 'MRN' || header === 'Att' || header === 'Priority') {
    input = document.createElement('input');
}
else if (header === 'VIOLIN') {
    input = document.createElement('textarea');
    // Remove contentEditable and inline styles - let CSS handle it
}
else {
    input = document.createElement('textarea');
}



                    
                if (input.tagName === 'INPUT') {
                    input.type = 'text';
                }
                
                input.id = `field_${header.replace(/\s+/g, '_')}`;


// Set initial content
if (header === 'VIOLIN') {
    const content = patient[header] || '';
    // If content has HTML spans, use innerHTML to preserve red formatting
    if (content.includes('<span')) {
        input.innerHTML = content;
    } else {
        input.textContent = content;
    }
} else {
    input.value = patient[header] || '';
}



				

input.addEventListener('input', function() {
    patient[header] = this.value;
    
    if (header === 'Name') {
        document.getElementById('stickyTextContainer').textContent = this.value || 'Unnamed Patient';
    }
    saveToLocalStorage();
    
    if (input.tagName === 'TEXTAREA') {
        autoResizeTextarea(this);
    }
});




                form.appendChild(label);
                
                // Add full orders display above ORDERS field
                if (header === 'ORDERS' && currentViewMode === 'chartcheck') {
                    const fullOrdersDiv = document.createElement('div');
                    fullOrdersDiv.id = 'fullOrdersDisplay';
                    fullOrdersDiv.className = 'orders-section hidden';
                    form.appendChild(fullOrdersDiv);
                }
                
                form.appendChild(input);
                
                if (input.tagName === 'TEXTAREA') {
                    setTimeout(() => autoResizeTextarea(input), 0);
                }
            });
          
        }




        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }

        function updateNavButtons() {
            document.getElementById('prevButton').disabled = currentPatientIndex === 0;
            document.getElementById('nextButton').disabled = currentPatientIndex === patientData.length - 1;
        }

        function navigateDetails(step) {
            const newIndex = currentPatientIndex + step;
            if (newIndex >= 0 && newIndex < patientData.length) {
                showDetails(newIndex);
            }
        }

        function backToList() {
            document.getElementById('detailsView').style.display = 'none';
            displayRows();
        }

        function deleteCurrentEntry() {
            if (currentPatientIndex !== -1) {
                if (confirm("Are you sure you want to delete this entry?")) {
                    patientData.splice(currentPatientIndex, 1);
                    backToList();
                    displayRows();
                    saveToLocalStorage();
                }
            }
        }

        // ============ ADD/UPDATE ENTRIES ============
        function showAddEntryModal() {
            document.getElementById('addEntryModal').style.display = 'block';
            document.getElementById('entryTypeSelection').style.display = 'block';
            document.getElementById('addEntryForm').style.display = 'none';
            document.getElementById('pasteEntrySection').style.display = 'none';
        }

        function closeAddEntryModal() {
            document.getElementById('addEntryModal').style.display = 'none';
        }

        function showManualEntry() {
            document.getElementById('entryTypeSelection').style.display = 'none';
            document.getElementById('addEntryForm').style.display = 'block';
            generateNewEntryFields();
        }

        function showPasteEntry() {
            document.getElementById('entryTypeSelection').style.display = 'none';
            document.getElementById('pasteEntrySection').style.display = 'block';
            document.getElementById('pasteTextArea').focus();
        }

  function backToEntrySelection() {
    document.getElementById('entryTypeSelection').style.display = 'block';
    document.getElementById('addEntryForm').style.display = 'none';
    document.getElementById('pasteEntrySection').style.display = 'none';
    document.getElementById('updatePatientsSection').style.display = 'none';
    document.getElementById('cameraEntrySection').style.display = 'none';
    document.getElementById('pasteTextArea').value = '';
    document.getElementById('updateListDataModal').value = '';
    
    // Reset camera UI
    resetCameraUI();
}

























	    function generateNewEntryFields(type = 'Patient') {
    const newEntryFields = document.getElementById('newEntryFields');
    newEntryFields.innerHTML = '';
    
    // If type selection is needed
    if (!type || type === true) {
        const typeSelection = document.createElement('div');
        typeSelection.innerHTML = `
            <h3 style="margin-bottom: 1rem;">Select Entry Type:</h3>
            <div class="nav-buttons" style="margin-bottom: 1rem;">
                <button type="button" onclick="generateNewEntryFields('Patient')">Regular Patient</button>
                <button type="button" onclick="generateNewEntryFields('Consult')">Consult</button>
            </div>
        `;
        newEntryFields.appendChild(typeSelection);
        return;
    }
    
    const typeLabel = document.createElement('h3');
    typeLabel.textContent = `New ${type} Entry`;
    typeLabel.style.marginBottom = '1rem';
    typeLabel.style.color = type === 'Consult' ? 'var(--secondary)' : 'var(--primary)';
    newEntryFields.appendChild(typeLabel);
    
    const typeInput = document.createElement('input');
    typeInput.type = 'hidden';
    typeInput.value = type;
    typeInput.setAttribute('data-type', 'true');
    newEntryFields.appendChild(typeInput);

   // Define the fields you want to show - UPDATED ORDER
	const fieldsToShow = ['Name', 'RM', 'MRN', 'A/G', 'CC', 'HPI', 'To do', 'Priority'];
    
    fieldsToShow.forEach(header => {
        const label = document.createElement('label');
        label.textContent = header;
        label.style.display = 'block';
        label.style.marginTop = '0.5rem';
        label.style.marginBottom = '0.25rem';
        label.style.color = 'var(--text-secondary)';
        label.style.fontSize = '0.9rem';
        newEntryFields.appendChild(label);
        
        const input = document.createElement('input');
        input.placeholder = `Enter ${header}...`;
        input.setAttribute('data-header', header);
        input.style.width = '100%';
        input.style.marginBottom = '0.75rem';
        newEntryFields.appendChild(input);
    });
}
















	    

















        function addEntry(event) {
            event.preventDefault();
            
            const newPatient = {};
            MASTER_HEADERS.forEach(header => {
                newPatient[header] = '';
            });
            
            const typeInput = document.querySelector('#newEntryFields input[data-type="true"]');
            if (typeInput) {
                newPatient.Type = typeInput.value;
            } else {
                newPatient.Type = 'Patient';
            }
            
            const fields = document.querySelectorAll('#newEntryFields input[data-header]');
            fields.forEach(field => {
                const header = field.getAttribute('data-header');
                newPatient[header] = field.value.trim();
            });

 if (newPatient['A/G']) {
        newPatient['Problems'] = newPatient['A/G'];
    }


            if (!newPatient.Name) {
                alert('Please enter at least a name.');
                return;
            }

            patientData.push(newPatient);
            displayRows();
            saveToLocalStorage();
            closeAddEntryModal();
            updateCensus();
        }








        function processPastedEntry() {
            const pastedText = document.getElementById('pasteTextArea').value.trim();
            
            if (!pastedText) {
                alert('Please paste some data first.');
                return;
            }

            const newPatients = parseCernerData(pastedText);
            
            if (newPatients && newPatients.length > 0) {
                newPatients.forEach(patient => {
                    patientData.push(patient);
                });
                
                displayRows();
                saveToLocalStorage();
                closeAddEntryModal();
                updateCensus();
                alert(`Successfully added ${newPatients.length} patient(s)!`);
            } else {
                alert('Could not parse the pasted data. Please check the format.');
            }
        }












function parseCernerData(text) {
  const lines = text.split('\n').filter(l => l.trim());
  const newPatients = [];

  lines.forEach(line => {
    const lc = line.toLowerCase();
    if (
      !line.trim() ||
      lc.includes('patient list') ||
      (lc.includes('room') && lc.includes('name'))
    ) return;

    // split on tabs or big spaces
    let cols = line.split('\t').filter(c => c.trim());
    if (cols.length < 3) {
      cols = line.split(/\s{2,}/).filter(c => c.trim());
    }
    if (cols.length < 2) return;

    // grab the basics
    let room = '', name = '', mrn = '', att = '';
    cols.forEach(c => {
      const t = c.trim();
      if (/^\d{5,10}$/.test(t) && !mrn)           mrn = t;
      else if (/^(WMC|ICU|CCU|[A-Z]{2,4})\s+/.test(t) && !room) room = t;
      else if (t.includes(',') && !name)           name = t;
      else if (/(MD|MBBS|DO|Dr\b)/i.test(t) && !att) att = t;
      else if (room && mrn && !name)               name = t;
    });
    if (!name) {
      const guess = cols.find(c => c.trim() && !/^\d+$/.test(c) && c.trim() !== room);
      name = guess ? guess.trim() : 'Unknown';
    }

    // build the blank patient object
    const p = {};
    MASTER_HEADERS.forEach(h => p[h] = '');
    p.Type = 'Patient';
    p.Name = name;
    p.RM   = room || 'TBD';
    p.MRN  = mrn  || '';
    p.Att  = att  || '';

    // —— extract Age/Gender ——
    let ag = '';
    const col7 = cols[6]?.trim() || '';
    // 1) single “30F” in col7
    const m1 = /^(\d+)([MF])$/i.exec(col7);
    if (m1) {
      ag = m1[1] + m1[2].toUpperCase();
    }
    // 2) separate age in col7 + gender in col8
    else if (cols.length >= 8) {
      const age = cols[6].trim();
      const g   = cols[7].trim().toUpperCase();
      if (/^\d+$/.test(age) && /^[MF]$/.test(g)) {
        ag = age + g;
      }
    }

    // if we got it, seed both A/G _and_ Problems
    if (ag) {
      p['A/G']      = ag;
      p['Problems'] = ag;
    }

    newPatients.push(p);
  });

  return newPatients;
}




































function processUpdateList() {
    const text = document.getElementById('updateListData').value.trim();
    if (!text) {
        alert('Please paste the patient list');
        return;
    }

    const minimal = parseCernerData(text);
    if (minimal.length === 0) {
        alert('No valid patient entries found. Please check the format.');
        return;
    }

    // build lookup maps for your existing patients
    const byMRN  = new Map();
    const byName = new Map();
    patientData.forEach(p => {
        if (p.MRN)           byMRN.set(p.MRN, p);
        if (p.Name?.trim())  byName.set(p.Name.trim().toUpperCase(), p);
    });

    // now create a brand-new array in EXACTLY the pasted order
    const updated = minimal.map(mini => {
        // try MRN match, then Name match
        const key = mini.Name.trim().toUpperCase();
        const existing = byMRN.get(mini.MRN) || byName.get(key);

        if (existing) {
            // keep all existing fields, but update RM/MRN/Att (and A/G if you like)
            existing.RM   = mini.RM;
            existing.MRN  = mini.MRN;
            existing.Att  = mini.Att;
            if (mini['A/G']) existing['A/G'] = mini['A/G'];
            return existing;
        } else {
            // brand new patient: has RM, MRN, Att, Type, plus A/G
            return mini;
        }
    });

    // replace your master list
    patientData = updated;

    saveToLocalStorage();
    displayRows();
    closeUpdateListModal();

    alert(
        `List updated!\n\n` +
        `Total now: ${patientData.length}\n` +
        `Matched existing: ${minimal.filter(m => byMRN.has(m.MRN) || byName.has(m.Name.toUpperCase())).length}\n` +
        `New patients: ${minimal.filter(m => !(byMRN.has(m.MRN)||byName.has(m.Name.toUpperCase()))).length}`
    );
}





// Custom labels for consult mode
const CONSULT_MODE_LABELS = {
    'Name': 'Name',
    'RM': 'RM',
    'MRN': 'MRN',
    'A/G': 'A/G',
    'CC': 'CC/Level',
    'HPI': 'HPI/Mech',
    'ROS': 'ROS/1-2o',
    'PMH': 'PMH',
    'Meds': 'Meds',
    'All': 'All',
    'Surg hx': 'SurgHx',
    'FSH': 'FSHCM#',
    'VIOLIN': 'VIOLIN',
    'PE': 'PE',
    'To do': 'To Do',
    'Priority': 'Priority'
};



















        // ============ CONSULT MODE FUNCTIONS ============
        function updateConvertButton() {
            const patient = patientData[currentPatientIndex];
            const btn = document.getElementById('convertTypeBtn');
            if (btn) {
                if (patient.Type === 'Consult') {
                    btn.textContent = '🔄 Convert to Patient';
                } else {
                    btn.textContent = '🔄 Convert to Consult';
                }
            }
        }








		function convertEntryType() {
    const patient = patientData[currentPatientIndex];
    
    if (patient.Type === 'Consult') {
        if (confirm('Convert this consult to a regular patient?')) {
            patient.Type = 'Patient';
            if (!patient.Problems && patient.HPI) {
                patient.Problems = patient.HPI;
            }
            saveToLocalStorage();
            switchView('consult');
            displayRows();
        }
    } else {
        if (confirm('Convert this patient to a consult?')) {
            patient.Type = 'Consult';
            if (!patient.HPI && patient.Problems) {
                patient.HPI = patient.Problems;
            }
            
            // AUTO-ASSIGN PRIORITY 1 WHEN CONVERTING TO CONSULT
            const consultFields = ['CC', 'HPI', 'ROS', 'PMH', 'Meds', 'All', 'Surg hx', 'FSH', 'PE'];
            const hasConsultData = consultFields.some(field => patient[field] && patient[field].trim());
            if (hasConsultData && (!patient.Priority || patient.Priority.trim() === '')) {
                patient.Priority = '1'; // Set to urgent/red when converting to consult with data
            }
            
            saveToLocalStorage();
            switchView('consult');
            displayRows();
        }
    }
}
		

        function exportToRTF(type) {
            if (currentPatientIndex === -1) return;
            
            const patient = patientData[currentPatientIndex];
            
            if (patient.Type !== 'Consult') {
                alert("This is a regular patient entry. Convert to consult first to generate consult/trauma notes.");
                return;
            }
            
            let noteText = "";
            const ageGender = patient['A/G'] || '';
            const cc = patient.CC || '';
            const hpi = patient.HPI || '';
            const ros = patient.ROS || '';
            const pmh = patient.PMH || '';
            const meds = patient.Meds || 'denies';
            const all = patient.All || 'denies';
            const surghx = patient['Surg hx'] || 'denies';
            const fsh = patient.FSH || 'denies';
            const violin = patient.VIOLIN || '';
            const pe = patient.PE || '';
            const plan = patient['To do'] || '';

            const pmhPhrase = pmh ? `with PMH ${pmh}` : "with no PMH";
            let finalLine = `\\i Discussed with Attending Physician\\i0\\par .supp2\\par`;

            if (type === "consult") {
                noteText = 
`\\b\\ul Surgery Initial Consultation Note:\\ul0\\b0\\par\\par
\\b\\ul CC:\\ul0\\b0  ${cc}\\par\\par
\\b\\ul Subjective:\\ul0\\b0\\par
\\b HPI: \\b0  ${ageGender} ${pmhPhrase} ${hpi}\\par\\par
\\b ROS: \\b0  ${ros}\\par.rosgen\\par\\par
\\b Meds: \\b0   ${meds}\\par
\\b All: \\b0  ${all}\\par
\\b Surghx: \\b0   ${surghx}\\par
\\b FamHx/Sochx/HCM:  \\b0  ${fsh}\\par\\par
\\b\\ul Objective:\\ul0\\b0\\par
\\b Physical Exam: \\b0  ${pe}\\par.pe\\par
\\b  Labs/imaging: \\b0   ${violin}\\par\\par
\\b\\ul Assessment:\\ul0\\b0\\par
${ageGender} ${pmhPhrase}, surgery consulted for ${cc}\\par\\par
\\b\\ul Plan:\\ul0\\b0\\par
${plan}\\par.plan\\par
${finalLine}`;
            } else if (type === "trauma") {
                noteText =
`\\b\\ul Trauma Initial Evaluation/Consult Note:\\ul0\\b0\\par\\par
\\b\\ul Activation: \\ul0\\b0 ${cc}\\par\\par
\\b\\ul HPI:\\ul0\\b0\\par
${ageGender} ${pmhPhrase} s/p ${hpi}\\par
\\b Primary Survey:\\b0  Airway intact. b/l breath sounds present. Hemodynamically stable, palpable femoral/radial pulses, extremities wwp, GCS 15 (E4 V5 M6)\\par
\\b Secondary Survey:\\b0  ${ros}\\par
\\b FAST:\\b0  no intra-abdominal free fluid noted\\par
\\b CXR:\\b0  no HTX, no PTX\\par
\\b Pelvic XR:\\b0  no obvious fractures or dislocation\\par\\par
\\b Meds:\\b0  ${meds}\\par
\\b All:\\b0  ${all}\\par
\\b Surghx:\\b0  ${surghx}\\par
\\b FamHx/Sochx/HCM:\\b0  ${fsh}\\par\\par
\\b\\ul Objective:\\ul0\\b0\\par
\\b Physical Exam:\\b0  ${pe}\\par.petrauma\\par\\par 
.frailty\\par\\par
\\b\\ul Assessment:\\ul0\\b0\\par
${ageGender} ${pmhPhrase} s/p ${hpi}\\par
INJURIES:\\par${violin}\\par\\par
\\b\\ul Plan:\\ul0\\b0\\par
${plan}\\par.plantrauma\\par
${finalLine}`;
            }

            const now = new Date();
            const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}`;
            const filename = type === "consult" ? `consult_note_${timestamp}.rtf` : `trauma_note_${timestamp}.rtf`;

            const rtf = `{\\rtf1\\ansi\\deff0\n${noteText}}`;
            downloadFile(rtf, filename, 'application/rtf');
        }

        // ============ CHART CHECK MODE FUNCTIONS ============













function updatePOD() {
    const problemsField = document.getElementById('field_Problems');
    if (!problemsField) return;
    
    const problemsText = problemsField.value;
    if (!problemsText || !problemsText.trim()) {
        alert('No problems text found. Please enter some text first.');
        return;
    }
    
    const lines = problemsText.split('\n');
    
    // Find if there's a date anywhere in the problems section
    let surgeryDate = null;
    let dateMatch = null;
    let dateLineIndex = -1;
    
    // Look for dates in multiple formats
    for (let i = 0; i < lines.length; i++) {
        // Try multiple date formats
        // Format 1: (MM/DD) or MM/DD
        dateMatch = lines[i].match(/\(?(\d{1,2})\/(\d{1,2})\)?/);
        
        // Format 2: MM/DD/YY or MM/DD/YYYY
        if (!dateMatch) {
            dateMatch = lines[i].match(/(\d{1,2})\/(\d{1,2})\/(\d{2,4})/);
            if (dateMatch) {
                // We have year information
                const month = parseInt(dateMatch[1]);
                const day = parseInt(dateMatch[2]);
                const year = parseInt(dateMatch[3]);
                const fullYear = year < 100 ? 2000 + year : year;
                surgeryDate = new Date(fullYear, month - 1, day);
                dateLineIndex = i;
                break;
            }
        }
        
        if (dateMatch && !surgeryDate) {
            const month = parseInt(dateMatch[1]);
            const day = parseInt(dateMatch[2]);
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            
            // Create date object for the surgery date
            surgeryDate = new Date(currentYear, month - 1, day);
            
            // If surgery date is in the future, it's probably from last year
            if (surgeryDate > currentDate) {
                surgeryDate.setFullYear(currentYear - 1);
            }
            dateLineIndex = i;
            break;
        }
    }
    
    if (!surgeryDate) {
        alert('No date found in the problems section.\n\nPlease add a date in one of these formats:\n- MM/DD (e.g., 12/25)\n- (MM/DD) (e.g., (12/25))\n- MM/DD/YY (e.g., 12/25/24)\n- MM/DD/YYYY (e.g., 12/25/2024)');
        return;
    }
    
    // Calculate days difference
    const currentDate = new Date();
    const diffTime = currentDate - surgeryDate;
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
    
    console.log('Surgery date:', surgeryDate);
    console.log('Current date:', currentDate);
    console.log('POD:', diffDays);
    
    // Look for existing POD in any line
    let podLineIndex = -1;
    let podMatch = null;
    for (let i = 0; i < lines.length; i++) {
        podMatch = lines[i].match(/POD\s*\d+/i);
        if (podMatch) {
            podLineIndex = i;
            break;
        }
    }
    
    // Update or add POD
    if (podLineIndex !== -1) {
        // Update existing POD line
        lines[podLineIndex] = lines[podLineIndex].replace(/POD\s*\d+/i, `POD ${diffDays}`);
    } else {
        // Add POD at the beginning of the second line
        if (lines.length === 1) {
            // If there's only one line, add POD as a new second line
            lines.push(`POD ${diffDays}`);
        } else if (lines.length >= 2) {
            // If there's already a second line, prepend POD to it
            const secondLine = lines[1].trim();
            if (secondLine) {
                // If second line has content, add POD at the beginning with a space
                lines[1] = `POD ${diffDays} ${secondLine}`;
            } else {
                // If second line is empty, just set it to POD
                lines[1] = `POD ${diffDays}`;
            }
        }
    }
    
    // Update the textarea
    problemsField.value = lines.join('\n');
    autoResizeTextarea(problemsField);
    
    // Save the updated value
    patientData[currentPatientIndex].Problems = problemsField.value;
    saveToLocalStorage();
    
    // Format the date nicely for the alert
    const formattedDate = surgeryDate.toLocaleDateString('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    });
    
    alert(`POD updated to ${diffDays}\n\nCalculated from surgery date: ${formattedDate}\nCurrent date: ${currentDate.toLocaleDateString('en-US', {
        month: '2-digit',
        day: '2-digit',
        year: 'numeric'
    })}`);
}







function showImportModal() {
    document.getElementById('importModal').style.display = 'block';
    
    // Always clear the textarea - don't load any existing data
    document.getElementById('importData').value = '';
    
    // Reset the paste button to its original state
    resetPasteButton();
    
    // Also clear any existing warnings when opening the import modal
    const warningDiv = document.getElementById('warningMessages');
    if (warningDiv) {
        warningDiv.innerHTML = '';
        warningDiv.classList.add('hidden');
    }
}


        function closeImportModal() {
            document.getElementById('importModal').style.display = 'none';
        }



















// 1. REPLACE the existing processImportedData function (around line 3450) with this:

function processImportedData() {
    const importText = document.getElementById('importData').value;
    if (!importText) return;
    
    const patient = patientData[currentPatientIndex];
    patient.ImportedData = importText;
    lastImportedData = importText;
    
    labData = extractLabValues(importText);
    patient.LabData = JSON.stringify(labData);
    
    const fishbone = generateFishbone(labData);
    const warnings = generateWarnings(labData);
    
    // Update VIOLIN field with plain text (asterisks preserved)
    const violinField = document.getElementById('field_VIOLIN');
    if (violinField) {
        violinField.value = fishbone;
        autoResizeTextarea(violinField);
        
        // Save the plain text with asterisks
        patient.VIOLIN = fishbone;
    }
    
    // Update warnings
    const warningDiv = document.getElementById('warningMessages');
    if (warnings.length > 0) {
        warningDiv.innerHTML = warnings.map(w => `<div class="warning-message">${w}</div>`).join('');
        warningDiv.classList.remove('hidden');
    } else {
        warningDiv.innerHTML = '<div class="warning-message" style="color: var(--accent-3);">All values within normal limits</div>';
        warningDiv.classList.remove('hidden');
    }
    
    saveToLocalStorage();
    closeImportModal();
    document.getElementById('importData').value = '';
    
    // Show fishbone inline instead of popup
    setTimeout(() => showFishboneInline(), 100);
}




        function showTableView() {
            document.getElementById('tableModal').style.display = 'block';
            generateTableView();
        }

        function closeTableModal() {
            document.getElementById('tableModal').style.display = 'none';
        }


// ADD THIS FUNCTION HERE
function closeGraphModal() {
    document.getElementById('graphModal').style.display = 'none';
}






























function generateWarnings(data) {
    const warnings = [];
    const currentDate = new Date().toLocaleDateString('en-US', { 
        month: '2-digit', 
        day: '2-digit', 
        year: '2-digit' 
    });
    
    // Check for date mismatches by category (KEEP THIS)
    const dateCategories = {
        'CBC': ['wbc', 'hgb', 'hct', 'plt'],
        'CMP': ['na', 'k', 'cl', 'co2', 'bun', 'cr', 'glu', 'ca', 'mg', 'phos'],
        'LFTs': ['ast', 'alt', 'tbil', 'dbil', 'alk', 'ggt'],
        'Coags': ['pt', 'ptt', 'inr', 'fib'],
        'ABG': ['ph', 'po2', 'pco2', 'bicarb', 'lactate']
    };
    
    // Check each category for outdated values (KEEP THIS)
    for (const [category, labs] of Object.entries(dateCategories)) {
        let outdated = false;
        let lastDate = '';
        
        for (const lab of labs) {
            if (data.dates[lab] && data.dates[lab] !== currentDate) {
                outdated = true;
                lastDate = data.dates[lab];
                break;
            }
        }
        
        if (outdated) {
            let labTime = '';
            for (const lab of labs) {
                if (data.times && data.times[lab]) {
                    labTime = data.times[lab];
                    break;
                }
            }
            if (labTime) {
                warnings.push(`Last ${category} from ${lastDate} ${labTime}!!`);
            } else {
                warnings.push(`Last ${category} from ${lastDate}!!`);
            }
        }
    }
    
    // KEEP ONLY ELECTROLYTE REPLACEMENT WARNINGS:
    
    // Sodium check
    if (data.labs.na && data.labs.na[0] !== undefined) {
        const na = data.labs.na[0];
        const naPrev = data.labs.na[1];
        const naStr = naPrev !== undefined ? `*${na}* (*${naPrev}*)` : `*${na}*`;
        
        if (na < 135) {
            warnings.push(`Hyponatremic! 1L FWR, Salt tabs 2g BID, Na: ${naStr}`);
        } else if (na > 145) {
            warnings.push(`Hypernatremic! Na: ${naStr} -> FWB/D5W/0.45 NS`);
        }
    } else {
        warnings.push('no Na');
    }
    
    // Potassium check
    if (data.labs.k && data.labs.k[0] !== undefined) {
        const k = data.labs.k[0];
        const kPrev = data.labs.k[1];
        const kStr = kPrev !== undefined ? `*${k}* (*${kPrev}*)` : `*${k}*`;
        
        if (k >= 3.3 && k <= 3.9) {
            warnings.push(`Give 40 meq K PO or IV, K=${kStr}`);
        } else if (k >= 3 && k <= 3.2) {
            warnings.push(`Give 60 meq K IV, K=${kStr}`);
        } else if (k >= 2.6 && k <= 2.9) {
            warnings.push(`Give 80 meq K IV and NHO, K=${kStr}`);
        } else if (k > 0 && k <= 2.6) {
            warnings.push(`Give 100 meq K and NHO, K=${kStr}`);
        } else if (k > 5) {
            warnings.push(`Hyperkalemic!!, K=${kStr}`);
        }
    } else {
        warnings.push('No K');
    }
    
    // Calcium check (KEEP FULL CALCIUM LOGIC)
    if (data.labs.ca && data.labs.ca[0] !== undefined) {
        const ca = data.labs.ca[0];
        const caPrev = data.labs.ca[1];
        const caType = data.labs.caType;
        const isIonized = ca < 7 && !caType;
        
        if (isIonized) {
            const caStr = caPrev !== undefined ? `*${ca}* (*${caPrev}*)` : `*${ca}*`;
            if (ca >= 3.5 && ca < 4) {
                warnings.push(`Give 4g calcium gluconate, 2g/hr, iCa=${caStr}`);
            } else if (ca >= 3 && ca <= 3.4) {
                warnings.push(`Give 6g calcium gluconate 2g/hr, iCa=${caStr}`);
            } else if (ca >= 2.5 && ca <= 2.9) {
                warnings.push(`Give 8g calcium gluconate 2g/hr, iCa=${caStr}`);
            } else if (ca > 0 && ca < 2.5) {
                warnings.push(`Give 10g calcium gluconate 2g/hr, notify senior! iCa=${caStr}`);
            } else if (ca > 5.3) {
                warnings.push(`Hypercalcemia! iCa=${caStr}`);
            }
        } else {
            const caLabel = caType === 'corrected' ? 'Corrected Ca' : 'Total Ca';
            const caStr = caPrev !== undefined ? `*${ca}* (*${caPrev}*)` : `*${ca}*`;
            
            if (ca < 8.5) {
                if (ca >= 8.0 && ca < 8.5) {
                    warnings.push(`Mild hypocalcemia: ${caLabel}=${caStr}`);
                } else if (ca >= 7.0 && ca < 8.0) {
                    warnings.push(`Moderate hypocalcemia: ${caLabel}=${caStr}, give calcium`);
                } else if (ca < 7.0) {
                    warnings.push(`Severe hypocalcemia: ${caLabel}=${caStr}, give IV calcium!`);
                }
            } else if (ca > 10.2) {
                if (ca > 10.2 && ca <= 11.5) {
                    warnings.push(`Mild hypercalcemia: ${caLabel}=${caStr}`);
                } else if (ca > 11.5 && ca <= 13.0) {
                    warnings.push(`Moderate hypercalcemia: ${caLabel}=${caStr}`);
                } else if (ca > 13.0) {
                    warnings.push(`Severe hypercalcemia: ${caLabel}=${caStr}, urgent treatment!`);
                }
            }
        }
    } else {
        warnings.push('Calcium not found');
    }
    
    // Magnesium check
    if (data.labs.mg && data.labs.mg[0] !== undefined) {
        const mg = data.labs.mg[0];
        const mgPrev = data.labs.mg[1];
        const mgStr = mgPrev !== undefined ? `*${mg}* (*${mgPrev}*)` : `*${mg}*`;
        
        if (mg >= 1.6 && mg <= 1.9) {
            warnings.push(`Give 4g mag sulfate IV/2hr@2g/hr, Mg: ${mgStr}`);
        } else if (mg >= 1 && mg <= 1.5) {
            warnings.push(`Give 6g mag sulfate IV/3hr@2g/hr, Mg: ${mgStr}`);
        } else if (mg > 0 && mg <= 1) {
            warnings.push(`Give 8g mag sulfate IV/4hr@2g/hr, Mg: ${mgStr}`);
        }
    } else {
        warnings.push('No mag');
    }
    
    // Phosphorus check
    if (data.labs.phos && data.labs.phos[0] !== undefined) {
        const p = data.labs.phos[0];
        const pPrev = data.labs.phos[1];
        const pStr = pPrev !== undefined ? `*${p}* (*${pPrev}*)` : `*${p}*`;
        
        if (p >= 2 && p < 2.5) {
            warnings.push(`Give 15 mmol phos (22.5 Meq K IV), P=${pStr}`);
        } else if (p >= 1.6 && p <= 1.9) {
            warnings.push(`Give 30 mmol phos (45 Meq K IV), P=${pStr}`);
        } else if (p > 0 && p <= 1.6) {
            warnings.push(`Give 40 mmol phos (60 Meq K IV), P=${pStr}`);
        }
    }
    
    return warnings;
}
















        function generateTableView() {
            if (!labData || Object.keys(labData).length === 0) {
                document.getElementById('tableContainer').innerHTML = '<p>No lab data available. Please import data first.</p>';
                return;
            }
            
            let tableHTML = '<table class="data-table">';
            tableHTML += '<tr><th>Parameter</th>';
            
            const maxValues = Math.max(
                ...Object.values(labData.labs || {}).map(arr => arr ? arr.length : 0),
                ...Object.values(labData.vitals || {}).map(arr => arr ? arr.length : 0)
            );
            
            for (let i = 0; i < maxValues; i++) {
                tableHTML += `<th>Value ${i + 1}</th>`;
            }
            tableHTML += '</tr>';
            
            // Add vitals
            if (labData.vitals) {
                if (labData.vitals.temp) {
                    tableHTML += '<tr><td>Temperature</td>';
                    labData.vitals.temp.forEach(val => {
                        tableHTML += `<td>${val}°C</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.hr) {
                    tableHTML += '<tr><td>Heart Rate</td>';
                    labData.vitals.hr.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.sbp) {
                    tableHTML += '<tr><td>Systolic BP</td>';
                    labData.vitals.sbp.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.dbp) {
                    tableHTML += '<tr><td>Diastolic BP</td>';
                    labData.vitals.dbp.forEach(val => {
                        tableHTML += `<td>${val}</td>`;
                    });
                    tableHTML += '</tr>';
                }
                
                if (labData.vitals.o2) {
                    tableHTML += '<tr><td>O2 Saturation</td>';
                    labData.vitals.o2.forEach(val => {
                        tableHTML += `<td>${val}%</td>`;
                    });
                    tableHTML += '</tr>';
                }
            }
            
            // Add labs
            const labNames = {
                'wbc': 'WBC',
                'hgb': 'Hemoglobin',
                'hct': 'Hematocrit',
                'plt': 'Platelets',
                'na': 'Sodium',
                'k': 'Potassium',
                'cl': 'Chloride',
                'co2': 'CO2',
                'bun': 'BUN',
                'cr': 'Creatinine',
                'glu': 'Glucose',
                'ca': 'Calcium',
                'mg': 'Magnesium',
                'phos': 'Phosphorus',
                'ph': 'pH',
                'pco2': 'pCO2',
                'po2': 'pO2',
                'bicarb': 'Bicarbonate',
                'lactate': 'Lactic Acid',
                'ast': 'AST',
                'alt': 'ALT',
                'tbili': 'Total Bilirubin',
                'dbili': 'Direct Bilirubin',
                'alkphos': 'Alk Phos',
                'ggt': 'GGT'
            };
            
            if (labData.labs) {
                for (const [key, name] of Object.entries(labNames)) {
                    if (labData.labs[key]) {
                        tableHTML += `<tr><td>${name}</td>`;
                        labData.labs[key].forEach(val => {
                            tableHTML += `<td>${val}</td>`;
                        });
                        tableHTML += '</tr>';
                    }
                }
            }
            
            tableHTML += '</table>';
            document.getElementById('tableContainer').innerHTML = tableHTML;
        }




















































function showVitalsTable() {
    document.getElementById('graphModal').style.display = 'block';
    generateVitalsTable();
}

















































function generateVitalsTable() {
    const container = document.getElementById('vitalChart');
    
    if (!lastImportedData) {
        container.innerHTML = '<p>No vital signs data available. Please import data first.</p>';
        return;
    }
    
    // Extract vital signs with timestamps
    const vitalReadings = [];
    const timeSet = new Set();
    
    // Extract temperature readings
    const tempRegex = /Temperature\s*(?:Temporal Artery|Axillary)?:\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    let match;
    while ((match = tempRegex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        vitalReadings.push({
            type: 'Temperature',
            value: parseFloat(match[1]),
            unit: '°C',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: parseFloat(match[1]) > 38 || parseFloat(match[1]) < 35
        });
    }
    
    // Extract heart rate readings
    const hrRegex = /(?:Heart Rate|Heart Rate Monitored|Apical Heart Rate).*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = hrRegex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        const hr = parseInt(match[1]);
        vitalReadings.push({
            type: 'Heart Rate',
            value: hr,
            unit: 'bpm',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: hr > 100 || hr < 60
        });
    }










  










// Extract blood pressure readings - SEPARATE PATTERNS
// First, collect all systolic readings
const systolicReadings = {};
const systolicRegex = /Systolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
while ((match = systolicRegex.exec(lastImportedData)) !== null) {
    const timeKey = `${match[2]} ${match[3]}`;
    systolicReadings[timeKey] = parseInt(match[1]);
}

// Then collect all diastolic readings
const diastolicReadings = {};
const diastolicRegex = /Diastolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
while ((match = diastolicRegex.exec(lastImportedData)) !== null) {
    const timeKey = `${match[2]} ${match[3]}`;
    diastolicReadings[timeKey] = parseInt(match[1]);
}

// Now match systolic and diastolic by timestamp
Object.keys(systolicReadings).forEach(timeKey => {
    timeSet.add(timeKey);
    const sbp = systolicReadings[timeKey];
    const dbp = diastolicReadings[timeKey];
    
    // Parse the date
    const [dateStr, timeStr] = timeKey.split(' ');
    const [month, day, year] = dateStr.split('/');
    const datetime = new Date(`20${year}-${month}-${day} ${timeStr}`);
    
    // Add systolic reading
    vitalReadings.push({
        type: 'Systolic BP',
        value: sbp,
        unit: 'mmHg',
        time: timeKey,
        datetime: datetime,
        abnormal: sbp < 90 || sbp > 180
    });
    
    // Add diastolic reading if it exists for this timestamp
    if (dbp !== undefined) {
        vitalReadings.push({
            type: 'Diastolic BP',
            value: dbp,
            unit: 'mmHg',
            time: timeKey,
            datetime: datetime,
            abnormal: dbp < 60 || dbp > 120
        });
    }
});

// Also check for any diastolic readings without matching systolic
Object.keys(diastolicReadings).forEach(timeKey => {
    if (!systolicReadings[timeKey]) {
        timeSet.add(timeKey);
        const dbp = diastolicReadings[timeKey];
        const [dateStr, timeStr] = timeKey.split(' ');
        const [month, day, year] = dateStr.split('/');
        const datetime = new Date(`20${year}-${month}-${day} ${timeStr}`);
        
        vitalReadings.push({
            type: 'Diastolic BP',
            value: dbp,
            unit: 'mmHg',
            time: timeKey,
            datetime: datetime,
            abnormal: dbp < 60 || dbp > 120
        });
    }
});






















    
    // Extract O2 saturation readings
    const o2Regex = /O2 Saturation.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    while ((match = o2Regex.exec(lastImportedData)) !== null) {
        const timeKey = `${match[2]} ${match[3]}`;
        timeSet.add(timeKey);
        const o2 = parseInt(match[1]);
        vitalReadings.push({
            type: 'O2 Saturation',
            value: o2,
            unit: '%',
            time: timeKey,
            datetime: new Date(`20${match[2].split('/')[2]}-${match[2].split('/')[0]}-${match[2].split('/')[1]} ${match[3]}`),
            abnormal: o2 < 92
        });
    }
    
    // Extract I/O data
    const ioData = extractIntakeOutputData(lastImportedData);
    
    // Add intake readings
    if (ioData.intakes.enteral && ioData.intakes.enteral.length > 0) {
        ioData.intakes.enteral.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Enteral Feeding',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    if (ioData.intakes.bloodProducts && ioData.intakes.bloodProducts.length > 0) {
        ioData.intakes.bloodProducts.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Blood Products',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    if (ioData.intakes.other && ioData.intakes.other.length > 0) {
        ioData.intakes.other.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: entry.description || 'Other Intake',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }
    
    // Add output readings
    if (ioData.outputs.urine && ioData.outputs.urine.length > 0) {
        ioData.outputs.urine.forEach(entry => {
            const timeKey = entry.dateTimeStr;
            timeSet.add(timeKey);
            vitalReadings.push({
                type: 'Urine Output',
                value: entry.volume,
                unit: 'mL',
                time: timeKey,
                datetime: entry.dateTime,
                abnormal: false
            });
        });
    }




    
  // Add drain outputs
    Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
        if (entries && entries.length > 0) {
            const cleanDrainType = drainType.replace(/^Other:\s*/i, '');
            entries.forEach(entry => {
                const timeKey = entry.dateTimeStr;
                timeSet.add(timeKey);
                vitalReadings.push({
                    type: cleanDrainType,
                    value: entry.volume,
                    unit: 'mL',
                    time: timeKey,
                    datetime: entry.dateTime,
                    abnormal: entry.volume > 100
                });
            });
        }
    });
    
    // Process count data and add to vital readings (MOVED HERE!)
    Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
        if (entries && entries.length > 0) {
            entries.forEach(entry => {
                const timeKey = entry.dateTimeStr;
                timeSet.add(timeKey);
                vitalReadings.push({
                    type: countType,
                    value: entry.count,
                    unit: 'count',
                    time: timeKey,
                    datetime: entry.dateTime,
                    abnormal: countType.toLowerCase().includes('stool') && entry.count > 1
                });
            });
        }
    });


	
    // Convert time set to sorted array
    const now = new Date();
    const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
    
    const times = Array.from(timeSet)
        .filter(timeStr => {
            const parts = timeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
            if (!parts) return false;
            const dt = new Date(`20${parts[3]}-${parts[1]}-${parts[2]} ${parts[4]}:${parts[5]}:${parts[6]}`);
            return dt >= twentyFourHoursAgo && dt <= now;
        })
        .sort((a, b) => {
            const dateA = new Date(a.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '20$3-$1-$2'));
            const dateB = new Date(b.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '20$3-$1-$2'));
            return dateB - dateA; // Most recent first
        });
    
    if (times.length === 0) {
        container.innerHTML = '<p>No vital signs or I/O data with timestamps found in the last 24 hours.</p>';
        return;
    }
    
    // Get all unique vital types and organize them by category
    const allTypes = [...new Set(vitalReadings.map(r => r.type))];
    
// Categorize the types
const vitalTypes = ['Temperature', 'Heart Rate', 'Systolic BP', 'Diastolic BP', 'O2 Saturation'];
const intakeTypes = allTypes.filter(t => 
    t.includes('Enteral') || t.includes('Blood Product') || 
    (vitalReadings.find(r => r.type === t && ioData.intakes.other && 
     ioData.intakes.other.some(i => i.description === t)))
);
const countTypes = allTypes.filter(t => t.includes('Count'));
const outputTypes = allTypes.filter(t => 
    !vitalTypes.includes(t) && !intakeTypes.includes(t) && !countTypes.includes(t)
);






    
    // Build the VERTICAL table HTML
    let tableHTML = `
        <h2 style="margin-bottom: 1rem; text-align: center;">Vital Signs & I/O Table (Last 24 Hours)</h2>
        <div style="overflow: auto; max-height: 80vh; width: 100%;">
            <table style="border-collapse: collapse; width: 100%; background: var(--card-bg); min-width: 800px;">
                <thead style="position: sticky; top: 0; background: var(--primary); z-index: 10;">
                    <tr>
                        <th rowspan="2" style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; min-width: 120px; position: sticky; left: 0; z-index: 11;">Date/Time</th>`;
    
    // Add section headers
    if (vitalTypes.length > 0) {
        tableHTML += `<th colspan="${vitalTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; text-align: center;">VITAL SIGNS</th>`;
    }
    if (intakeTypes.length > 0) {
        tableHTML += `<th colspan="${intakeTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--secondary); color: white; text-align: center;">INTAKES</th>`;
    }
    if (outputTypes.length > 0) {
        tableHTML += `<th colspan="${outputTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--danger); color: white; text-align: center;">OUTPUTS</th>`;
    }

if (countTypes.length > 0) {
    tableHTML += `<th colspan="${countTypes.length}" style="border: 1px solid var(--border); padding: 8px; background: var(--accent-5); color: white; text-align: center;">COUNTS</th>`;
}


    
    tableHTML += `</tr><tr>`;
    
    // Add individual column headers
    vitalTypes.forEach(vitalType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--primary); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${vitalType}</th>`;
    });
    
    intakeTypes.forEach(intakeType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--secondary); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${intakeType}</th>`;
    });
    
    outputTypes.forEach(outputType => {
        tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--danger); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${outputType}</th>`;
    });


countTypes.forEach(countType => {
    tableHTML += `<th style="border: 1px solid var(--border); padding: 8px; background: var(--accent-5); color: white; min-width: 100px; text-align: center; font-size: 0.85em;">${countType}</th>`;
});



    
    tableHTML += `</tr></thead><tbody>`;
    
    // Add rows for each time point
    times.forEach((time, index) => {
        const shortTime = time.replace(/(\d{2})\/(\d{2})\/(\d{2})/, '$1/$2').replace(/:00$/, '');
        const rowStyle = index % 2 === 0 ? 'background: var(--card-bg);' : 'background: rgba(255,255,255,0.05);';
        
        tableHTML += `<tr style="${rowStyle}">`;
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; font-weight: bold; position: sticky; left: 0; background: var(--card-bg); z-index: 1;">${shortTime}</td>`;
        
        // Add vital signs data
        vitalTypes.forEach(vitalType => {
            const reading = vitalReadings.find(r => r.type === vitalType && r.time === time);
            if (reading) {
                const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
                let displayValue = reading.value;
                
                if (vitalType === 'Temperature' && !displayValue.toString().includes('°')) {
                    displayValue = `${reading.value}°C`;
                } else if (vitalType === 'O2 Saturation' && !displayValue.toString().includes('%')) {
                    displayValue = `${reading.value}%`;
                }
                
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; ${style}">${displayValue}</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });
        
        // Add intake data
        intakeTypes.forEach(intakeType => {
            const reading = vitalReadings.find(r => r.type === intakeType && r.time === time);
            if (reading) {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(6, 182, 212, 0.1);">${reading.value} mL</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });
        
        // Add output data
        outputTypes.forEach(outputType => {
            const reading = vitalReadings.find(r => r.type === outputType && r.time === time);
            if (reading) {
                const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(239, 68, 68, 0.1); ${style}">${reading.value} mL</td>`;
            } else {
                tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
            }
        });


// Add count data
countTypes.forEach(countType => {
    const reading = vitalReadings.find(r => r.type === countType && r.time === time);
    if (reading) {
        const style = reading.abnormal ? 'color: #ff4444; font-weight: bold;' : '';
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; background: rgba(255, 128, 0, 0.1); ${style}">${reading.value}</td>`;
    } else {
        tableHTML += `<td style="border: 1px solid var(--border); padding: 8px; text-align: center; color: var(--text-secondary);">-</td>`;
    }
});



        
        tableHTML += `</tr>`;
    });
    
    tableHTML += `</tbody></table></div>`;
    
    // Add close button
    tableHTML += `<div style="margin-top: 1.5rem; text-align: center;"><button onclick="closeGraphModal()" style="padding: 0.75rem 2rem;">Close</button></div>`;
    
    container.innerHTML = tableHTML;
}
























































































        function updateOrders() {
            if (!lastImportedData) {
                alert('Please import data first using the Import Data button');
                return;
            }
            
            const orders = extractOrders(lastImportedData);
            const ordersField = document.getElementById('field_ORDERS');
            if (ordersField) {
                ordersField.value = orders;
                patientData[currentPatientIndex].ORDERS = orders;
                autoResizeTextarea(ordersField);
                saveToLocalStorage();
            }
        }


























function toggleOrdersView() {
    showFullOrders = !showFullOrders;
    const fullOrdersDisplay = document.getElementById('fullOrdersDisplay');
    
    if (showFullOrders && (fullOrdersText || lastImportedData)) {
        // Create categorized full orders display
        const medsText = fullOrdersText || extractFullMeds(lastImportedData);
        const dietMatch = lastImportedData.match(/DIET ORDER:\s*([^\n]+)/i);
        
        // Track current section (Scheduled, PRN, Continuous)
        let currentSection = 'Scheduled';
        const medsLines = medsText.split('\n');
        const categorizedMeds = {
            'N/F': [],
            'Pain': [],
            'Abx': [],
            'AC': [],
            'Misc': []
        };
        
        // Process each line and track section
        medsLines.forEach(line => {
            const trimmedLine = line.trim();
            
            // Check for section headers
            if (trimmedLine.toLowerCase().includes('scheduled:')) {
                currentSection = 'Scheduled';
                return;
            } else if (trimmedLine.toLowerCase().includes('prn:')) {
                currentSection = 'PRN';
                return;
            } else if (trimmedLine.toLowerCase().includes('continuous:')) {
                currentSection = 'Continuous';
                return;
            }
            
            // Skip empty lines
            if (!trimmedLine) return;
            
            // Add PRN prefix if in PRN section
            const displayLine = currentSection === 'PRN' ? `PRN ${trimmedLine}` : trimmedLine;
            
            // Categorize the medication
            const lineLower = trimmedLine.toLowerCase();
            
            if (lineLower.match(/npo|lactated ringers|normal saline|parenteral|sodium chloride|dextrose|infant formula|pediatric|regular diet|clear liquid|renal|cardiac|diabetic|dysphagia|soft|full liquid|bariatric|albumin/i)) {
                categorizedMeds['N/F'].push(displayLine);
            } else if (lineLower.match(/oxycodone|hydromorphone|acetaminophen|methocarbamol|baclofen|gabapentin|pregabalin|ibuprofen|ketorolac|tramadol|lidocaine|methadone|fentanyl|morphine|celecoxib|cyclobenzaprine|dexmedetomidine|propofol|midazolam|naproxen/i)) {
                categorizedMeds['Pain'].push(displayLine);
            } else if (lineLower.match(/piperacillin|tazobactam|ceftriaxone|vancomycin|amoxicillin|ciprofloxacin|metronidazole|doxycycline|clindamycin|azithromycin|meropenem|levofloxacin|cephalexin|ampicillin|gentamicin|linezolid|ertapenem|trimethoprim|sulfamethoxazole|diflucan|fluconazole|daptomycin|cefepime|norepinephrine|epinephrine|vasopressin|ceftolozane|amphotericin|micafungin|cefazolin|ceftazidime|eravacycline|phenylephrine|dopamine/i)) {
                categorizedMeds['Abx'].push(displayLine);
            } else if (lineLower.match(/heparin|enoxaparin|aspirin|clopidogrel|apixaban|warfarin|rivaroxaban|fondaparinux|ticagrelor|dabigatran|prasugrel/i)) {
                categorizedMeds['AC'].push(displayLine);
            } else {
                categorizedMeds['Misc'].push(displayLine);
            }
        });
        
        // Build HTML display
        let categorizedHTML = '<strong style="color: var(--primary);">Full Orders List:</strong><br><br>';
        
        // N/F Category
        categorizedHTML += '<strong style="color: var(--primary);">N/F (Nutrition/Fluids):</strong><br>';
        if (dietMatch) {
            categorizedHTML += `<span style="color: var(--primary);">Diet: ${dietMatch[1].trim()}</span><br>`;
        }
        categorizedMeds['N/F'].forEach(med => {
            categorizedHTML += `<span style="color: var(--primary);">${med}</span><br>`;
        });
        if (categorizedMeds['N/F'].length === 0 && !dietMatch) {
            categorizedHTML += '<span style="color: var(--text-secondary);">None</span><br>';
        }
        categorizedHTML += '<br>';
        
        // Pain Category
        categorizedHTML += '<strong style="color: var(--primary);">Pain:</strong><br>';
        if (categorizedMeds['Pain'].length > 0) {
            categorizedMeds['Pain'].forEach(med => {
                categorizedHTML += `<span style="color: var(--primary);">${med}</span><br>`;
            });
        } else {
            categorizedHTML += '<span style="color: var(--text-secondary);">None</span><br>';
        }
        categorizedHTML += '<br>';
        
        // Antibiotics/Pressors Category
        categorizedHTML += '<strong style="color: var(--primary);">Antibiotics/Pressors:</strong><br>';
        if (categorizedMeds['Abx'].length > 0) {
            categorizedMeds['Abx'].forEach(med => {
                categorizedHTML += `<span style="color: var(--primary);">${med}</span><br>`;
            });
        } else {
            categorizedHTML += '<span style="color: var(--text-secondary);">None</span><br>';
        }
        categorizedHTML += '<br>';
        
        // Anticoagulation Category
        categorizedHTML += '<strong style="color: var(--primary);">Anticoagulation:</strong><br>';
        if (categorizedMeds['AC'].length > 0) {
            categorizedMeds['AC'].forEach(med => {
                categorizedHTML += `<span style="color: var(--primary);">${med}</span><br>`;
            });
        } else {
            categorizedHTML += '<span style="color: var(--text-secondary);">None</span><br>';
        }
        categorizedHTML += '<br>';
        
        // Misc Category
        categorizedHTML += '<strong style="color: var(--primary);">Misc:</strong><br>';
        if (categorizedMeds['Misc'].length > 0) {
            categorizedMeds['Misc'].forEach(med => {
                categorizedHTML += `<span style="color: var(--primary);">${med}</span><br>`;
            });
        } else {
            categorizedHTML += '<span style="color: var(--text-secondary);">None</span><br>';
        }
        
        fullOrdersDisplay.innerHTML = categorizedHTML;
        fullOrdersDisplay.classList.remove('hidden');
    } else {
        fullOrdersDisplay.classList.add('hidden');
    }
}






















        // ============ LAB DATA EXTRACTION FUNCTIONS ============




        function extractLabValues(text) {
            const data = {
                vitals: {},
                labs: {},
                dates: {},
                times: {},
                weight: null,
                intake: null,
                output: null,
                o2therapy: null,
                age: null
            };

            // Extract weight
            const weightMatch = text.match(/Weight Measured:\s*([\d.]+)\s*kg/i);
            if (weightMatch) {
                data.weight = parseFloat(weightMatch[1]);
            }

            // Extract intake and output
            const intakeMatch = text.match(/Intake\s*mL\s+([\d,]+(?:\.\d+)?)/);
            if (intakeMatch) {
                data.intake = parseFloat(intakeMatch[1].replace(/,/g, ''));
            }

            const outputMatch = text.match(/Output\s*mL\s+([\d,]+(?:\.\d+)?)/);
            if (outputMatch) {
                data.output = parseFloat(outputMatch[1].replace(/,/g, ''));
            }








// Helper: parse "MM/DD/YY HH:MM:SS" into a Date
function parseTS(dateStr, timeStr) {
  const [mo, day, yr] = dateStr.split('/').map(n => parseInt(n, 10));
  const [h, m, s]    = timeStr.split(':').map(n => parseInt(n, 10));
  return new Date(2000 + yr, mo - 1, day, h, m, s);
}

// Helper function to pick latest entry
function pickLatest(regex, text) {
  const arr = [];
  let mm;
  while ((mm = regex.exec(text)) !== null) {
    arr.push({
      val: mm[1].trim(),
      ts:  parseTS(mm[2], mm[3])
    });
  }
  if (!arr.length) return null;
  arr.sort((a,b) => a.ts - b.ts);
  return arr.pop().val;
}

// ——— Oxygen Therapy ———
const o2Entries = [];
const o2Regex = /Oxygen Therapy:\s*(.+?)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
let m;
while ((m = o2Regex.exec(text)) !== null) {
  o2Entries.push({
    desc: m[1].trim(),
    ts:   parseTS(m[2], m[3])
  });
}

if (o2Entries.length) {
  // pick the latest
  o2Entries.sort((a, b) => a.ts - b.ts);
  const latest = o2Entries.pop();
  data.o2therapyRaw  = latest.desc;
  const rawLower = latest.desc.toLowerCase();

  // map to short codes
  if (/room air/i.test(rawLower)) {
    data.o2therapyCode = 'RA';
  } else if (/invasive mechanical ventilator/i.test(rawLower)) {
    data.o2therapyCode = 'Vent';
  } else if (/non-invasive mechanical ventilator/i.test(rawLower) || /bipap|cpap/i.test(rawLower)) {
    data.o2therapyCode = 'BiPAP/CPAP';
  } else if (/high[- ]?flow nasal cannula/i.test(rawLower)) {
    data.o2therapyCode = 'HFNC';
  } else if (/nasal cannula/i.test(rawLower) && !/high[- ]?flow/i.test(rawLower)) {
    data.o2therapyCode = 'NC';
  } else if (/non-?rebreather/i.test(rawLower)) {
    data.o2therapyCode = 'NRB';
  } else {
    data.o2therapyCode = 'O2';
  }
} // Close the if (o2Entries.length) block

// ——— Oxygen Flow Rate ———
const flowEntries = [];
const flowRegex = /Oxygen Flow Rate:\s*([\d.]+\s*L\/min)\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi;
while ((m = flowRegex.exec(text)) !== null) {
  flowEntries.push({
    rate: m[1].trim(),
    ts:   parseTS(m[2], m[3])
  });
}
if (flowEntries.length) {
  flowEntries.sort((a, b) => a.ts - b.ts);
  data.o2flowRaw = flowEntries.pop().rate;
}










		// ——— Ventilator Settings ———
data.ventModeRaw      = pickLatest(/Ventilator Mode:\s*([^(]+)\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventFrequencyRaw = pickLatest(/Ventilator Frequency(?:,\s*Mandatory)?:\s*(\d+)\s*br\/min\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventTidalRaw     = pickLatest(/Tidal Volume(?:,\s*Delivered)?:\s*(\d+)\s*mL\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventPeepRaw      = pickLatest(/Positive End Expiratory Pressure:\s*(\d+)\s*cmH2O\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);
data.ventFiO2Raw      = pickLatest(/FIO2:\s*(\d+)\s*%\s*\(\s*(\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\s*\)/gi, text);

// If we detected ventilator settings but o2therapyCode isn't set to 'Vent', set it
if (data.ventModeRaw && !data.o2therapyCode) {
    data.o2therapyCode = 'Vent';
    data.o2therapyRaw = 'Mechanical Ventilation';
}

















		


		

            // Extract age
            const ageMatch = text.match(/Age:\s*(\d+)\s*Years/i);
            if (ageMatch) {
                data.age = parseInt(ageMatch[1], 10);
            }




	// Extract vitals (only from last 24 hours)
            // Helper function to check if entry is within 24 hours
            const now = new Date();
            const twentyFourHoursAgo = new Date(now - 24 * 60 * 60 * 1000);
            
            function isWithin24Hours(dateTimeStr) {
                const parts = dateTimeStr.match(/(\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
                if (!parts) return false;
                const dt = new Date(`20${parts[3]}-${parts[1]}-${parts[2]} ${parts[4]}:${parts[5]}:${parts[6]}`);
                return dt >= twentyFourHoursAgo && dt <= now;
            }
            
            // Extract temperature with timestamps
            const tempRegex = /Temperature\s*(?:Temporal Artery|Axillary)?:\s*([\d.]+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const tempValues = [];
            let tempMatch;
            while ((tempMatch = tempRegex.exec(text)) !== null) {
                const timeKey = `${tempMatch[2]} ${tempMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    tempValues.push(parseFloat(tempMatch[1]));
                }
            }
            if (tempValues.length > 0) {
                data.vitals.temp = tempValues;
            }
            
            // Extract heart rate with timestamps
            const hrRegex = /(?:Heart Rate|Heart Rate Monitored|Apical Heart Rate).*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const hrValues = [];
            let hrMatch;
            while ((hrMatch = hrRegex.exec(text)) !== null) {
                const timeKey = `${hrMatch[2]} ${hrMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    hrValues.push(parseInt(hrMatch[1]));
                }
            }
            if (hrValues.length > 0) {
                data.vitals.hr = hrValues;
            }
            
            // Extract systolic BP with timestamps
            const sbpRegex = /Systolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const sbpValues = [];
            let sbpMatch;
            while ((sbpMatch = sbpRegex.exec(text)) !== null) {
                const timeKey = `${sbpMatch[2]} ${sbpMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    sbpValues.push(parseInt(sbpMatch[1]));
                }
            }
            if (sbpValues.length > 0) {
                data.vitals.sbp = sbpValues;
            }
            
            // Extract diastolic BP with timestamps
            const dbpRegex = /Diastolic Blood Pressure(?:\s+Invasive)?:\s*(\d+)\s*mmHg(?:\s+(?:Low|High))?\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const dbpValues = [];
            let dbpMatch;
            while ((dbpMatch = dbpRegex.exec(text)) !== null) {
                const timeKey = `${dbpMatch[2]} ${dbpMatch[3]}`;
                if (isWithin24Hours(timeKey)) {
                    dbpValues.push(parseInt(dbpMatch[1]));
                }
            }
            if (dbpValues.length > 0) {
                data.vitals.dbp = dbpValues;
            }
            
            // Extract O2 saturation with timestamps
            const o2SatRegex = /O2 Saturation.*?:\s*(\d+).*?\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
            const o2Values = [];
            let o2Match;
            while ((o2Match = o2SatRegex.exec(text)) !== null) {
                const timeKey = `${o2Match[2]} ${o2Match[3]}`;
                if (isWithin24Hours(timeKey)) {
                    o2Values.push(parseInt(o2Match[1]));
                }
            }
            if (o2Values.length > 0) {
                data.vitals.o2 = o2Values;
            }







			

            // Extract lab values with dates
            const extractLabValue = (pattern, name) => {
                const matches = text.match(new RegExp(pattern + '.*?([\\d.]+).*?\\((\\d{2}/\\d{2}/\\d{2})\\s+(\\d{2}:\\d{2}:\\d{2})\\)', 'gi'));
                if (matches && matches.length > 0) {
                    const values = [];
                    const dates = [];
                    const times = [];
                    
                    matches.forEach(match => {
                         const valueMatch = match.match(/:\s*[<>]?\s*([\d.]+)/);
            const dateTimeMatch = match.match(/\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/);
                        if (valueMatch) {
                            values.push(parseFloat(valueMatch[1]));
                            if (dateTimeMatch) {
                                dates.push(dateTimeMatch[1]);
                                times.push(dateTimeMatch[2]);
                            }
                        }
                    });

                    data.labs[name] = values;
                    if (dates.length > 0) {
                        data.dates[name] = dates[0];
                        data.times[name] = times[0];
                    }
                }
            };

            // Extract all lab values
            extractLabValue('WBC:', 'wbc');
            extractLabValue('Hgb:', 'hgb');
            extractLabValue('Hct:', 'hct');
            extractLabValue('Platelet Count:', 'plt');
            extractLabValue('Sodium:', 'na');
            extractLabValue('Potassium:', 'k');
            extractLabValue('Chloride:', 'cl');
            extractLabValue('CO2:', 'co2');
            extractLabValue('BUN:', 'bun');
            extractLabValue('Creatinine:', 'cr');
            extractLabValue('Glucose:', 'glu');
            extractLabValue('Calcium, Ionized:', 'ca');
            extractLabValue('Ionized Calcium:', 'ca');
            
            // If no ionized calcium, try total calcium
            if (!data.labs.ca || data.labs.ca.length === 0) {
                extractLabValue('Calcium:', 'totalCa');
                extractLabValue('Albumin:', 'albumin');
                
                if (data.labs.totalCa && data.labs.totalCa.length > 0 && 
                    data.labs.albumin && data.labs.albumin.length > 0) {
                    const totalCa = data.labs.totalCa[0];
                    const albumin = data.labs.albumin[0];
                    const correctedCa = totalCa + 0.8 * (4.0 - albumin);
                    data.labs.ca = [parseFloat(correctedCa.toFixed(2))];
                    data.labs.caType = 'corrected';
                    if (data.dates.totalCa) {
                        data.dates.ca = data.dates.totalCa;
                        data.times.ca = data.times.totalCa;
                    }
                }
            }
            
            extractLabValue('Magnesium Level:', 'mg');
            extractLabValue('Inorganic Phosphorus:', 'phos');
            
            // Extract ABG values
            extractLabValue('pH:', 'ph');
            extractLabValue('pC02:', 'pco2');
            extractLabValue('PO2:', 'po2');
            extractLabValue('Bicarbonate:', 'bicarb');
            extractLabValue('Lactic Acid:', 'lactate');
            
            // Extract LFT values
            extractLabValue('AST:', 'ast');
            extractLabValue('ALT:', 'alt');
	    extractLabValue('Total Bilirubin:', 'tbil');  // Changed from 'tbili' to 'tbil'
            extractLabValue('Direct Bilirubin:', 'dbil'); // Changed from 'dbili' to 'dbil'

            extractLabValue('Alkaline Phosphatase:', 'alk'); // Changed from 'alkphos' to 'alk'

            extractLabValue('GGT:', 'ggt');


           // Add coagulation lab extractions (these were missing)
          extractLabValue('Prothrombin Time:', 'pt');
          extractLabValue('INR:', 'inr');
         extractLabValue('APTT:', 'ptt');
         extractLabValue('Fibrinogen:', 'fib');

extractLabValue('Troponin I, High Sensitivity:', 'trop');

// Extract pancreatic enzymes
extractLabValue('Amylase:', 'amylase');
extractLabValue('Lipase:', 'lipase');




            return data;
        }


































function extractIntakeOutputData(text) {
    console.log('extractIntakeOutputData called with text length:', text ? text.length : 0);
    
const ioData = {
    intakes: {
        enteral: [],
        bloodProducts: [],
        other: []
    },
    outputs: {
        urine: [],
        urinaryCatheter: false,
        lastUrineTime: null,
        drains: {},
        other: {}
    },
    counts: {},
    elapsedHours: null,
    cutoffTime: null,
    totalIntake: null,
    totalOutput: null,
    fluidBalance: null
};

    // Extract intake/output section
    const ioMatch = text.match(/<Intake and Output Start>([\s\S]*?)<Intake and Output End>/i);
    if (!ioMatch) {
        console.log('No I/O section found in text');
        return ioData;
    }
    
    console.log('Found I/O section');
    const ioText = ioMatch[1];
    
    // Split into intake and output sections
    const intakeMatch = ioText.match(/Intake\s*\n([\s\S]*?)(?=Output|$)/i);
    const outputMatch = ioText.match(/Output\s*\n([\s\S]*?)$/i);
    
    const intakeSection = intakeMatch ? intakeMatch[1] : '';
    const outputSection = outputMatch ? outputMatch[1] : '';

    // Get current time and calculate 7 AM cutoff
    const now = new Date();
    const currentHour = now.getHours();
    const cutoffDate = new Date(now);
    
    if (currentHour < 7) {
        // If before 7 AM, go back to 7 AM yesterday
        cutoffDate.setDate(cutoffDate.getDate() - 1);
    }
    cutoffDate.setHours(7, 0, 0, 0);
    
    console.log('Current time:', now);
    console.log('Cutoff date:', cutoffDate);

    // Helper function to parse date/time
    function parseDateTime(dateTimeStr) {
        // Format: (06/14/25 07:00:00)
        const match = dateTimeStr.match(/\((\d{2})\/(\d{2})\/(\d{2})\s+(\d{2}):(\d{2}):(\d{2})\)/);
        if (!match) return null;
        
        const [_, month, day, year, hour, minute, second] = match;
        const fullYear = 2000 + parseInt(year);
        return new Date(fullYear, parseInt(month) - 1, parseInt(day), 
                       parseInt(hour), parseInt(minute), parseInt(second));
    }

    // Helper function to check if entry is within time window
    function isWithinTimeWindow(dateTime) {
        if (!dateTime) return false;
        return dateTime >= cutoffDate && dateTime <= now;
    }

    // Process intake entries
    if (intakeSection && !intakeSection.includes('No qualifying data available')) {
        const intakeLines = intakeSection.split('\n').filter(line => line.trim());
        
        intakeLines.forEach(line => {
            if (line.trim() === '') return;
            
            const dateTime = parseDateTime(line);
            if (!isWithinTimeWindow(dateTime)) return;
            
            const volumeMatch = line.match(/:\s*(\d+)\s*mL/);
            if (!volumeMatch) return;
            
            const volume = parseInt(volumeMatch[1]);
            const entry = {
                description: line.split(':')[0].trim(),
                volume: volume,
                dateTime: dateTime,
                dateTimeStr: line.match(/\(([^)]+)\)/)[1]
            };
            
       // Categorize intake
            if (line.toLowerCase().includes('enteral') || 
                line.toLowerCase().includes('tube feed') ||
                line.toLowerCase().includes('feeding tube') ||
                line.toLowerCase().includes('nasogastric') ||
                line.toLowerCase().includes('ng tube') ||
                line.toLowerCase().includes('peg') ||
                line.toLowerCase().includes('jejunostomy')) {
                ioData.intakes.enteral.push(entry);
            } else if (line.toLowerCase().includes('blood') || 
                       line.toLowerCase().includes('red blood cells') ||
                       line.toLowerCase().includes('packed cells') ||
                       line.toLowerCase().includes('plasma') || 
                       line.toLowerCase().includes('platelets') ||
                       line.toLowerCase().includes('fresh frozen') ||
                       line.toLowerCase().includes('cryoprecipitate') ||
                       line.toLowerCase().includes('albumin')) {
                ioData.intakes.bloodProducts.push(entry);
            } else {
                ioData.intakes.other.push(entry);
            }
			
        });
    }

    // Process output entries
    if (outputSection) {
        const outputLines = outputSection.split('\n').filter(l => l.trim());
        outputLines.forEach(rawLine => {
            let line = rawLine.trim();
            // strip any leading "#<n> "
            line = line.replace(/^#\d+\s*/, '');
            // skip bare headers
            if (/^output$/i.test(line) && !line.includes(':')) return;
            const dateTime = parseDateTime(line);
            if (!isWithinTimeWindow(dateTime)) return;
            const volumeMatch = line.match(/:\s*(\d+)\s*mL/i);
            if (!volumeMatch) return;
            const volume = +volumeMatch[1];
            const dateTimeStr = (line.match(/\(([^)]+)\)/) || [,''])[1];
            // Extract a clean description:
            let description = '';
            if (/Other:/i.test(line)) {
                // grab text after "Other:" up to the next " - " or ":" 
                const m = line.match(/Other:\s*([^:-]+?)(?:\s*-\s*|:)/i);
                description = m ? m[1].trim() : '';
            } else {
                description = line.split(':')[0].trim();
            }
            const entry = { description, volume, dateTime, dateTimeStr };
            // now categorize
            if (/urinary catheter/i.test(line) || /straight cath/i.test(line) ||
                /urine output/i.test(line) || /void/i.test(line)) {
                ioData.outputs.urine.push(entry);
                if (/catheter/i.test(line)) ioData.outputs.urinaryCatheter = true;
                if (!ioData.outputs.lastUrineTime || dateTime > ioData.outputs.lastUrineTime) {
                    ioData.outputs.lastUrineTime = dateTime;
                    ioData.outputs.lastUrineTimeStr = dateTimeStr;
                }
            } else if (/estimated blood loss/i.test(line)) {
                ioData.outputs.other['Estimated Blood Loss'] = 
                    ioData.outputs.other['Estimated Blood Loss'] || [];
                ioData.outputs.other['Estimated Blood Loss'].push(entry);
            } else if (/drain/i.test(description) || /jp/i.test(description)) {
                // surgical drains now grouped correctly by the cleaned description
                ioData.outputs.drains[description] = 
                    ioData.outputs.drains[description] || [];
                ioData.outputs.drains[description].push(entry);
            } else {
                // anything else
                const key = description || 'Other Output';
                ioData.outputs.other[key] = ioData.outputs.other[key] || [];
                ioData.outputs.other[key].push(entry);
            }
        });
    }



// Process count entries
const countData = {};
if (outputSection) {
    const countRegex = /(Stool Count|Urine Count|Vomit Count|.*?Count):\s*(\d+)\s*\((\d{2}\/\d{2}\/\d{2})\s+(\d{2}:\d{2}:\d{2})\)/gi;
    let countMatch;
    while ((countMatch = countRegex.exec(outputSection)) !== null) {
        const countType = countMatch[1];
        const count = parseInt(countMatch[2]);
        const dateTime = parseDateTime(`(${countMatch[3]} ${countMatch[4]})`);
        
        if (isWithinTimeWindow(dateTime)) {
            if (!countData[countType]) {
                countData[countType] = [];
            }
            countData[countType].push({
                count: count,
                dateTime: dateTime,
                dateTimeStr: `${countMatch[3]} ${countMatch[4]}`
            });
        }
    }
}

ioData.counts = countData;

// Calculate elapsed time



    
    // Calculate elapsed time
    const elapsedMs = now - cutoffDate;
    const elapsedHours = elapsedMs / (1000 * 60 * 60);
    ioData.elapsedHours = elapsedHours;
    ioData.cutoffTime = cutoffDate;
    
    console.log('I/O data processed:', {
        enteralCount: ioData.intakes.enteral.length,
        bloodProductCount: ioData.intakes.bloodProducts.length,
        urineCount: ioData.outputs.urine.length,
        hasCatheter: ioData.outputs.urinaryCatheter,
        drainTypes: Object.keys(ioData.outputs.drains),
        elapsedHours: elapsedHours
    });

	

    return ioData;
}

function generateIntakeOutputWarnings(ioData, weight) {
    const warnings = [];
    
    // Get elapsed hours and cutoff time
    const elapsedHours = ioData.elapsedHours || 24;
    const elapsedHoursDisplay = Math.round(elapsedHours);
    const cutoffTime = ioData.cutoffTime || new Date();
    
    // Format cutoff time for display
    const cutoffStr = cutoffTime.toLocaleString('en-US', {
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
    });
    
 



// 1. Check urine output
if (ioData.outputs.urine.length > 0) {
    const totalUrine = ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    const hourlyOutput = Math.round(totalUrine / elapsedHours);
    
    if (weight) {
        const urinePerKgHr = (hourlyOutput / weight).toFixed(2);
        
        if (urinePerKgHr < 0.1) {
            warnings.push(`*ANURIA!* ${urinePerKgHr} mL/kg/hr - total *${totalUrine} mL* in ${elapsedHoursDisplay}hr - last: ${ioData.outputs.lastUrineTimeStr}`);
        } else if (urinePerKgHr < 0.5) {
            warnings.push(`LOW URINE OUTPUT! ${urinePerKgHr} mL/kg/hr, expected: ≥0.5 mL/kg/hr - total *${totalUrine} mL* in ${elapsedHoursDisplay}hr - last: ${ioData.outputs.lastUrineTimeStr}`);
        } else {
            warnings.push(`Urine output: (${urinePerKgHr} mL/kg/hr) - total ${totalUrine} mL in ${elapsedHoursDisplay}hr - last: ${ioData.outputs.lastUrineTimeStr}`);
        }
    } else {
        warnings.push(`Urine output: total ${totalUrine} mL in ${elapsedHoursDisplay}hr - last: ${ioData.outputs.lastUrineTimeStr} (no weight available)`);
    }
    
    if (ioData.outputs.urinaryCatheter) {
        warnings.push(`*Has urinary catheter*`);
    }
} else {
    warnings.push(`*No urine output recorded since ${cutoffStr}!*`);
}










    
// 2. Check drains
Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
    if (entries.length > 0) {
        const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        
        if (total > (30 * elapsedHours)) {
            warnings.push(`${drainType}: *${total} mL* (HIGH OUTPUT) in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
        } else {
            warnings.push(`${drainType}: ${total} mL in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
        }
    }
});
    
// 3. Check blood loss
if (ioData.outputs.other['Estimated Blood Loss']) {
    const bloodLoss = ioData.outputs.other['Estimated Blood Loss'];
    const total = bloodLoss.reduce((sum, entry) => sum + entry.volume, 0);
    
    warnings.push(`*Estimated Blood Loss: ${total} mL* in ${elapsedHoursDisplay}hr`);
}
    
    // 4. Check intakes
    if (ioData.intakes.enteral.length > 0) {
        const totalEnteral = ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
        const hourlyEnteral = Math.round(totalEnteral / elapsedHours);
        const latestEnteral = ioData.intakes.enteral.sort((a, b) => b.dateTime - a.dateTime)[0];
        
        if (weight) {
            const enteralPerKgHr = (hourlyEnteral / weight).toFixed(2);
            warnings.push(`*Enteral feeding: ${hourlyEnteral} mL/hr* (${enteralPerKgHr} mL/kg/hr) - total ${totalEnteral} mL in ${elapsedHoursDisplay}hr - last: ${latestEnteral.dateTimeStr}`);
        } else {
            warnings.push(`*Enteral feeding: ${hourlyEnteral} mL/hr* - total ${totalEnteral} mL in ${elapsedHoursDisplay}hr - last: ${latestEnteral.dateTimeStr}`);
        }
    }
    
    // 5. Check blood products
    if (ioData.intakes.bloodProducts.length > 0) {
        const totalBlood = ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
        const latestBlood = ioData.intakes.bloodProducts.sort((a, b) => b.dateTime - a.dateTime)[0];
        warnings.push(`*Blood products: ${totalBlood} mL* in ${elapsedHoursDisplay}hr - last: ${latestBlood.dateTimeStr}`);
    }
    
    // 6. Check if no intake at all
    if (ioData.intakes.enteral.length === 0 && 
        ioData.intakes.bloodProducts.length === 0 && 
        ioData.intakes.other.length === 0) {
        warnings.push(`*No intake recorded since ${cutoffStr}* (${elapsedHoursDisplay}hr)`);
    }
    
// 7. Check other outputs
Object.entries(ioData.outputs.other).forEach(([outputType, entries]) => {
    if (outputType !== 'Estimated Blood Loss' && entries.length > 0) {
        const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        
        warnings.push(`${outputType}: ${total} mL in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
    }
});




// 8. Check counts
Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
    if (entries.length > 0) {
        const totalCount = entries.reduce((sum, entry) => sum + entry.count, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        
        if (countType.toLowerCase().includes('stool') && totalCount > 3) {
            warnings.push(`*${countType} Total: ${totalCount}* in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
        } else if (countType.toLowerCase().includes('vomit') && totalCount > 0) {
            warnings.push(`*${countType} Total: ${totalCount}* in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
        } else {
            warnings.push(`${countType} Total: ${totalCount} in ${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`);
        }
    }
});







    
    return warnings;
}










































































function generateFishbone(data) {
    let fishbone = '';
    
    // Helper function to wrap abnormal values
    const markAbnormal = (value) => `*${value}*`;
    
    // ===== VITALS SECTION =====
    if (data.vitals.temp && data.vitals.temp.length > 0) {
        const tempMin = Math.min(...data.vitals.temp).toFixed(1);
        const tempMax = Math.max(...data.vitals.temp).toFixed(1);
        const tempAvg = (data.vitals.temp.reduce((a, b) => a + b, 0) / data.vitals.temp.length).toFixed(1);
        
        const hadFever = data.vitals.temp.some(t => t > 38);
        const hadHypothermia = data.vitals.temp.some(t => t < 35);
        
        if (hadFever || hadHypothermia) {
            fishbone += `T ${markAbnormal(`${tempMin}-${tempMax}`)} (${tempAvg}), `;
        } else {
            fishbone += `T ${tempMin}-${tempMax} (${tempAvg}), `;
        }
    } else {
        fishbone += 'no T, ';
    }
    
    if (data.vitals.hr && data.vitals.hr.length > 0) {
        const hrMin = Math.min(...data.vitals.hr);
        const hrMax = Math.max(...data.vitals.hr);
        const hrAvg = Math.round(data.vitals.hr.reduce((a, b) => a + b, 0) / data.vitals.hr.length);
        
        const hadTachycardia = data.vitals.hr.some(hr => hr > 100);
        const hadBradycardia = data.vitals.hr.some(hr => hr < 60);
        
        if (hadTachycardia || hadBradycardia) {
            fishbone += `HR ${markAbnormal(`${hrMin}-${hrMax}`)}(${hrAvg}), `;
        } else {
            fishbone += `HR ${hrMin}-${hrMax}(${hrAvg}), `;
        }
    } else {
        fishbone += 'no HR, ';
    }
    
   


// Handle SBP and DBP separately
if (data.vitals.sbp && data.vitals.sbp.length > 0) {
    const sbpMin = Math.min(...data.vitals.sbp);
    const sbpMax = Math.max(...data.vitals.sbp);
    const sbpAvg = Math.round(data.vitals.sbp.reduce((a, b) => a + b, 0) / data.vitals.sbp.length);
    
    const hadHypotension = data.vitals.sbp.some(sbp => sbp < 90);
    const hadHypertension = data.vitals.sbp.some(sbp => sbp > 180);
    
    if (hadHypotension || hadHypertension) {
        fishbone += `SBP ${markAbnormal(`${sbpMin}-${sbpMax}`)} (${sbpAvg}), `;
    } else {
        fishbone += `SBP ${sbpMin}-${sbpMax} (${sbpAvg}), `;
    }
} else {
    fishbone += 'no SBP, ';
}

if (data.vitals.dbp && data.vitals.dbp.length > 0) {
    const dbpMin = Math.min(...data.vitals.dbp);
    const dbpMax = Math.max(...data.vitals.dbp);
    const dbpAvg = Math.round(data.vitals.dbp.reduce((a, b) => a + b, 0) / data.vitals.dbp.length);
    
    const hadDiastolicHypertension = data.vitals.dbp.some(dbp => dbp > 120);
    const hadDiastolicHypotension = data.vitals.dbp.some(dbp => dbp < 60);
    
    if (hadDiastolicHypertension || hadDiastolicHypotension) {
        fishbone += `DBP ${markAbnormal(`${dbpMin}-${dbpMax}`)} (${dbpAvg}) `;
    } else {
        fishbone += `DBP ${dbpMin}-${dbpMax} (${dbpAvg}) `;
    }
} else {
    fishbone += 'no DBP ';
}







    // O2 saturation with therapy
    if (data.vitals.o2 && data.vitals.o2.length > 0) {
        const o2Min = Math.min(...data.vitals.o2);
        const o2Max = Math.max(...data.vitals.o2);
        
        const hadHypoxia = data.vitals.o2.some(o2 => o2 < 94);
        
        if (hadHypoxia) {
            fishbone += `O2 ${markAbnormal(`${o2Min}-${o2Max}`)}`;
        } else {
            fishbone += `O2 ${o2Min}-${o2Max}`;
        }
        
        if (data.o2therapyCode && data.o2therapyCode !== 'RA') {
            fishbone += `-${markAbnormal(data.o2therapyCode)}`;
            if (data.o2flowRaw && data.o2therapyCode !== 'Vent') {
                fishbone += `@${data.o2flowRaw}`;
            }
        }


} else if (data.o2therapyCode) {
    if (data.o2therapyCode === 'RA') {
        fishbone += `O2: ${data.o2therapyCode}`;
    } else {
        fishbone += `O2: ${markAbnormal(data.o2therapyCode)}`;
        if (data.o2flowRaw && data.o2therapyCode !== 'Vent') {
            fishbone += `@${data.o2flowRaw}`;
        }
    }
} else {
    fishbone += 'no O2';
}




    fishbone += '\n';

   // ===== OXYGEN THERAPY DETAILS ===== 
    // Only show detailed info for ventilators (complex settings worth showing separately)
    if (data.o2therapyCode === 'Vent') {
        const mode = data.ventModeRaw ? data.ventModeRaw.replace(/[\s\/\+]+/g,'') : '';
        const freq = data.ventFrequencyRaw || '';
        const tv = data.ventTidalRaw || '';
        const peep = data.ventPeepRaw || '';
        const fio2 = data.ventFiO2Raw || '';
        const settings = [freq, tv, peep, fio2 ? fio2 + '%' : ''].filter(x => x).join('/');
        fishbone += `${markAbnormal(`Ventilator: ${mode} ${settings}`)}\n`;
    }
	

    // ===== INTAKE/OUTPUT SECTION =====
    if (lastImportedData) {
        const ioData = extractIntakeOutputData(lastImportedData);
        const elapsedHours = ioData.elapsedHours || 24;
        const elapsedHoursDisplay = Math.round(elapsedHours);
        
// Get total intake from the summary section instead of calculating
let totalIntake = 0;
const intakeSummaryMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Intake\s+mL\s+([\d,]+(?:\.\d+)?)/i);
if (intakeSummaryMatch) {
    totalIntake = parseFloat(intakeSummaryMatch[1].replace(/,/g, ''));
} else {
    // Fallback to calculation if summary not found
    totalIntake += ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
    totalIntake += ioData.intakes.other.reduce((sum, entry) => sum + entry.volume, 0);
}
		
        
    // Get total output from the summary section instead of calculating
let totalOutput = 0;
const outputSummaryMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Output\s+mL\s+([\d,]+(?:\.\d+)?)/i);
if (outputSummaryMatch) {
    totalOutput = parseFloat(outputSummaryMatch[1].replace(/,/g, ''));
} else {
    // Fallback to calculation if summary not found
    totalOutput += ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    Object.values(ioData.outputs.drains).forEach(entries => {
        totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
    Object.values(ioData.outputs.other).forEach(entries => {
        totalOutput += entries.reduce((sum, entry) => sum + entry.volume, 0);
    });
}
		
        
        // INTAKES
        fishbone += `I: ${totalIntake}\n`;
        let hasIntakes = false;

		
        
        if (ioData.intakes.enteral.length > 0) {
            const totalEnteral = ioData.intakes.enteral.reduce((sum, entry) => sum + entry.volume, 0);
            const hourlyEnteral = Math.round(totalEnteral / elapsedHours);
            const latestEnteral = ioData.intakes.enteral.sort((a, b) => b.dateTime - a.dateTime)[0];
            fishbone += `Enteral: ${totalEnteral}mL/${elapsedHoursDisplay}hr (${hourlyEnteral}mL/hr) - last: ${latestEnteral.dateTimeStr}\n`;
            hasIntakes = true;
        }
        
        if (ioData.intakes.bloodProducts.length > 0) {
            const totalBlood = ioData.intakes.bloodProducts.reduce((sum, entry) => sum + entry.volume, 0);
            const latestBlood = ioData.intakes.bloodProducts.sort((a, b) => b.dateTime - a.dateTime)[0];
            fishbone += `Blood products: ${totalBlood}mL/${elapsedHoursDisplay}hr - last: ${latestBlood.dateTimeStr}\n`;
            hasIntakes = true;
        }
        
        if (ioData.intakes.other.length > 0) {
            const groupedIntakes = {};
            ioData.intakes.other.forEach(entry => {
                const type = entry.description || 'Other intake';
                if (!groupedIntakes[type]) groupedIntakes[type] = [];
                groupedIntakes[type].push(entry);
            });
            
            Object.entries(groupedIntakes).forEach(([type, entries]) => {
                const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
                const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                fishbone += `${type}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}\n`;
                hasIntakes = true;
            });
        }
        
        if (!hasIntakes) {
            fishbone += ``;
        }
        
        // OUTPUTS  
        fishbone += `O: ${totalOutput}\n`;
        let hasOutputs = false;
        



		// Urine output
if (ioData.outputs.urine.length > 0) {
    const totalUrine = ioData.outputs.urine.reduce((sum, entry) => sum + entry.volume, 0);
    const hourlyOutput = Math.round(totalUrine / elapsedHours);
    
    // Start with Foley if present
    let urineStr = '';
    if (ioData.outputs.urinaryCatheter) {
        urineStr = `${markAbnormal('Foley')} `;
    }
    
    urineStr += `UOP: ${totalUrine}mL/${elapsedHoursDisplay}hr`;
    if (data.weight) {
        const urinePerKgHr = (hourlyOutput / data.weight).toFixed(2);
        urineStr += ` (${urinePerKgHr}mL/kg/hr)`;
        if (urinePerKgHr < 0.5) {
            // Rebuild the string to mark the UOP part as abnormal while keeping Foley at front
            const foleyPrefix = ioData.outputs.urinaryCatheter ? `${markAbnormal('Foley')} ` : '';
            urineStr = `${foleyPrefix}UOP: ${markAbnormal(`${totalUrine}mL/${elapsedHoursDisplay}hr (${urinePerKgHr}mL/kg/hr)`)}`;
        }
    }
    urineStr += ` - last: ${ioData.outputs.lastUrineTimeStr}`;
    
    fishbone += urineStr + '\n';
    hasOutputs = true;
} else {
    fishbone += `${markAbnormal('No urine found')}\n`;
    hasOutputs = true;
}


		
        
     // Drains
Object.entries(ioData.outputs.drains).forEach(([drainType, entries]) => {
    if (entries.length > 0) {
        const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
        const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
        let drainStr = `${markAbnormal(drainType)}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`;
        if (total > (30 * elapsedHours)) {
            drainStr = `${markAbnormal(drainType)}: ${markAbnormal(`${total}mL/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}`;
        }
        fishbone += drainStr + '\n';
        hasOutputs = true;
    }
});
        
        // Other outputs
        Object.entries(ioData.outputs.other).forEach(([outputType, entries]) => {
            if (entries.length > 0) {
                const total = entries.reduce((sum, entry) => sum + entry.volume, 0);
                const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                if (outputType.includes('Blood Loss')) {
                    fishbone += `${outputType}: ${markAbnormal(`${total}mL/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}\n`;
                } else {
                    fishbone += `${outputType}: ${total}mL/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}\n`;
                }
                hasOutputs = true;
            }
        });
        
        // COUNTS
        if (Object.keys(ioData.counts || {}).length > 0) {
            fishbone += `COUNTS:\n`;
            Object.entries(ioData.counts || {}).forEach(([countType, entries]) => {
                if (entries.length > 0) {
                    const totalCount = entries.reduce((sum, entry) => sum + entry.count, 0);
                    const latest = entries.sort((a, b) => b.dateTime - a.dateTime)[0];
                    let countStr = `${countType}: ${totalCount}/${elapsedHoursDisplay}hr - last: ${latest.dateTimeStr}`;
                    if ((countType.toLowerCase().includes('stool') && totalCount > 3) || 
                        (countType.toLowerCase().includes('vomit') && totalCount > 0)) {
                        countStr = `${countType}: ${markAbnormal(`${totalCount}/${elapsedHoursDisplay}hr`)} - last: ${latest.dateTimeStr}`;
                    }
                    fishbone += countStr + '\n';
                }
            });
        }
        
        // Fluid balance
        const intakeMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Intake\s+mL\s+([\d,]+(?:\.\d+)?)/i);
        const outputMatch = lastImportedData.match(/Total\s+Summary[\s\S]*?Output\s+mL\s+([\d,]+(?:\.\d+)?)/i);
        const balanceMatch = lastImportedData.match(/Fluid\s+Balance\s+([-+]?[\d,]+(?:\.\d+)?)/i);
        
        let fluidBalance = null;
        if (balanceMatch) {
            fluidBalance = parseFloat(balanceMatch[1].replace(/,/g, ''));
        } else if (intakeMatch && outputMatch) {
            const totalIntake = parseFloat(intakeMatch[1].replace(/,/g, ''));
            const totalOutput = parseFloat(outputMatch[1].replace(/,/g, ''));
            fluidBalance = totalIntake - totalOutput;
        }
        
 


if (fluidBalance !== null) {
    const sign = fluidBalance >= 0 ? '+' : '';
    const absBalance = Math.abs(fluidBalance);
    
    if (absBalance > 100) {
        fishbone += `Fluid Balance: ${markAbnormal(`${sign}${fluidBalance.toFixed(1)}mL`)}\n`;
    } else {
        fishbone += `Fluid Balance: ${sign}${fluidBalance.toFixed(1)}mL\n`;
    }
}



        
        fishbone += '\n';
    }

    // ===== CBC FISHBONE =====
    const wbc = data.labs.wbc?.[0];
    const hgb = data.labs.hgb?.[0];
    const hct = data.labs.hct?.[0];
    const plt = data.labs.plt?.[0];

    const wbcPrev = data.labs.wbc?.[1];
    const hgbPrev = data.labs.hgb?.[1];
    const hctPrev = data.labs.hct?.[1];
    const pltPrev = data.labs.plt?.[1];

   let wbcStr = '--';
    if (wbc !== undefined) {
        if (wbc < 4.5 || wbc > 11) {
            // Abnormal WBC - show current and previous if available
            wbcStr = wbcPrev !== undefined ? `${markAbnormal(wbc)}(${wbcPrev})` : markAbnormal(wbc);
        } else {
            // Normal WBC - just show current value
            wbcStr = wbc.toString();
        }
    }

    













let hgbStr = '--';
if (hgb !== undefined) {
    if (hgb <= 7 || (hgbPrev !== undefined && hgbPrev - hgb >= 1)) {
        hgbStr = `${markAbnormal(hgb)}${hgbPrev !== undefined ? `(${hgbPrev})` : ''}`;
    } else {
        hgbStr = hgb.toString();
    }
}





    let hctStr = '--';
    if (hct !== undefined) {
        if (hct < 21 && hctPrev !== undefined) {
            hctStr = `${markAbnormal(hct)}(${hctPrev})`;
        } else if (hct < 21) {
            hctStr = markAbnormal(hct);
        } else {
            hctStr = hct.toString();
        }
    }

    let pltStr = '--';
    if (plt !== undefined) {
        if ((plt < 150 || plt > 400) && pltPrev !== undefined) {
            pltStr = `${markAbnormal(plt)}(${pltPrev})`;
        } else if (plt < 150 || plt > 400) {
            pltStr = markAbnormal(plt);
        } else {
            pltStr = plt.toString();
        }
    }

    const posBack = wbcStr.length;
    const hctEndPos = posBack + 1 + hctStr.length;
    const slashPos = hctEndPos;
    const spacesAfterHgb = Math.max(0, slashPos - (wbcStr.length + 1 + hgbStr.length + 1));
    
    fishbone += `${wbcStr}\\${hgbStr} ${' '.repeat(spacesAfterHgb)}/${pltStr}\n`;
    
    let bottom = Array(slashPos + 1).fill(' ');
    bottom[posBack] = '/';
    for (let i = 0; i < hctStr.length; i++) {
        bottom[posBack + 1 + i] = hctStr[i];
    }
    bottom[slashPos] = '\\';
    fishbone += bottom.join('').trimEnd() + '\n';

    // ===== BMP FISHBONE =====
    const na  = data.labs.na?.[0],
          k   = data.labs.k?.[0],
          cl  = data.labs.cl?.[0],
          co2 = data.labs.co2?.[0],
          bun = data.labs.bun?.[0],
          cr  = data.labs.cr?.[0],
          glu = data.labs.glu?.[0];

    let naStr   = na  !== undefined ? na.toString()   : '--';
    let kStr    = k   !== undefined ? (k < 3.5 || k > 5.0 ? markAbnormal(k) : k.toString()) : '--';
    let clStr   = cl  !== undefined ? (cl < 96 || cl > 106 ? markAbnormal(cl) : cl.toString()) : '--';
    let co2Str  = co2 !== undefined ? co2.toString()  : '--';
    let bunStr  = bun !== undefined ? (bun > 24 ? markAbnormal(bun) : bun.toString()) : '--';

   let crStr;
    if (cr !== undefined) {
        const prevCr = data.labs.cr?.[1];
        if (cr > 1.2 || (prevCr !== undefined && cr - prevCr > 0.3)) {
            // Abnormal creatinine - show current and previous if available
            crStr = prevCr !== undefined ? `${markAbnormal(cr)}(${prevCr})` : markAbnormal(cr);
        } else {
            // Normal creatinine - just show current value
            crStr = cr.toString();
        }
    } else {
        crStr = '--';
    }

	

    let gluStr  = glu !== undefined ? (glu > 200 || glu < 70 ? markAbnormal(glu) : glu.toString()) : '--';

    const col1 = Math.max(naStr.length, kStr.length);
    const col2 = Math.max(clStr.length, co2Str.length);
    const col3 = Math.max(bunStr.length, crStr.length);

    fishbone +=
        `${naStr.padEnd(col1)} |` +
        `${clStr.padEnd(col2)} |` +
        `${bunStr.padEnd(col3)}/${gluStr}\n`;

    fishbone +=
        `${kStr.padEnd(col1)} |` +
        `${co2Str.padEnd(col2)} |` +
        `${crStr.padEnd(col3)}\\\n`;

    // Check if labs are recent
    const currentDate = new Date();
    currentDate.setHours(0, 0, 0, 0);
    const yesterday = new Date(currentDate);
    yesterday.setDate(yesterday.getDate() - 1);

    const isRecentDate = (dateStr) => {
        if (!dateStr) return false;
        const [month, day, year] = dateStr.split('/').map(n => parseInt(n));
        const labDate = new Date(2000 + year, month - 1, day);
        labDate.setHours(0, 0, 0, 0);
        return labDate >= yesterday && labDate <= currentDate;
    };

    // ===== LFTs SECTION =====
    if ((data.labs.ast || data.labs.alt || data.labs.tbil || data.labs.alk) && 
        (isRecentDate(data.dates.ast) || isRecentDate(data.dates.alt))) {
        const ast = data.labs.ast?.[0];
        const alt = data.labs.alt?.[0];
        const astPrev = data.labs.ast?.[1];
        const altPrev = data.labs.alt?.[1];
        
        let astAltStr = '';
        if (ast && alt && (ast > 40 || alt > 40)) {
            astAltStr = `AST/ALT:${markAbnormal(`${ast}/${alt}`)}(${astPrev || '--'}/${altPrev || '--'})`;
        } else if (ast && alt) {
            astAltStr = `AST/ALT:${ast}/${alt}`;
        }
        
        const tbil = data.labs.tbil?.[0];
        const tbilPrev = data.labs.tbil?.[1];
        let tbilStr = '';
        if (tbil !== undefined) {
            if (tbil > 1.2) {
                tbilStr = `TB:${markAbnormal(tbil)}${tbilPrev !== undefined ? `(${tbilPrev})` : ''}`;
            } else {
                tbilStr = `TB:${tbil}`;
            }
        } else {
            tbilStr = 'TB:--';
        }
        
        const dbil = data.labs.dbil?.[0];
        const dbilPrev = data.labs.dbil?.[1];
        let dbilStr = '';
        if (dbil !== undefined) {
            if (dbil > 0.3) {
                dbilStr = `DB:${markAbnormal(dbil)}${dbilPrev !== undefined ? `(${dbilPrev})` : ''}`;
            } else {
                dbilStr = `DB:${dbil}`;
            }
        } else {
            dbilStr = 'DB:--';
        }
        
        const alk = data.labs.alk?.[0];
        const alkPrev = data.labs.alk?.[1];
        let alkStr = '';
        if (alk !== undefined) {
            if (alk > 150 || alk < 40) {
                alkStr = `ALK:${markAbnormal(alk)}${alkPrev !== undefined ? `(${alkPrev})` : ''}`;
            } else {
                alkStr = `ALK:${alk}`;
            }
        } else {
            alkStr = 'ALK:--';
        }
        
        fishbone += `LFTs: ${astAltStr}, ${tbilStr}, ${dbilStr}, ${alkStr}`;
        
        const lfDate = data.dates.ast || data.dates.alt || data.dates.tbil;
        const lfTime = data.times.ast || data.times.alt || data.times.tbil || '';
        if (lfDate) {
            fishbone += ` (${lfDate}${lfTime ? ' ' + lfTime : ''})`;
        }
        fishbone += '\n';
    }

    // ===== COAGULATION SECTION =====
    if ((data.labs.pt || data.labs.ptt || data.labs.inr || data.labs.fib) &&
        (isRecentDate(data.dates.pt) || isRecentDate(data.dates.ptt) || 
         isRecentDate(data.dates.inr) || isRecentDate(data.dates.fib))) {
        
        const pt = data.labs.pt?.[0];
        const ptt = data.labs.ptt?.[0];
        const inr = data.labs.inr?.[0];
        const fib = data.labs.fib?.[0];
        
        const ptPrev = data.labs.pt?.[1];
        const pttPrev = data.labs.ptt?.[1];
        const inrPrev = data.labs.inr?.[1];
        const fibPrev = data.labs.fib?.[1];
        
        let ptStr = '--';
        if (pt !== undefined) {
            if (pt > 13.5 && ptPrev !== undefined) {
                ptStr = `${markAbnormal(pt)}(${ptPrev})`;
            } else if (pt > 13.5) {
                ptStr = markAbnormal(pt);
            } else {
                ptStr = pt.toString();
            }
        }
        
        let pttStr = '--';
        if (ptt !== undefined) {
            if (ptt > 35 && pttPrev !== undefined) {
                pttStr = `${markAbnormal(ptt)}(${pttPrev})`;
            } else if (ptt > 35) {
                pttStr = markAbnormal(ptt);
            } else {
                pttStr = ptt.toString();
            }
        }
        
        let inrStr = '--';
        if (inr !== undefined) {
            if (inr > 1.1 && inrPrev !== undefined) {
                inrStr = `${markAbnormal(inr)}(${inrPrev})`;
            } else if (inr > 1.1) {
                inrStr = markAbnormal(inr);
            } else {
                inrStr = inr.toString();
            }
        }
        
        let fibStr = '--';
        if (fib !== undefined) {
            if ((fib < 200 || fib > 400) && fibPrev !== undefined) {
                fibStr = `${markAbnormal(fib)}(${fibPrev})`;
            } else if (fib < 200 || fib > 400) {
                fibStr = markAbnormal(fib);
            } else {
                fibStr = fib.toString();
            }
        }
        
        fishbone += `Coags: PT/PTT: ${ptStr}/${pttStr}, INR: ${inrStr}, Fib: ${fibStr}`;
        
        const coagDate = data.dates.pt || data.dates.ptt || data.dates.inr || data.dates.fib;
        const coagTime = data.times.pt || data.times.ptt || data.times.inr || data.times.fib || '';
        if (coagDate) {
            fishbone += ` (${coagDate}${coagTime ? ' ' + coagTime : ''})`;
        }
        fishbone += '\n';
    }
    
    // ===== ABG SECTION =====
    if ((data.labs.ph || data.labs.po2 || data.labs.pco2) && 
        (isRecentDate(data.dates.ph) || isRecentDate(data.dates.po2))) {
        const ph = data.labs.ph?.[0];
        const po2 = data.labs.po2?.[0];
        const pco2 = data.labs.pco2?.[0];
        const bicarb = data.labs.bicarb?.[0];
        
        let phStr = ph !== undefined ? (ph < 7.35 || ph > 7.45 ? markAbnormal(ph) : ph.toString()) : '--';
        let po2Str = po2 !== undefined ? (po2 < 80 ? markAbnormal(po2) : po2.toString()) : '--';
        let pco2Str = pco2 !== undefined ? (pco2 < 35 || pco2 > 45 ? markAbnormal(pco2) : pco2.toString()) : '--';
        let bicarbStr = bicarb !== undefined ? (bicarb < 22 || bicarb > 28 ? markAbnormal(bicarb) : bicarb.toString()) : '--';
        
        fishbone += `ABG: ${phStr}/${pco2Str}/${po2Str}/${bicarbStr}`;
        
        const abgDate = data.dates.ph || data.dates.po2 || data.dates.pco2;
        const abgTime = data.times.ph || data.times.po2 || data.times.pco2 || '';
        if (abgDate) {
            fishbone += ` (${abgDate}${abgTime ? ' ' + abgTime : ''})`;
        }
        fishbone += '\n';
    }
    
    // ===== MISC LABS SECTION =====
    const miscLabs = [];
    
    const lactate = data.labs.lactate?.[0];
    if (lactate !== undefined) {
        let lactateStr = `Lactate:${lactate > 2 ? markAbnormal(lactate) : lactate}`;
        miscLabs.push(lactateStr);
    }
    
    const trop = data.labs.trop?.[0];
    if (trop !== undefined && isRecentDate(data.dates.trop)) {
        let tropStr = `Trop:${trop > 0.04 ? markAbnormal(trop) : trop}`;
        miscLabs.push(tropStr);
    }
    
    const amylase = data.labs.amylase?.[0];
    if (amylase !== undefined && isRecentDate(data.dates.amylase)) {
        let amylaseStr = `Amylase:${amylase > 110 ? markAbnormal(amylase) : amylase}`;
        miscLabs.push(amylaseStr);
    }
    
    const lipase = data.labs.lipase?.[0];
    if (lipase !== undefined && isRecentDate(data.dates.lipase)) {
        let lipaseStr = `Lipase:${lipase > 140 ? markAbnormal(lipase) : lipase}`;
        miscLabs.push(lipaseStr);
    }
    
    if (miscLabs.length > 0) {
        fishbone += `Misc: ${miscLabs.join(', ')}\n`;
    }
    
    return fishbone;
}

































  











































































































function extractOrders(text) {
    // Extract medications section
    const medsMatch = text.match(/Medications.*?\(\d+\)\s*Active([\s\S]*?)(?=(?:\n\n)?(?:DIET ORDER:|CONSULTATION:|PROCEDURE:|IMAGING:|LABS:|$))/i);
    if (!medsMatch) return '';
    
    const medsText = medsMatch[1];
    
    // Get existing LTD and dispo
    const currentOrders = document.getElementById('field_ORDERS')?.value || '';
    let existingLTD = '';
    let existingDispo = '';
    
    if (currentOrders) {
        const ltdMatch = currentOrders.match(/^LTD:[ \t]*([^\r\n]*)/m);
        const dispoMatch = currentOrders.match(/dispo:\s*([^\n]+)/);
        if (ltdMatch) existingLTD = ltdMatch[1].trim();
        if (dispoMatch) existingDispo = dispoMatch[1].trim();
    }
    
    fullOrdersText = medsText;
    
    // Extract diet order
    const dietMatch = text.match(/DIET ORDER:\s*([^\n]+)/i);
    
    // Initialize order categories
    const orders = {
        'N/F': [],
        'Pain': [],
        'Abx': [],
        'AC': []
    };

    // COMPREHENSIVE MEDICATION ABBREVIATION TABLE
    const drugAbbreviations = {
        // Pain medications
        'acetaminophen': { abbr: 'T', category: 'Pain' },
        'tylenol': { abbr: 'T', category: 'Pain' },
        'morphine': { abbr: 'm', category: 'Pain' },
        'oxycodone': { abbr: 'o', category: 'Pain' },
        'oxyCODONE': { abbr: 'o', category: 'Pain' },
        'percocet': { abbr: 'perc', category: 'Pain' },
        'hydromorphone': { abbr: 'D', category: 'Pain' },
        'dilaudid': { abbr: 'D', category: 'Pain' },
        'fentanyl': { abbr: 'fent', category: 'Pain' },
        'tramadol': { abbr: 'tram', category: 'Pain' },
        'ketorolac': { abbr: 'k', category: 'Pain' },
        'toradol': { abbr: 'k', category: 'Pain' },
        'gabapentin': { abbr: 'g', category: 'Pain' },
        'neurontin': { abbr: 'g', category: 'Pain' },
        'pregabalin': { abbr: 'lyrica', category: 'Pain' },
        'lidocaine': { abbr: 'lido', category: 'Pain' },
        'methocarbamol': { abbr: 'r', category: 'Pain' },
        'robaxin': { abbr: 'r', category: 'Pain' },
        'cyclobenzaprine': { abbr: 'flexeril', category: 'Pain' },
        'baclofen': { abbr: 'bac', category: 'Pain' },
        'ibuprofen': { abbr: 'ibu', category: 'Pain' },
        'naproxen': { abbr: 'nap', category: 'Pain' },
        'celecoxib': { abbr: 'celebrex', category: 'Pain' },
        'dexmedetomidine': { abbr: 'precedex', category: 'Pain' },
        
        // Antibiotics
        'vancomycin': { abbr: 'vanco', category: 'Abx' },
        'piperacillin': { abbr: 'zosyn', category: 'Abx' },
        'tazobactam': { abbr: 'zosyn', category: 'Abx' },
        'ceftriaxone': { abbr: 'ctx', category: 'Abx' },
        'cefepime': { abbr: 'cef', category: 'Abx' },
        'cefazolin': { abbr: 'ancef', category: 'Abx' },
        'meropenem': { abbr: 'mero', category: 'Abx' },
        'azithromycin': { abbr: 'azithro', category: 'Abx' },
        'levofloxacin': { abbr: 'levo', category: 'Abx' },
        'ciprofloxacin': { abbr: 'cipro', category: 'Abx' },
        'metronidazole': { abbr: 'flagyl', category: 'Abx' },
        'clindamycin': { abbr: 'clinda', category: 'Abx' },
        'doxycycline': { abbr: 'doxy', category: 'Abx' },
        'fluconazole': { abbr: 'fluc', category: 'Abx' },
        'micafungin': { abbr: 'mica', category: 'Abx' },
        'ampicillin': { abbr: 'amp', category: 'Abx' },
        'amoxicillin': { abbr: 'amox', category: 'Abx' },
        'trimethoprim': { abbr: 'bactrim', category: 'Abx' },
        'sulfamethoxazole': { abbr: 'bactrim', category: 'Abx' },
        'linezolid': { abbr: 'linezolid', category: 'Abx' },
	'ertapenem': { abbr: 'ertapenem', category: 'Abx' },
	'ceftriaxone': { abbr: 'ceftriaxone', category: 'Abx' },
        
        // Pressors
        'norepinephrine': { abbr: 'levo', category: 'Abx' },
        'epinephrine': { abbr: 'epi', category: 'Abx' },
        'vasopressin': { abbr: 'vaso', category: 'Abx' },
        'phenylephrine': { abbr: 'neo', category: 'Abx' },
        'dopamine': { abbr: 'dopa', category: 'Abx' },
        
        // Anticoagulation
        'heparin': { abbr: 'hep', category: 'AC' },
        'enoxaparin': { abbr: 'L', category: 'AC' },
        'lovenox': { abbr: 'L', category: 'AC' },
        'aspirin': { abbr: 'ASA', category: 'AC' },
        'clopidogrel': { abbr: 'plavix', category: 'AC' },
        'warfarin': { abbr: 'coumadin', category: 'AC' },
        'apixaban': { abbr: 'eliquis', category: 'AC' },
        'rivaroxaban': { abbr: 'xarelto', category: 'AC' },
        'fondaparinux': { abbr: 'arixtra', category: 'AC' },
        
        // Fluids
        'lactated ringers': { abbr: 'LR', category: 'N/F' },
        'normal saline': { abbr: 'NS', category: 'N/F' },
        'dextrose': { abbr: 'D', category: 'N/F' },
        'd5w': { abbr: 'D5W', category: 'N/F' },
        'd5ns': { abbr: 'D5NS', category: 'N/F' },
        'albumin': { abbr: 'alb', category: 'N/F' },
	'parenteral nutrition': { abbr: 'TPN', category: 'N/F' },
	'total parenteral nutrition': { abbr: 'TPN', category: 'N/F' },
	'tpn': { abbr: 'TPN', category: 'N/F' },
	'peripheral parenteral nutrition': { abbr: 'PPN', category: 'N/F' },
	'ppn': { abbr: 'PPN', category: 'N/F' },
    };








function extractDoseInfo(line) {
    let dose = '';
    let freq = '';
    
    // Extract all dose matches - now handles commas in numbers (e.g., "1,000 mg")
    const doseMatches = [...line.matchAll(/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*(mg|g|mcg|unit|units|mL|L)/gi)];
    
    if (doseMatches.length > 0) {
        // For medications with multiple doses (like "500 mg 1 tab 1,000 mg 2 tab"),
        // take the highest dose which is usually the total therapeutic dose
        let bestDose = doseMatches[0];
        
        for (let match of doseMatches) {
            // Remove commas for numeric comparison
            const currentValue = parseFloat(match[1].replace(/,/g, ''));
            const bestValue = parseFloat(bestDose[1].replace(/,/g, ''));
            
            // Take the higher dose value, or if same unit type, the larger number
            if (match[2].toLowerCase() === bestDose[2].toLowerCase() && currentValue > bestValue) {
                bestDose = match;
            }
        }
        
        // Clean the dose value (remove commas for final output)
        const cleanDose = parseFloat(bestDose[1].replace(/,/g, ''));
        const unit = bestDose[2].toLowerCase();
        
        // Convert units when appropriate
        let finalDose = cleanDose;
        let finalUnit = unit;
        
        // Unit conversion logic
        if (unit === 'mg' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'g';
        } else if (unit === 'ml' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'L';
        } else if (unit === 'mcg' && cleanDose >= 1000 && cleanDose % 1000 === 0) {
            finalDose = cleanDose / 1000;
            finalUnit = 'mg';
        }
        
        // Format the final dose
        if (finalUnit === 'mg') {
            // For mg, only include the number (legacy behavior)
            dose = finalDose.toString();
        } else {
            // For other units, include the unit
            dose = finalDose + finalUnit;
        }
    }
    
    // Enhanced frequency patterns - handles extra words like "scheduled", "as ordered", etc.
    const freqPatterns = [
        // Every X hours patterns
        { pattern: /every\s+(\d+)\s+hours?(?:\s+(?:scheduled|as\s+ordered|prn|as\s+needed))?/i, 
          convert: (match) => `q${match[1]}` },
        { pattern: /q\s*(\d+)\s*h(?:rs?)?(?:\s+(?:scheduled|as\s+ordered|prn|as\s+needed))?/i, 
          convert: (match) => `q${match[1]}` },
        
        // Daily patterns
        { pattern: /(?:once\s+)?daily(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        { pattern: /once\s+(?:a\s+)?day(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        { pattern: /qd(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qd' },
        
        // BID patterns
        { pattern: /(?:twice\s+(?:a\s+)?day|2\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'bid' },
        { pattern: /bid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'bid' },
        
        // TID patterns
        { pattern: /(?:three\s+times?\s+(?:a\s+)?day|3\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'tid' },
        { pattern: /tid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'tid' },
        
        // QID patterns
        { pattern: /(?:four\s+times?\s+(?:a\s+)?day|4\s+times?\s+(?:a\s+)?day)(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qid' },
        { pattern: /qid(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qid' },
        
        // PRN patterns
        { pattern: /as\s+needed(?:\s+for.*?)?/i, 
          convert: () => 'prn' },
        { pattern: /prn(?:\s+for.*?)?/i, 
          convert: () => 'prn' },
        
        // Bedtime patterns
        { pattern: /(?:at\s+)?bedtime(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qhs' },
        { pattern: /qhs(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'qhs' },
        
        // Single dose patterns
        { pattern: /once(?:\s+only)?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'x1' },
        { pattern: /single\s+dose(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'x1' },
        
        // Weekly patterns
        { pattern: /weekly(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'weekly' },
        { pattern: /once\s+(?:a\s+)?week(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'weekly' },
        
        // Before meals patterns
        { pattern: /before\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'ac' },
        { pattern: /ac(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'ac' },
        
        // After meals patterns
        { pattern: /after\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'pc' },
        { pattern: /pc(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'pc' },
        
        // With meals patterns
        { pattern: /with\s+meals?(?:\s+(?:scheduled|as\s+ordered))?/i, 
          convert: () => 'w/meals' }
    ];
    
    // Try to match frequency patterns
    for (const freqPattern of freqPatterns) {
        const match = line.match(freqPattern.pattern);
        if (match) {
            freq = freqPattern.convert(match);
            break;
        }
    }
    
    // Extract rate for continuous infusions (handles commas in rates too)
    const rateMatch = line.match(/(\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*mL\/hr/i);
    if (rateMatch) {
        const cleanRate = parseFloat(rateMatch[1].replace(/,/g, ''));
        
        // Convert mL/hr to L/hr when appropriate
        if (cleanRate >= 1000 && cleanRate % 1000 === 0) {
            const convertedRate = cleanRate / 1000;
            freq = '@' + convertedRate + 'L/hr';
        } else {
            freq = '@' + cleanRate;
        }
    }
    
    return { dose, freq };
}





	

    // Process diet order
    if (dietMatch) {
        const diet = dietMatch[1].trim().toLowerCase();
        const dietMap = {
            'npo': 'NPO',
            'nothing by mouth': 'NPO',
            'regular': 'RD',
            'general': 'RD',
            'clear liquid': 'CLD',
            'full liquid': 'FLD',
            'renal': 'renal',
            'cardiac': 'cardiac',
            'diabetic': 'DM diet',
            'diabetes': 'DM diet',
            'soft': 'soft',
            'mechanical soft': 'mech soft',
            'pureed': 'puree',
            'dysphagia': 'dysphagia'
        };
        
        for (const [key, value] of Object.entries(dietMap)) {
            if (diet.includes(key)) {
                orders['N/F'].push(value);
                break;
            }
        }
    }
    
    // Process medications
    const medLines = medsText.split('\n').filter(line => line.trim());
    const processedMeds = new Set();
    
    medLines.forEach(line => {
        const lineLower = line.toLowerCase();
        
        // Skip non-medication lines
        if (lineLower.includes('scheduled:') || 
            lineLower.includes('prn:') || 
            lineLower.includes('continuous:') ||
            line.trim().length < 3) {
            return;
        }
        
        // Find matching drug
        let matched = false;
        for (const [drug, info] of Object.entries(drugAbbreviations)) {
            if (lineLower.includes(drug)) {
                const { dose, freq } = extractDoseInfo(line);
                
                // Build abbreviation
                let abbr = info.abbr;
                if (dose) {
                    // Special formatting for common doses
                    if (drug === 'acetaminophen' && dose === '975') abbr = 't975';
                    else if (drug === 'acetaminophen' && dose === '1000') abbr = 'T1g';
                    else if (dose && freq) abbr = `${info.abbr}${dose}${freq}`;
                    else if (dose) abbr = `${info.abbr}${dose}`;
                }
                if (freq && !dose) abbr = `${info.abbr}${freq}`;
                
              // Special cases for IV medications
		if (lineLower.includes('iv ') || lineLower.includes('intravenous')) {
		    abbr += 'IV';
		}
		
		// Add asterisks around IV pain medications
		if (info.category === 'Pain' && abbr.includes('IV')) {
		    abbr = `*${abbr}*`;
		}
		
		if (!processedMeds.has(abbr)) {
		    orders[info.category].push(abbr);
		    processedMeds.add(abbr);
		}





		    
                matched = true;
                break;
            }
        }
        
        // Special handling for fluids with rates
        if (!matched && (lineLower.includes('ml/hr') || lineLower.includes('ml per hour'))) {
            const rateMatch = line.match(/(\d+)\s*mL\/hr/i);
            if (rateMatch) {
                const rate = rateMatch[1];
                if (lineLower.includes('lactated ringer')) {
                    orders['N/F'].push(`LR@${rate}`);
                } else if (lineLower.includes('normal saline') || lineLower.includes('0.9%')) {
                    orders['N/F'].push(`NS@${rate}`);
                } else if (lineLower.includes('d5w')) {
                    orders['N/F'].push(`D5W@${rate}`);
                }
            }
        }
    });
    
    // Format final orders
    const formattedOrders = [];
    formattedOrders.push(`N/F: ${orders['N/F'].length > 0 ? orders['N/F'].join(', ') : ''}`);
    formattedOrders.push(`Pain: ${orders['Pain'].length > 0 ? orders['Pain'].join(', ') : ''}`);
    formattedOrders.push(existingLTD ? `LTD: ${existingLTD}` : `LTD:`);
    formattedOrders.push(`Abx: ${orders['Abx'].length > 0 ? orders['Abx'].join(', ') : ''}`);
    formattedOrders.push(`AC: ${orders['AC'].length > 0 ? orders['AC'].join(', ') : '*NO DVT PPX*'}`);
    formattedOrders.push(`dispo: ${existingDispo}`);
    
    return formattedOrders.join('\n');
}




        function extractFullMeds(text) {
            const medsMatch = text.match(/Medications.*?\(\d+\)\s*Active([\s\S]*?)(?=(?:\n\n)?(?:DIET ORDER:|CONSULTATION:|PROCEDURE:|IMAGING:|LABS:|$))/i);
            return medsMatch ? medsMatch[1] : '';
        }




	   function showStaffPresentation() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    
    // Check if it's a consult
    if (patient.Type !== 'Consult') {
        alert("This is a regular patient entry. Convert to consult first to generate staff presentation.");
        return;
    }
    
    // Extract data
    const cc = patient.CC || 'No chief complaint';
    const ageGender = patient['A/G'] || 'Unknown age/gender';
    const pmh = patient.PMH || '';
    const hpi = patient.HPI || '';
    const ros = patient.ROS || '';
    const violin = patient.VIOLIN || 'No labs/vitals documented';
    const pe = patient.PE || 'No physical exam documented';
    const todo = patient['To do'] || 'No plan documented';
    
    // Format PMH phrase
    const pmhPhrase = pmh ? `with PMH ${pmh}` : 'with no PMH';
 
 // Extract patient identifiers
    const name = patient.Name || 'Unknown';
    const rm = patient.RM || 'Unknown';
    const mrn = patient.MRN || 'Unknown';
    

// Build the presentation with patient identifiers at the top
    let presentation = `${name}\n${rm}\nMRN: ${mrn}\n\n`;
    presentation += `Consult for ${cc}\n\n`;
    presentation += `${ageGender} ${pmhPhrase}, ${hpi} ${ros}\n\n`;
    presentation += `${violin} \n\n ${pe}\n\n`;
    presentation += `Plan: ${todo}`;
    
    
    // Create modal for presentation
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 800px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Staff</h2>
            <pre style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; white-space: pre-wrap; font-family: monospace; font-size: 0.9rem; line-height: 1.6; color: var(--text-primary);">${presentation}</pre>
            <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                <button onclick="copyStaffPresentation()">📋 Copy to Clipboard</button>
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Store presentation for copy function
    window.currentStaffPresentation = presentation;
}

function copyStaffPresentation() {
    if (window.currentStaffPresentation) {
        navigator.clipboard.writeText(window.currentStaffPresentation).then(() => {
            alert('Presentation copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy:', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = window.currentStaffPresentation;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                alert('Presentation copied to clipboard!');
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textArea);
        });
    }
}




	    function showUpdatePatientsSection() {
    document.getElementById('entryTypeSelection').style.display = 'none';
    document.getElementById('updatePatientsSection').style.display = 'block';
    document.getElementById('updateListDataModal').focus();
}



	    function processUpdateListFromModal() {
    const text = document.getElementById('updateListDataModal').value.trim();
    if (!text) {
        alert('Please paste the patient list');
        return;
    }

    const minimal = parseCernerData(text);
    if (minimal.length === 0) {
        alert('No valid patient entries found. Please check the format.');
        return;
    }

    // build lookup maps for your existing patients
    const byMRN  = new Map();
    const byName = new Map();
    patientData.forEach(p => {
        if (p.MRN)           byMRN.set(p.MRN, p);
        if (p.Name?.trim())  byName.set(p.Name.trim().toUpperCase(), p);
    });

    // now create a brand-new array in EXACTLY the pasted order
    const updated = minimal.map(mini => {
        // try MRN match, then Name match
        const key = mini.Name.trim().toUpperCase();
        const existing = byMRN.get(mini.MRN) || byName.get(key);

        if (existing) {
            // keep all existing fields, but update RM/MRN/Att (and A/G if you like)
            existing.RM   = mini.RM;
            existing.MRN  = mini.MRN;
            existing.Att  = mini.Att;
            if (mini['A/G']) existing['A/G'] = mini['A/G'];
            return existing;
        } else {
            // brand new patient: has RM, MRN, Att, Type, plus A/G
            return mini;
        }
    });

    // replace your master list
    patientData = updated;

    saveToLocalStorage();
    displayRows();
    closeAddEntryModal(); // Close the modal after updating

    alert(
        `List updated!\n\n` +
        `Total now: ${patientData.length}\n` +
        `Matched existing: ${minimal.filter(m => byMRN.has(m.MRN) || byName.has(m.Name.toUpperCase())).length}\n` +
        `New patients: ${minimal.filter(m => !(byMRN.has(m.MRN)||byName.has(m.Name.toUpperCase()))).length}`
    );

    // Re-apply sort if one was active
    if (currentSortColumn) {
        reSort();
    }
}

	    
	
function copyPatientInfo(patient, button) {
    const name = patient.Name || 'Unknown';
    const rm = patient.RM || 'Unknown';
    const mrn = patient.MRN || 'Unknown';
    
    // Format the text to copy
    const textToCopy = `${name}\n${rm}\n${mrn}`;
    
    // Copy to clipboard
    navigator.clipboard.writeText(textToCopy).then(() => {
        // Success feedback
        button.innerHTML = '✅';
        button.classList.add('copied');
        
        // Show tooltip
        const tooltip = document.createElement('div');
        tooltip.style.position = 'absolute';
        tooltip.style.bottom = '100%';
        tooltip.style.right = '0';
        tooltip.style.marginBottom = '5px';
        tooltip.style.background = 'var(--success)';
        tooltip.style.color = 'white';
        tooltip.style.padding = '0.5rem';
        tooltip.style.borderRadius = '0.25rem';
        tooltip.style.fontSize = '0.8rem';
        tooltip.style.whiteSpace = 'nowrap';
        tooltip.style.zIndex = '1000';
        tooltip.textContent = 'Copied!';
        button.appendChild(tooltip);
        
        // Reset after 2 seconds
        setTimeout(() => {
            button.innerHTML = '📋';
            button.classList.remove('copied');
            if (tooltip.parentNode) {
                tooltip.remove();
            }
        }, 2000);
    }).catch(err => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = textToCopy;
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.select();
        
        try {
            document.execCommand('copy');
            button.innerHTML = '✅';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = '📋';
                button.classList.remove('copied');
            }, 2000);
        } catch (err) {
            alert('Failed to copy. Please copy manually: ' + textToCopy);
        }
        
        document.body.removeChild(textArea);
    });
}


    
















function generateFullChecklistHTML() {
    const patient = patientData[currentPatientIndex];
    const patientKey = `${currentPatientIndex}_${patient.Name || 'unnamed'}`;
    const isTrauma = patient.Type !== 'Consult';
    
    // Initialize patient's checklist if not exists
    if (!tempChecklistStates[patientKey]) {
        tempChecklistStates[patientKey] = {};
    }
    
    const states = tempChecklistStates[patientKey];
    
    // Define all checklist items with colors and sections
    const traumaItems = [
        // ADD TO LIST
        { section: 'ADD TO LIST', color: '#dc2626', text: 'Add to list' },
        
        // STAFF  
        { section: 'STAFF', color: '#d97706', text: 'Staff' },
        { section: 'STAFF', color: '#d97706', text: 'Order Scans' },
        
        // NOTE
        { section: 'NOTE (include HCP)', color: '#16a34a', text: 'Advanced Directives/Goals of Care/HCP' },   
        
        // F/U SCANS AND LABS
        { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Primary review of imaging' },
        { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Plan by injury: CTH, CT C/T/L Spine, CT chest/abdomen/pelvis, + additional scans. https://docs.google.com/document/d/12lbPO5K7jMPhruuoedT-piCaQSr9dja2OObAeMD2NWk/edit?tab=t.0' },
        { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'TERTIARY survey' },
        { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'Review labs' },
        { section: 'F/U SCANS AND LABS', color: '#9333ea', text: 'If going to OR: NPO at midnight ± IVF, Book OR + Call OR, consent, Type & screen within 3 days + historical, order 2U PRBCs on hold, Urine ± HCG EKG CXR coags, Order special booking needs/instruments' },

        // ORDERS/CONSULTS
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Extra Scans/Consults' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'PSO if admitting - call bed board' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Diet order vs. NPO/IVF' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Home medications' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'DVT prophylaxis' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Pain meds' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Floor Orders: Vital signs, Continuous pulse oximetry, Telemetry monitoring' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Nursing Orders: Peripheral IVs, Intake and output, Incentive spirometry, Ambulation/activity orders, weight bearing status' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Notify provider of abnormal vital signs (SBP >180 or <100, MAP <65, HR >110 or <50, RR >30 or <10, Change in O2 delivery)' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Neuro vs. neurovascular checks, Foley, OGT, chest tube, central line, arterial line (AND procedure notes)' },
        { section: 'ORDERS/CONSULTS', color: '#0284c7', text: 'Order daily 2 AM labs' },
        
        // DISPO/ADDENDUM
        { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Sign out to ICU/Floor/ED' },
        { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Update family' },
        { section: 'DISPO/ADDENDUM', color: '#c026d3', text: 'Tertiary Survey' }
    ];
    
    const consultItems = [
        // ADD TO LIST
        { section: 'ADD TO LIST', color: '#2563eb', text: 'Add to list' },
        
        // STAFF
 		{ section: 'STAFF', color: '#2563eb', text: 'HX/Vitals/IOs/Labs/Imaging' },
		{ section: 'STAFF', color: '#16a34a', text: 'Staff' },
        
        // ORDERS
        { section: 'ORDERS', color: '#d97706', text: 'PSO if admitting - call bed board' },
        { section: 'ORDERS', color: '#d97706', text: 'Diet order vs. NPO/IVF' },
        { section: 'ORDERS', color: '#d97706', text: 'Home medications' },
        { section: 'ORDERS', color: '#d97706', text: 'DVT prophylaxis' },
        { section: 'ORDERS', color: '#d97706', text: 'Pain meds' },
        { section: 'ORDERS', color: '#d97706', text: 'Floor Orders: Vital signs, Continuous pulse oximetry, Telemetry monitoring' },
        { section: 'ORDERS', color: '#d97706', text: 'Nursing Orders: Peripheral IVs, Intake and output, Incentive spirometry, Ambulation/activity orders, weight bearing status, Notify provider of abnormal vital signs, Neuro vs. neurovascular checks, Foley, OGT, chest tube, central line, arterial line (AND procedure notes)' },
        { section: 'ORDERS', color: '#d97706', text: 'Order daily 2 AM labs' },
        { section: 'ORDERS', color: '#d97706', text: 'Consultations/Imaging/Interventions' },
        
        // NOTE
        { section: 'NOTE', color: '#9333ea', text: 'Complete consultation note' }
    ];
    
    const items = isTrauma ? traumaItems : consultItems;
    const completed = items.filter((_, i) => states[`item_${i}`]).length;
    const progress = Math.round((completed / items.length) * 100);
    
    // Generate HTML with toggle button
    let html = `
        <div style="margin-bottom: 1.5rem; text-align: center;">
            <div style="display: flex; justify-content: center; align-items: center; gap: 0.5rem; margin-bottom: 1rem;">
                <strong style="color: ${isTrauma ? '#ef4444' : '#3b82f6'}; font-size: 1.3em;">
                    ${isTrauma ? 'TRAUMA' : 'CONSULT PATIENT'} CHECKLIST
                </strong>
                <button onclick="toggleChecklistType()" 
                        style="background: linear-gradient(135deg, ${isTrauma ? '#3b82f6' : '#ef4444'}, ${isTrauma ? '#2563eb' : '#dc2626'}); 
                               color: white; border: none; padding: 0.2rem 0.5rem; border-radius: 0.375rem; 
                               font-size: 0.85rem; cursor: pointer; transition: all 0.3s ease;
                               box-shadow: 0 2px 4px rgba(0,0,0,0.2);"
                        onmouseover="this.style.transform='scale(1.05)'"
                        onmouseout="this.style.transform='scale(1)'">
                    Switch to ${isTrauma ? 'Consult' : 'Trauma'}
                </button>
            </div>
        </div>
        
        <div style="margin-bottom: 0.5rem; padding: 0.2rem; background: var(--card-bg); border-radius: 0.5rem; border: 2px solid var(--primary);">
            <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                <strong style="color: var(--primary);">Progress</strong>
                <span id="progressText" style="color: var(--text-primary);">${completed}/${items.length} (${progress}%)</span>
            </div>
            <div style="background: var(--dark-bg); border-radius: 1rem; height: 10px; overflow: hidden;">
                <div id="progressBar" style="background: linear-gradient(90deg, var(--primary), var(--secondary)); height: 100%; width: ${progress}%; transition: width 0.3s;"></div>
            </div>
        </div>`;
    
    // Group items by section
    const sections = {};
    items.forEach((item, index) => {
        if (!sections[item.section]) {
            sections[item.section] = [];
        }
        sections[item.section].push({...item, index});
    });
    

// Generate HTML for each section
Object.entries(sections).forEach(([sectionName, sectionItems]) => {
    const sectionColor = sectionItems[0].color;
    
    html += `
        <div style="margin-bottom: 0.75rem;">
            <h4 style="color: ${sectionColor}; margin-bottom: 0.25rem; font-size: 1.1em; font-weight: bold;">
                ${sectionName}
            </h4>
            <div style="margin-left: 1rem; display: grid; gap: 0.15rem;">`;
        
        sectionItems.forEach(item => {
            const isChecked = states[`item_${item.index}`] || false;
            html += `
    <label style="display: flex; align-items: flex-start; gap: 0.5rem; cursor: pointer; padding: 0.2rem 0.5rem; border-radius: 0.25rem; transition: background 0.2s; border: 1px solid transparent;"
                       onmouseover="this.style.background='var(--card-hover)'; this.style.borderColor='${sectionColor}30';" 
                       onmouseout="this.style.background='transparent'; this.style.borderColor='transparent';">
                    <input type="checkbox" ${isChecked ? 'checked' : ''} 
                           onchange="updateFullChecklist('${patientKey}', ${item.index}, this.checked, ${items.length})"
                           style="width: 18px; height: 18px; min-width: 18px; margin-top: 2px; accent-color: ${sectionColor}; cursor: pointer;">
                    <span style="color: var(--text-primary); font-size: 0.95rem; line-height: 1.4;">
                        ${item.text}
                    </span>
                </label>`;
        });
        
        html += `</div></div>`;
    });
    
    return html;
}





		




		

function updateFullChecklist(patientKey, index, checked, totalItems) {
    // Update temporary state
    if (!tempChecklistStates[patientKey]) {
        tempChecklistStates[patientKey] = {};
    }
    tempChecklistStates[patientKey][`item_${index}`] = checked;
    
    // SAVE TO LOCALSTORAGE FOR PERSISTENCE
    try {
        localStorage.setItem('checklistStates', JSON.stringify(tempChecklistStates));
    } catch (e) {
        console.error('Failed to save checklist states:', e);
    }
    
    // Update progress display
    const states = tempChecklistStates[patientKey];
    const completed = Object.values(states).filter(Boolean).length;
    const progress = Math.round((completed / totalItems) * 100);
    
    const progressBar = document.getElementById('progressBar');
    const progressText = document.getElementById('progressText');
    
    if (progressBar) progressBar.style.width = `${progress}%`;
    if (progressText) progressText.textContent = `${completed}/${totalItems} (${progress}%)`;
}






		














		function showHelpModal(fieldName) {
    const modal = document.getElementById('helpModal') || createHelpModal();
    const title = document.getElementById('helpModalTitle');
    const body = document.getElementById('helpModalBody');
    
    title.textContent = `${fieldName} - Help & Instructions`;
    
    // Special handling for interactive 'To do' checklist
    if (fieldName === 'To do' && currentPatientIndex !== -1) {
        body.innerHTML = generateFullChecklistHTML();
    } else {
        body.innerHTML = helpContent[fieldName] || 'No help content available.';
    }
    
    modal.style.display = 'block';
    document.body.style.overflow = 'hidden';
}













		

function closeHelpModal() {
    const modal = document.getElementById('helpModal');
    if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = 'auto'; // Restore background scrolling
    }
}


		

function createHelpModal() {
    const modal = document.createElement('div');
    modal.id = 'helpModal';
    modal.className = 'help-modal';
    modal.innerHTML = `
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2 id="helpModalTitle" class="help-modal-title">Help & Instructions</h2>
                <button class="help-modal-close" onclick="closeHelpModal()">&times;</button>
            </div>
            <div id="helpModalBody" class="help-modal-body">
                <!-- Content will be inserted here -->
            </div>
        </div>
    `;
    

    
    document.body.appendChild(modal);
    return modal;
}








		function exportCSV() {
    if (patientData.length === 0) {
        alert('No data to export');
        return;
    }
    
    // Define the fields to export (exclude internal fields)
    const exportFields = MASTER_HEADERS.slice(0, -2); // Exclude ImportedData and LabData
    
    // Create CSV header
    let csvContent = exportFields.join(',') + '\n';
    
    // Add data rows
    patientData.forEach(patient => {
        const row = exportFields.map(field => {
            const value = patient[field] || '';
            // Escape commas and quotes in values
            if (value.includes(',') || value.includes('"') || value.includes('\n')) {
                return '"' + value.replace(/"/g, '""') + '"';
            }
            return value;
        });
        csvContent += row.join(',') + '\n';
    });
    
    // Create filename with format: list_M.D.YY.csv
    const now = new Date();
    const month = now.getMonth() + 1;
    const day = now.getDate();
    const year = String(now.getFullYear()).slice(-2);
    const filename = `list_${month}.${day}.${year}.csv`;
    
    downloadFile(csvContent, filename, 'text/csv');
}



		
		function parseCSVData(csvText) {
    console.log('Parsing CSV data...');
    
    // Check if Papa Parse is available
    if (typeof Papa === 'undefined') {
        console.error('Papa Parse not loaded, using fallback parser');
        return parseCSVFallback(csvText);
    }
    
    // Parse CSV using Papa Parse with better configuration
    const parsed = Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true,
        trimHeaders: true,
        transform: function(value) {
            return value ? value.trim() : '';
        }
    });
    
    console.log('Papa Parse result:', parsed);
    
    if (parsed.errors.length > 0) {
        console.warn('CSV parsing errors:', parsed.errors);
    }
    
    const csvData = parsed.data;
    if (!csvData || csvData.length === 0) {
        console.error('No data found in CSV');
        return [];
    }
    
    console.log('CSV headers found:', Object.keys(csvData[0]));
    console.log('First row data:', csvData[0]);
    
    // Create header mapping
    const csvHeaders = Object.keys(csvData[0]);
    const headerMap = createHeaderMapping(csvHeaders);
    
    console.log('Header mapping:', headerMap);
    
    // Convert CSV rows to patient objects
    const patients = [];
    csvData.forEach((row, index) => {
        // Skip completely empty rows
        const hasData = Object.values(row).some(val => val && val.toString().trim() !== '');
        if (!hasData) {
            return;
        }
        
        // Create new patient object
        const patient = {};
        MASTER_HEADERS.forEach(header => {
            patient[header] = '';
        });
        
        // Set default type
        patient.Type = 'Patient';
        
        // Map CSV data to patient fields
        Object.entries(headerMap).forEach(([csvHeader, appField]) => {
            if (row[csvHeader] && row[csvHeader].toString().trim()) {
                patient[appField] = row[csvHeader].toString().trim();
            }
        });
        
        // Also try direct field mapping for exact matches
        csvHeaders.forEach(csvHeader => {
            if (MASTER_HEADERS.includes(csvHeader) && row[csvHeader]) {
                patient[csvHeader] = row[csvHeader].toString().trim();
            }
        });
        
        console.log(`Row ${index + 1} mapped to:`, patient);
        
        // Add patient if we have at least a name or MRN
        if (patient.Name || patient.MRN) {
            patients.push(patient);
        }
    });
    
    console.log(`Successfully parsed ${patients.length} patients from CSV`);
    return patients;
}

// Fallback CSV parser in case Papa Parse fails
function parseCSVFallback(csvText) {
    console.log('Using fallback CSV parser');
    
    const lines = csvText.split('\n').filter(line => line.trim());
    if (lines.length < 2) {
        return [];
    }
    
    // Parse headers
    const headers = lines[0].split(',').map(h => h.replace(/"/g, '').trim());
    console.log('Fallback parser headers:', headers);
    
    const headerMap = createHeaderMapping(headers);
    console.log('Fallback header mapping:', headerMap);
    
    const patients = [];
    
    for (let i = 1; i < lines.length; i++) {
        const values = parseCSVLine(lines[i]);
        
        if (values.length === 0) continue;
        
        const patient = {};
        MASTER_HEADERS.forEach(header => {
            patient[header] = '';
        });
        patient.Type = 'Patient';
        
        // Map values to fields
        headers.forEach((header, index) => {
            if (values[index] && headerMap[header]) {
                patient[headerMap[header]] = values[index].trim();
            }
        });
        
        // Direct mapping for exact matches
        headers.forEach((header, index) => {
            if (MASTER_HEADERS.includes(header) && values[index]) {
                patient[header] = values[index].trim();
            }
        });
        
        if (patient.Name || patient.MRN) {
            patients.push(patient);
        }
    }
    
    return patients;
}

// Simple CSV line parser that handles quotes
function parseCSVLine(line) {
    const result = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            result.push(current);
            current = '';
        } else {
            current += char;
        }
    }
    
    result.push(current);
    return result.map(val => val.replace(/"/g, '').trim());
}



		function createHeaderMapping(csvHeaders) {
    const headerMap = {};
    
    console.log('Creating header mapping for:', csvHeaders);
    
    // Define flexible mappings - more comprehensive
    const fieldMappings = {
        'Name': ['name', 'patient name', 'patient_name', 'full name', 'fullname', 'pt name', 'patient'],
        'RM': ['rm', 'room', 'room number', 'room_number', 'bed', 'room#', 'rm#'],
        'MRN': ['mrn', 'medical record number', 'medical_record_number', 'record number', 'patient id', 'patient_id', 'id', 'record#'],
        'Att': ['att', 'attending', 'physician', 'doctor', 'attending physician', 'attending_physician', 'md', 'provider'],
        'A/G': ['a/g', 'ag', 'age/gender', 'age_gender', 'age gender', 'age', 'gender'],
        'CC': ['cc', 'chief complaint', 'chief_complaint', 'complaint', 'reason'],
        'Problems': ['problems', 'problem list', 'problem_list', 'diagnosis', 'diagnoses', 'dx'],
        'HPI': ['hpi', 'history of present illness', 'history_of_present_illness', 'present illness', 'history'],
        'ROS': ['ros', 'review of systems', 'review_of_systems', 'systems review'],
        'PMH': ['pmh', 'past medical history', 'past_medical_history', 'medical history', 'medical_history', 'past history'],
        'Meds': ['meds', 'medications', 'drugs', 'medicine'],
        'All': ['all', 'allergies', 'allergy', 'allergic'],
        'Surg hx': ['surg hx', 'surgical history', 'surgical_history', 'surgery history', 'surgery_history', 'surgeries'],
        'FSH': ['fsh', 'family social history', 'family_social_history', 'family/social', 'family social', 'family history', 'social history'],
        'ICS': ['ics', 'interval change', 'interval_change', 'changes', 'updates'],
        'VIOLIN': ['violin', 'vitals', 'labs', 'lab values', 'vital signs'],
        'PE': ['pe', 'physical exam', 'physical_exam', 'examination', 'exam', 'physical'],
        'ORDERS': ['orders', 'order', 'medical orders', 'medical_orders', 'plan', 'treatment'],
        'To do': ['to do', 'todo', 'to_do', 'plan', 'action items', 'action_items', 'tasks'],
        'Priority': ['priority', 'urgency', 'level', 'importance']
    };
    
    // Match CSV headers to application fields
    csvHeaders.forEach(csvHeader => {
        const csvHeaderLower = csvHeader.toLowerCase().trim();
        
        console.log(`Checking header: "${csvHeader}" (${csvHeaderLower})`);
        
        // Direct match first (case insensitive)
        const directMatch = MASTER_HEADERS.find(field => 
            field.toLowerCase() === csvHeaderLower
        );
        
        if (directMatch) {
            headerMap[csvHeader] = directMatch;
            console.log(`Direct match: ${csvHeader} -> ${directMatch}`);
            return;
        }
        
        // Check flexible mappings
        for (const [appField, variations] of Object.entries(fieldMappings)) {
            if (variations.some(variation => csvHeaderLower === variation || csvHeaderLower.includes(variation))) {
                headerMap[csvHeader] = appField;
                console.log(`Flexible match: ${csvHeader} -> ${appField}`);
                return;
            }
        }
        
        console.log(`No match found for: ${csvHeader}`);
    });
    
    return headerMap;
}





function pasteFromClipboard() {
    const textarea = document.getElementById('importData');
    const button = event.target;
    const originalText = button.textContent;
    const originalBackground = button.style.background;
    const originalColor = button.style.color;
    
    // Clear any existing content first
    textarea.value = '';
    
    button.textContent = 'Reading clipboard...';
    button.disabled = true;
    
    // Check if clipboard API is available
    if (!navigator.clipboard || !navigator.clipboard.readText) {
        // Fallback for browsers without clipboard API
        button.textContent = 'Manual paste required';
        button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
        button.style.color = 'white';
        button.disabled = false;
        
        setTimeout(() => {
            alert('Automatic clipboard reading not supported.\n\nPlease:\n1. Click in the text area below\n2. Press Ctrl+V (or Cmd+V on Mac) to paste\n3. Click "Process Data" button');
            button.textContent = originalText;
            button.style.background = originalBackground;
            button.style.color = originalColor;
            textarea.focus();
        }, 500);
        return;
    }
    
    // Try to read from clipboard
    navigator.clipboard.readText()
        .then(text => {
            console.log('Clipboard read successful, text length:', text ? text.length : 0);
            
            if (text && text.trim()) {
                // Paste the content
                textarea.value = text;
                button.textContent = 'Processing data...';
                
                // Add a small delay to show the pasted content
                setTimeout(() => {
                    try {
                        // Process the data immediately
                        const importText = textarea.value;
                        if (!importText) {
                            throw new Error('No text found in textarea after paste');
                        }
                        
                        const patient = patientData[currentPatientIndex];
                        if (!patient) {
                            throw new Error('No current patient selected');
                        }
                        
                        patient.ImportedData = importText;
                        lastImportedData = importText;
                        
                        labData = extractLabValues(importText);
                        patient.LabData = JSON.stringify(labData);
                        
                        const fishbone = generateFishbone(labData);
                        const warnings = generateWarnings(labData);
                        
                        // Update VIOLIN field with plain text (asterisks preserved)
                        const violinField = document.getElementById('field_VIOLIN');
                        if (violinField) {
                            violinField.value = fishbone;
                            autoResizeTextarea(violinField);
                            
                            // Save the plain text with asterisks
                            patient.VIOLIN = fishbone;
                        }
                        
                        // Update warnings
                        const warningDiv = document.getElementById('warningMessages');
                        if (warningDiv) {
                            if (warnings.length > 0) {
                                warningDiv.innerHTML = warnings.map(w => `<div class="warning-message">${w}</div>`).join('');
                                warningDiv.classList.remove('hidden');
                            } else {
                                warningDiv.innerHTML = '<div class="warning-message" style="color: var(--accent-3);">All values within normal limits</div>';
                                warningDiv.classList.remove('hidden');
                            }
                        }
                        
                        saveToLocalStorage();
                        closeImportModal();
                        
                        // Success feedback
                        button.textContent = 'Completed!';
                        button.style.background = 'linear-gradient(135deg, var(--success), #059669)';
                        button.style.color = 'white';
                        button.disabled = false;
                        
                        // Show fishbone inline
                        setTimeout(() => {
                            showFishboneInline();
                        }, 200);
                        
                        // Auto-reset button after 3 seconds
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = originalBackground;
                            button.style.color = originalColor;
                        }, 3000);
                        
                    } catch (error) {
                        console.error('Error processing data:', error);
                        button.textContent = 'Processing Error';
                        button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
                        button.style.color = 'white';
                        button.disabled = false;
                        
                        alert('Error processing the pasted data: ' + error.message);
                        
                        // Reset button after error
                        setTimeout(() => {
                            button.textContent = originalText;
                            button.style.background = originalBackground;
                            button.style.color = originalColor;
                        }, 3000);
                    }
                }, 300);
                
            } else {
                // Reset button if clipboard is empty
                button.textContent = 'Clipboard Empty';
                button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
                button.style.color = 'white';
                button.disabled = false;
                
                setTimeout(() => {
                    alert('Clipboard appears to be empty.\n\nPlease:\n1. Copy some data first\n2. Try the button again');
                    button.textContent = originalText;
                    button.style.background = originalBackground;
                    button.style.color = originalColor;
                }, 1000);
            }
        })
        .catch(err => {
            console.error('Failed to read clipboard:', err);
            button.textContent = 'Permission Required';
            button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
            button.style.color = 'white';
            button.disabled = false;
            
            // Show helpful message
            setTimeout(() => {
                alert('Clipboard permission required.\n\nPlease:\n1. Allow clipboard access when prompted by your browser\n2. Make sure you have data copied to clipboard\n3. Try the button again\n\nOR paste manually with Ctrl+V in the text area below');
                
                button.textContent = originalText;
                button.style.background = originalBackground;
                button.style.color = originalColor;
                textarea.focus(); // Focus textarea for manual paste
            }, 500);
        });
}



		function resetPasteButton() {
    const button = document.querySelector('#importModal button[onclick="pasteFromClipboard()"]');
    if (button) {
        button.textContent = '📋⚡ Paste & Process';
        button.style.background = '';
        button.style.color = '';
        button.disabled = false;
    }
}

		



		function showFormattedVIOLIN() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Formatted VIOLIN Data</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 70vh; overflow-y: auto;">${formattedContent}</div>
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}


		function showFormattedVIOLIN() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">Formatted VIOLIN Results</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 70vh; overflow-y: auto;">${formattedContent}</div>
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

		


function showFishbonePopup() {
    if (currentPatientIndex === -1) return;
    
    const patient = patientData[currentPatientIndex];
    const violinText = patient.VIOLIN || 'No VIOLIN data available';
    
    // Generate missing values messages
    const missingValues = generateMissingValuesMessages(labData);
    
    // Create formatted version with red text for abnormal values
    const formattedContent = violinText.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">$1</span>');
    
    // Create modal
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px;">
            <span class="close" onclick="this.closest('.modal').remove()" style="float: right; font-size: 30px; cursor: pointer; color: var(--danger);">&times;</span>
            <h2 style="color: var(--primary); margin-bottom: 1rem;">VIOLIN Fishbone Diagram</h2>
            <div style="background: var(--card-bg); padding: 1.5rem; border-radius: 0.5rem; font-family: monospace; font-size: 0.9rem; line-height: 1.6; white-space: pre-wrap; color: var(--text-primary); border: 1px solid var(--border); max-height: 60vh; overflow-y: auto;">${formattedContent}</div>
            ${missingValues ? `<div style="background: var(--card-bg); margin-top: 1rem; padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border);"><div style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 0.5rem;"><strong>Missing Values:</strong></div><div style="font-style: italic; color: var(--text-secondary); font-size: 0.85rem; line-height: 1.4;">${missingValues}</div></div>` : ''}
            <div style="margin-top: 1rem; text-align: center;">
                <button onclick="copyFishboneToClipboard()">📋 Copy to Clipboard</button>
                <button onclick="this.closest('.modal').remove()">Close</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
    
    // Store fishbone content for copy function
    window.currentFishboneContent = violinText;
}
		



		

		// 3. ADD this function to generate missing values messages:

function generateMissingValuesMessages(data) {
    const missing = [];
    
    // Check vitals
    if (!data.vitals.hr || data.vitals.hr.length === 0) missing.push('No HR');
    if (!data.vitals.sbp || data.vitals.sbp.length === 0) missing.push('No SBP');
    if (!data.vitals.dbp || data.vitals.dbp.length === 0) missing.push('No DBP');
    if (!data.vitals.temp || data.vitals.temp.length === 0) missing.push('No Temp');
    if (!data.vitals.o2 || data.vitals.o2.length === 0) missing.push('No SPO2');
    
    // Check if MAP is missing (would need to be calculated or extracted)
    const hasMAP = lastImportedData && /Mean\s+(?:Arterial\s+)?Pressure/i.test(lastImportedData);
    if (!hasMAP) missing.push('No MAP');
    
    // Check respiratory rate
    const hasRR = lastImportedData && /Respiratory\s+Rate/i.test(lastImportedData);
    if (!hasRR) missing.push('No RR');
    
    // Check O2 therapy
    if (!data.o2therapyCode && !data.o2therapyRaw) missing.push('No O2 therapy documented');
    
    // Check ventilator settings if on vent
    if (data.o2therapyCode === 'Vent') {
        if (!data.ventModeRaw) missing.push('No Vent Mode');
        if (!data.ventFrequencyRaw) missing.push('No Vent RR');
        if (!data.ventTidalRaw) missing.push('No Vt');
        if (!data.ventPeepRaw) missing.push('No PEEP');
        if (!data.ventFiO2Raw) missing.push('No FIO2');
    }
    
    // Check intake/output data if lastImportedData exists
    if (lastImportedData) {
        const ioData = extractIntakeOutputData(lastImportedData);
        
        // Check for specific I/O types
        if (ioData.intakes.bloodProducts.length === 0) {
            const hasBloodProducts = /blood.*product|packed.*cell|plasma|platelet/i.test(lastImportedData);
            if (!hasBloodProducts) missing.push('No blood products');
        }
        
        if (ioData.intakes.other.length === 0) {
            const hasOralIntake = /oral|po\s|by\s+mouth/i.test(lastImportedData);
            if (!hasOralIntake) missing.push('No oral intake');
        }
        
        const hasIVF = /lactated.*ringer|normal.*saline|dextrose.*water|d5w|lr|ns/i.test(lastImportedData);
        if (!hasIVF) missing.push('No IVF');
        
        if (ioData.intakes.enteral.length === 0) {
            const hasTubeFeeds = /tube.*feed|enteral|nasogastric.*feed/i.test(lastImportedData);
            if (!hasTubeFeeds) missing.push('No tube feeds');
        }
        
        // Check outputs
        if (ioData.outputs.urine.length === 0) missing.push('No UOP');
        
        const hasOstomy = /ostomy|colostomy|ileostomy|stoma/i.test(lastImportedData);
        if (!hasOstomy) missing.push('No ostomy output');
        
        const hasBM = /bowel.*movement|bm|stool/i.test(lastImportedData);
        if (!hasBM) missing.push('No BM');
        
        const hasEmesis = /emesis|vomit|nausea.*vomit/i.test(lastImportedData);
        if (!hasEmesis) missing.push('No emesis');
        
        const hasBloodLoss = /blood.*loss|ebl|estimated.*blood/i.test(lastImportedData);
        if (!hasBloodLoss) missing.push('No blood loss');
        
        const hasDialysis = /dialysis|cvvh|crrt/i.test(lastImportedData);
        if (!hasDialysis) missing.push('No dialysis');
    }
    
    // Check labs
    if (!data.labs.wbc || data.labs.wbc.length === 0) missing.push('No WBC');
    if (!data.labs.hgb || data.labs.hgb.length === 0) missing.push('No Hgb');
    if (!data.labs.hct || data.labs.hct.length === 0) missing.push('No Hct');
    if (!data.labs.plt || data.labs.plt.length === 0) missing.push('No Plt');
    
    // BMP
    if (!data.labs.na || data.labs.na.length === 0) missing.push('No Na');
    if (!data.labs.k || data.labs.k.length === 0) missing.push('No K');
    if (!data.labs.cl || data.labs.cl.length === 0) missing.push('No Cl');
    if (!data.labs.co2 || data.labs.co2.length === 0) missing.push('No CO2');
    if (!data.labs.bun || data.labs.bun.length === 0) missing.push('No BUN');
    if (!data.labs.cr || data.labs.cr.length === 0) missing.push('No Cr');
    if (!data.labs.glu || data.labs.glu.length === 0) missing.push('No Glucose');
    
    // Additional electrolytes
    if (!data.labs.ca || data.labs.ca.length === 0) missing.push('No Ca');
    if (!data.labs.mg || data.labs.mg.length === 0) missing.push('No Mg');
    if (!data.labs.phos || data.labs.phos.length === 0) missing.push('No P');
    
    // LFTs
    if (!data.labs.tbil || data.labs.tbil.length === 0) missing.push('No Tbil');
    if (!data.labs.dbil || data.labs.dbil.length === 0) missing.push('No Dbili');
    if (!data.labs.alk || data.labs.alk.length === 0) missing.push('No ALK');
    if (!data.labs.ggt || data.labs.ggt.length === 0) missing.push('No GGT');
    if (!data.labs.ast || data.labs.ast.length === 0) missing.push('No AST');
    if (!data.labs.alt || data.labs.alt.length === 0) missing.push('No ALT');
    
    // Coags
    if (!data.labs.pt || data.labs.pt.length === 0) missing.push('No PT');
    if (!data.labs.ptt || data.labs.ptt.length === 0) missing.push('No PTT');
    if (!data.labs.inr || data.labs.inr.length === 0) missing.push('No INR');
    
    // ABG
    if (!data.labs.ph || data.labs.ph.length === 0) missing.push('No pH');
    if (!data.labs.po2 || data.labs.po2.length === 0) missing.push('No PO2');
    if (!data.labs.pco2 || data.labs.pco2.length === 0) missing.push('No PCO2');
    if (!data.labs.bicarb || data.labs.bicarb.length === 0) missing.push('No Bicarb');
    if (!data.labs.lactate || data.labs.lactate.length === 0) missing.push('No Lactate');
    
    // Other important labs
    if (!data.labs.trop || data.labs.trop.length === 0) missing.push('No Trops');
    
    // Base excess check (would need to be added to extraction)
    const hasBaseExcess = lastImportedData && /base.*excess/i.test(lastImportedData);
    if (!hasBaseExcess) missing.push('No Base excess');
    
    if (missing.length === 0) {
        return null;
    }
    
    return missing.join(', ');
}

// 4. ADD this function for copying fishbone content:

function copyFishboneToClipboard() {
    if (window.currentFishboneContent) {
        navigator.clipboard.writeText(window.currentFishboneContent).then(() => {
            // Change button text briefly to show success
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = '✅ Copied!';
            setTimeout(() => {
                button.textContent = originalText;
            }, 2000);
        }).catch(err => {
            console.error('Failed to copy:', err);
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = window.currentFishboneContent;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                const button = event.target;
                const originalText = button.textContent;
                button.textContent = '✅ Copied!';
                setTimeout(() => {
                    button.textContent = originalText;
                }, 2000);
            } catch (err) {
                alert('Failed to copy. Please select and copy manually.');
            }
            document.body.removeChild(textArea);
        });
    }
}



function toggleFishboneDisplay() {
    const fishboneDisplay = document.getElementById('fishboneDisplay');
    const fishboneContent = document.getElementById('fishboneContent');
    
    if (!fishboneDisplay || !fishboneContent) {
        console.error('Fishbone display elements not found');
        return;
    }
    
    if (fishboneDisplay.classList.contains('hidden')) {
        // Show fishbone - generate it if needed
        const patient = patientData[currentPatientIndex];


		
        if (patient && patient.VIOLIN) {
            // Format content with red styling for abnormal values
 fishboneContent.innerHTML = '';
    const preElement = document.createElement('pre');
    preElement.style.margin = '0';
    preElement.style.fontFamily = 'inherit';
    preElement.style.fontSize = 'inherit';
    preElement.style.lineHeight = 'inherit';
    preElement.style.whiteSpace = 'pre-wrap';
    preElement.style.wordWrap = 'break-word';
    
    // Apply red styling while preserving exact spacing
preElement.innerHTML = patient.VIOLIN.replace(/\*([^*]+)\*/g, '<span style="color: #ff4444; font-weight: bold;">*$1*</span>');
			
    fishboneContent.appendChild(preElement);
            
            // Add missing values if available
            if (labData && Object.keys(labData).length > 0) {
                const missingValues = generateMissingValuesMessages(labData);
                if (missingValues) {
                    const missingDiv = document.createElement('div');
                    missingDiv.style.marginTop = '1rem';
                    missingDiv.style.padding = '0.75rem';
                    missingDiv.style.background = 'rgba(100, 100, 100, 0.1)';
                    missingDiv.style.borderRadius = '0.25rem';
                    missingDiv.style.fontSize = '0.85rem';
                    missingDiv.innerHTML = `<strong style="color: var(--text-secondary);">Missing Values:</strong><br><span style="font-style: italic; color: var(--text-secondary);">${missingValues}</span>`;
                    fishboneContent.appendChild(missingDiv);
                }
            }
        } else {
            fishboneContent.innerHTML = '<em style="color: var(--text-secondary);">No VIOLIN data available. Import data first.</em>';
        }
        
        fishboneDisplay.classList.remove('hidden');
        
        // Scroll the fishbone into view
        setTimeout(() => {
            fishboneDisplay.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }, 100);
    } else {
        // Hide fishbone
        fishboneDisplay.classList.add('hidden');
    }
}

		


		

function showFishboneInline() {
    // Add a delay to ensure DOM elements are ready
    setTimeout(() => {
        const fishboneDisplay = document.getElementById('fishboneDisplay');
        if (fishboneDisplay && currentViewMode === 'chartcheck') {
            // Auto-show the fishbone after processing
            if (fishboneDisplay.classList.contains('hidden')) {
                toggleFishboneDisplay(); // This will populate and show it
            }
        }
    }, 200);
}




































		





	function toggleChecklistType() {
    const patient = patientData[currentPatientIndex];
    const patientKey = `${currentPatientIndex}_${patient.Name || 'unnamed'}`;
    
    // Toggle patient type
    if (patient.Type === 'Consult') {
        patient.Type = 'Patient';
    } else {
        patient.Type = 'Consult';
    }
    
    // Clear the checklist state since items are different
    if (tempChecklistStates[patientKey]) {
        tempChecklistStates[patientKey] = {};
    }
    
    // Save the patient type change
    saveToLocalStorage();
    
    // Regenerate the checklist HTML
    const body = document.getElementById('helpModalBody');
    if (body) {
        body.innerHTML = generateFullChecklistHTML();
    }
    
    // Also update the main list display
    displayRows();
}














		function showChecklistStatus(index) {
    const patient = patientData[index];
    const status = getChecklistStatus(patient, index);
    const isTrauma = patient.Type !== 'Consult';
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                ${patient.Name || 'Unnamed'} - Checklist Status
            </h3>
            <div style="text-align: center; margin: 1.5rem 0;">
                <div style="display: inline-block; width: 80px; height: 80px; border-radius: 50%; 
                           background: ${status.percentage === 100 ? 'var(--success)' : 'var(--danger)'}; 
                           display: flex; align-items: center; justify-content: center; margin-bottom: 1rem;">
                    <span style="color: white; font-size: 1.5rem; font-weight: bold;">
                        ${status.percentage}%
                    </span>
                </div>
                <div style="color: var(--text-primary); margin-bottom: 0.5rem;">
                    <strong>${isTrauma ? 'Trauma' : 'Consult'} Checklist Progress</strong>
                </div>
                <div style="color: var(--text-secondary);">
                    ${status.completed} of ${status.total} items completed
                </div>
            </div>
            <div style="text-align: center;">
                <button onclick="showDetails(${index}); this.closest('.modal').remove();">
                    View Details
                </button>
                <button onclick="this.closest('.modal').remove();" style="margin-left: 0.5rem;">
                    Close
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function showPriorityStatus(index) {
    const patient = patientData[index];
    const priorityStatus = getPriorityStatus(patient);
    const priority = patient.Priority || 'Not set';
    
    let statusColor = 'var(--card-bg)';
    let statusText = 'No Priority';
    
    switch(priorityStatus) {
        case 'high':
            statusColor = '#ef4444';
            statusText = 'High Priority';
            break;
        case 'medium':
            statusColor = '#f59e0b';
            statusText = 'Medium Priority';
            break;
        case 'low':
            statusColor = '#10b981';
            statusText = 'Low Priority';
            break;
    }
    
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                ${patient.Name || 'Unnamed'} - Priority Status
            </h3>
            <div style="text-align: center; margin: 1.5rem 0;">
                <div style="display: inline-block; width: 80px; height: 80px; border-radius: 50%; 
                           background: ${statusColor}; display: flex; align-items: center; 
                           justify-content: center; margin-bottom: 1rem;">
                    <span style="color: white; font-size: 2rem;">●</span>
                </div>
                <div style="color: var(--text-primary); margin-bottom: 0.5rem;">
                    <strong>${statusText}</strong>
                </div>
                <div style="color: var(--text-secondary);">
                    Priority: ${priority}
                </div>
            </div>
            <div style="text-align: center;">
                <button onclick="showDetails(${index}); this.closest('.modal').remove();">
                    View Details
                </button>
                <button onclick="this.closest('.modal').remove();" style="margin-left: 0.5rem;">
                    Close
                </button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}










		function showStatusSelector(patient, index, statusDotElement) {
// In the showStatusSelector function (around line 2990), 
// replace the priorityOptions array with these neon colors:

const priorityOptions = [
    { num: '0', name: 'Priority 0 - Complete/Done', color: '#00ff41' },          // Bright neon green
    { num: '1', name: 'Priority 1 - Urgent', color: '#ff0040' },                // Bright neon red
    { num: '2', name: 'Priority 2 - High', color: '#ff6600' },                  // Bright neon orange
    { num: '3', name: 'Priority 3 - Medium-High', color: '#ffaa00' },           // Bright neon amber
    { num: '4', name: 'Priority 4 - Medium', color: '#ffff00' },                // Bright neon yellow
    { num: '5', name: 'Priority 5 - Medium-Low', color: '#ccff00' },            // Bright neon lime
    { num: '6', name: 'Priority 6 - Low-Medium', color: '#66ff00' },            // Bright neon chartreuse
    { num: '7', name: 'Priority 7 - Low', color: '#00ffff' },                   // Bright neon cyan
    { num: '8', name: 'Priority 8 - Very Low', color: '#0080ff' },              // Bright neon blue
    { num: '9', name: 'Priority 9 - Minimal', color: '#8000ff' },               // Bright neon purple
    { num: '10', name: 'Priority 10 - Lowest', color: '#ff00ff' },              // Bright neon magenta
    { num: '', name: 'No Priority', color: 'var(--card-bg)' }                   // Background color
];
			
    const modal = document.createElement('div');
    modal.className = 'modal';
    modal.style.display = 'block';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
            <h3 style="color: var(--primary); margin-bottom: 1rem;">
                Set Priority for ${patient.Name || 'Unnamed'}
            </h3>
            <div style="display: grid; gap: 0.5rem; margin-bottom: 1rem; max-height: 400px; overflow-y: auto;">
                ${priorityOptions.map(option => `
                    <button onclick="setPatientPriority('${option.num}', ${index}, this.closest('.modal'))" 
                            style="padding: 0.75rem; text-align: left; background: var(--card-bg); 
                                   border: 1px solid var(--border); border-radius: 0.375rem; 
                                   color: var(--text-primary); cursor: pointer; display: flex; 
                                   align-items: center; gap: 0.75rem;"
                            onmouseover="this.style.background='var(--card-hover)'"
                            onmouseout="this.style.background='var(--card-bg)'">
                        <div style="width: 12px; height: 12px; border-radius: 50%; 
                                    background: ${option.color};"></div>
                        ${option.name}
                    </button>
                `).join('')}
            </div>
            <div style="text-align: center;">
                <button onclick="this.closest('.modal').remove()">Cancel</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}



		

function getStatusColor(colorName) {
    const colors = {
        'red': '#ef4444',
        'yellow': '#f59e0b', 
        'green': '#10b981',
        'blue': '#3b82f6',
        'purple': '#8b5cf6',
        'orange': '#f97316',
        'grey': 'var(--card-bg)'
    };
    return colors[colorName] || 'var(--card-bg)';
}




		function setPatientPriority(priorityNum, index, modal) {
    // Set the priority number
    patientData[index].Priority = priorityNum;
    
    // Remove any saved status since we're now using priority-based system
    delete patientData[index].SavedStatus;
    
    // Save to localStorage
    saveToLocalStorage();
    
    // Refresh the display
    displayRows();
    
    // Close the modal
    modal.remove();
}













































// Camera and OCR Functions - Global variables
let currentImageCanvas = null;
let currentRotation = 0;
let baseImageSrc = null;
let extractedData = { name: '', mrn: '' };
let lastOCRText = '';

function showCameraEntry() {
    document.getElementById('entryTypeSelection').style.display = 'none';
    document.getElementById('cameraEntrySection').style.display = 'block';
    resetCameraUI();
}

function resetCameraUI() {
    document.getElementById('capturedImage').style.display = 'none';
    document.getElementById('rotationControls').style.display = 'none';
    document.getElementById('ocrProgress').style.display = 'none';
    document.getElementById('extractedInfo').style.display = 'none';
    document.getElementById('debugInfo').style.display = 'none';
    document.getElementById('processBtn').style.display = 'none';
    document.getElementById('addExtractedBtn').style.display = 'none';
    
    document.getElementById('labelImageInput').value = '';
    
    currentImageCanvas = null;
    currentRotation = 0;
    baseImageSrc = null;
    extractedData = { name: '', mrn: '' };
    lastOCRText = '';
}

function handleImageUpload(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (!file.type.startsWith('image/')) {
        alert('Please select an image file.');
        return;
    }
    
    const reader = new FileReader();
    reader.onload = function(e) {
        displayUploadedImage(e.target.result);
    };
    reader.onerror = function() {
        alert('Error reading file. Please try again.');
    };
    reader.readAsDataURL(file);
}

function displayUploadedImage(imageSrc) {
    const previewImg = document.getElementById('previewImage');
    
    previewImg.onload = function() {
        console.log('Image loaded successfully:', previewImg.naturalWidth + 'x' + previewImg.naturalHeight);
        
        baseImageSrc = imageSrc;
        currentRotation = 0;
        
        createCanvasFromImage(previewImg);
        
        document.getElementById('capturedImage').style.display = 'block';
        document.getElementById('rotationControls').style.display = 'block';
        document.getElementById('processBtn').style.display = 'inline-block';
        
        console.log('UI elements shown, ready to process');
    };
    
    previewImg.onerror = function() {
        console.error('Failed to load image');
        alert('Failed to load the image. Please try a different image.');
    };
    
    previewImg.src = imageSrc;
}

function createCanvasFromImage(imgElement) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = imgElement.naturalWidth;
    canvas.height = imgElement.naturalHeight;
    
    ctx.drawImage(imgElement, 0, 0);
    currentImageCanvas = canvas;
    
    console.log('Canvas created:', canvas.width + 'x' + canvas.height);
}

function rotateImage(degrees) {
    if (!currentImageCanvas) {
        console.error('No canvas available for rotation');
        return;
    }
    
    currentRotation = (currentRotation + degrees) % 360;
    if (currentRotation < 0) currentRotation += 360;
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const rad = (currentRotation * Math.PI) / 180;
    const sin = Math.abs(Math.sin(rad));
    const cos = Math.abs(Math.cos(rad));
    
    const origWidth = currentImageCanvas.width;
    const origHeight = currentImageCanvas.height;
    
    canvas.width = Math.floor(origWidth * cos + origHeight * sin);
    canvas.height = Math.floor(origWidth * sin + origHeight * cos);
    
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.rotate(rad);
    ctx.drawImage(currentImageCanvas, -origWidth / 2, -origHeight / 2);
    
    const rotatedDataUrl = canvas.toDataURL('image/jpeg', 0.9);
    document.getElementById('previewImage').src = rotatedDataUrl;
    
    const img = new Image();
    img.onload = function() {
        createCanvasFromImage(img);
        baseImageSrc = rotatedDataUrl;
    };
    img.src = rotatedDataUrl;
    
    console.log('Image rotated by', degrees, 'degrees. Total rotation:', currentRotation);
}




		async function processCurrentImage() {
    console.log('=== Starting image processing ===');
    
    if (!currentImageCanvas) {
        alert('No image available to process. Please upload an image first.');
        return;
    }
    
    if (!isTesseractAvailable()) {
        alert('OCR system is not loaded. Please refresh the page and try again.');
        return;
    }
    
    const progressDiv = document.getElementById('ocrProgress');
    const progressBar = document.getElementById('ocrProgressBar');
    const progressPercent = document.getElementById('ocrProgressPercent');
    
    progressDiv.style.display = 'block';
    progressPercent.textContent = 'Processing image...';
    progressBar.style.width = '20%';
    
    try {
        const imageData = currentImageCanvas.toDataURL('image/png', 1.0);
        console.log('Starting OCR with image data size:', imageData.length);
        
        progressBar.style.width = '60%';
        progressPercent.textContent = 'Reading text...';
        
        // Use direct recognition without worker management
        const result = await Tesseract.recognize(imageData, 'eng', {
            logger: m => {
                if (m.status === 'recognizing text') {
                    const progress = Math.round(60 + (m.progress * 30));
                    progressBar.style.width = progress + '%';
                    progressPercent.textContent = `Reading text... ${Math.round(m.progress * 100)}%`;
                }
            }
        });
        
        progressBar.style.width = '100%';
        progressPercent.textContent = 'Complete!';
        
        const text = result.data.text;
        const confidence = result.data.confidence;
        
        console.log('OCR completed. Confidence:', confidence);
        console.log('Extracted text:', text);
        
        lastOCRText = text || '';
        updateDebugInfo();
        
        if (!text || text.trim().length < 3) {
            throw new Error('No text could be extracted from the image. Try:\n• Rotating the image\n• Taking a clearer photo\n• Ensuring good lighting');
        }
        
        setTimeout(() => {
            progressDiv.style.display = 'none';
        }, 1500);
        
        extractPatientInfo(text);
        
    } catch (error) {
        console.error('OCR Error:', error);
        progressDiv.style.display = 'none';
        alert('Error processing image: ' + error.message);
    }
}




		








		function extractPatientInfo(text) {
    console.log('=== Extracting patient info ===');
    console.log('Input text:', text);
    
    extractedData = { name: '', mrn: '' };
    
    if (!text || text.trim().length === 0) {
        console.log('No text to process');
        displayExtractedInfo();
        return;
    }
    
    const cleanText = text.replace(/[^\w\s\n,.-]/g, ' ').replace(/\s+/g, ' ');
    const lines = cleanText.split('\n')
        .map(line => line.trim())
        .filter(line => line.length > 1);
    
    console.log('Processed lines:', lines);
    
    const fullText = cleanText.replace(/\n/g, ' ');
    
    // Extract MRN - keeping existing logic since it works
    const mrnPatterns = [
        /(?:MRN|Medical\s*Record|Record\s*#?|Patient\s*ID)[:\s#]*([0-9]{5,12})/i,
        /(?:ID|#)\s*([0-9]{6,10})/i,
        /\b([0-9]{7,10})\b/g
    ];
    
    for (const pattern of mrnPatterns) {
        if (pattern.global) {
            const matches = [...fullText.matchAll(pattern)];
            for (const match of matches) {
                const potentialMRN = match[1] || match[0];
                if (potentialMRN && potentialMRN.length >= 6 && potentialMRN.length <= 12) {
                    extractedData.mrn = potentialMRN.replace(/\D/g, '');
                    console.log('Found MRN:', extractedData.mrn);
                    break;
                }
            }
        } else {
            const match = fullText.match(pattern);
            if (match) {
                extractedData.mrn = match[1].replace(/\D/g, '');
                console.log('Found MRN:', extractedData.mrn);
                break;
            }
        }
        if (extractedData.mrn) break;
    }
    
    // ALL CAPS name extraction for medical labels
    console.log('Starting ALL CAPS name extraction...');
    
   // Strategy 1: Look for comma-separated ALL CAPS names (LAST, FIRST) - KEEP SAME FORMAT
const allCapsCommaPattern = /\b([A-Z]{2,20})\s*,\s*([A-Z]{2,20})\b/;
const commaMatch = fullText.match(allCapsCommaPattern);
if (commaMatch) {
    const fullMatch = commaMatch[0].trim(); // Get the entire match as-is
    
    // Skip if it contains numbers
    if (!/\d/.test(fullMatch)) {
        extractedData.name = fullMatch; // Keep original format: "SAWYER, JAMES"
        console.log('Found ALL CAPS comma-separated name:', extractedData.name);
    }
}

			
    
    // Strategy 2: Look for ALL CAPS name patterns (2-3 words)
    if (!extractedData.name) {
        const allCapsNamePattern = /\b([A-Z]{2,20}(?:\s+[A-Z]{2,20}){1,2})\b/g;
        const nameMatches = [...fullText.matchAll(allCapsNamePattern)];
        
        for (const match of nameMatches) {
            const candidate = match[1].trim();
            
            // Skip if contains numbers or MRN
            if (/\d/.test(candidate)) continue;
            if (extractedData.mrn && candidate.includes(extractedData.mrn)) continue;
            
            // Skip only specific label prefixes
            if (/^(DOB|ATT|AKA|FIN|MRN)/.test(candidate)) {
                console.log('Skipping label field:', candidate);
                continue;
            }
            
            // Check if it looks like a name (2-3 words, reasonable length)
            const words = candidate.split(/\s+/);
            if (words.length >= 2 && words.length <= 3 && candidate.length >= 6 && candidate.length <= 40) {
                extractedData.name = candidate;
                console.log('Found ALL CAPS name:', extractedData.name);
                break;
            }
        }
    }
    
    // Strategy 3: Line-by-line search for ALL CAPS names
    if (!extractedData.name) {
        for (let i = 0; i < Math.min(lines.length, 8); i++) {
            const line = lines[i].trim();
            
            // Skip obvious non-name lines
            if (line.length < 6 || line.length > 50) continue;
            if (/^\d/.test(line)) continue;
            if (extractedData.mrn && line.includes(extractedData.mrn)) continue;
            
            // Skip lines that start with label prefixes
            if (/^(DOB:|ATT:|AKA:|FIN:|MRN:)/i.test(line)) continue;
            
            // Check if line is predominantly ALL CAPS letters
            const allCapsLetters = (line.match(/[A-Z]/g) || []).length;
            const totalLetters = (line.match(/[A-Za-z]/g) || []).length;
            const isAllCaps = totalLetters > 0 && (allCapsLetters / totalLetters) > 0.8;
            
            if (isAllCaps && !/\d/.test(line)) {
                const words = line.split(/\s+/).filter(word => word.length > 1);
                
                if (words.length >= 2 && words.length <= 4) {
                    // Clean but keep original case
                    const cleanName = line.replace(/[^\w\s,.-]/g, '').trim();
                    if (cleanName.length >= 6) {
                        extractedData.name = cleanName;
                        console.log('Found ALL CAPS name via line analysis:', extractedData.name);
                        break;
                    }
                }
            }
        }
    }
    
    // Strategy 4: Broader ALL CAPS search as final fallback
    if (!extractedData.name) {
        const broadAllCapsPattern = /\b([A-Z]{3,15})\s+([A-Z]{3,15})\b/g;
        const broadMatches = [...fullText.matchAll(broadAllCapsPattern)];
        
        for (const match of broadMatches) {
            const word1 = match[1];
            const word2 = match[2];
            const candidate = `${word1} ${word2}`;
            
            // Skip if contains numbers or MRN
            if (/\d/.test(candidate)) continue;
            if (extractedData.mrn && candidate.includes(extractedData.mrn)) continue;
            if (candidate.length < 6 || candidate.length > 30) continue;
            
            // Skip only specific label prefixes
            if (/^(DOB|ATT|AKA|FIN|MRN)/.test(candidate)) continue;
            
            extractedData.name = candidate;
            console.log('Found ALL CAPS name via broad search:', extractedData.name);
            break;
        }
    }
    
    console.log('Final extracted data:', extractedData);
    displayExtractedInfo();
}










		










		

function displayExtractedInfo() {
    const extractedDiv = document.getElementById('extractedInfo');
    const nameSpan = document.getElementById('extractedName');
    const mrnSpan = document.getElementById('extractedMRN');
    const addBtn = document.getElementById('addExtractedBtn');
    
    nameSpan.textContent = extractedData.name || 'Not found';
    mrnSpan.textContent = extractedData.mrn || 'Not found';
    
    if (extractedData.name) {
        nameSpan.style.color = '#10b981';
        nameSpan.style.fontWeight = 'bold';
        nameSpan.style.fontStyle = 'normal';
    } else {
        nameSpan.style.color = '#ef4444';
        nameSpan.style.fontStyle = 'italic';
        nameSpan.style.fontWeight = 'normal';
    }
    
    if (extractedData.mrn) {
        mrnSpan.style.color = '#10b981';
        mrnSpan.style.fontWeight = 'bold';
        mrnSpan.style.fontStyle = 'normal';
    } else {
        mrnSpan.style.color = '#ef4444';
        mrnSpan.style.fontStyle = 'italic';
        mrnSpan.style.fontWeight = 'normal';
    }
    
    extractedDiv.style.display = 'block';
    addBtn.style.display = 'inline-block';
    
    console.log('Extraction results displayed');
}

function addExtractedPatient() {
    console.log('Adding extracted patient to list');
    
    const newPatient = {};
    MASTER_HEADERS.forEach(header => {
        newPatient[header] = '';
    });
    
    newPatient.Type = 'Patient';
    newPatient.Name = extractedData.name || 'Unknown Patient - Please Edit';
    newPatient.MRN = extractedData.mrn || '';
    newPatient.RM = 'TBD';
    
    patientData.push(newPatient);
    displayRows();
    saveToLocalStorage();
    updateCensus();
    
    closeAddEntryModal();
    
    const successParts = [];
    if (extractedData.name) successParts.push(`Name: ${extractedData.name}`);
    if (extractedData.mrn) successParts.push(`MRN: ${extractedData.mrn}`);
    
    if (successParts.length > 0) {
        alert(`Patient added successfully!\n\n${successParts.join('\n')}\n\nYou can edit any details by clicking on the patient in the list.`);
    } else {
        alert('Patient added with placeholder information.\n\nPlease click on the patient to edit the name and MRN.');
        setTimeout(() => {
            showDetails(patientData.length - 1);
        }, 100);
    }
}

function toggleDebugInfo() {
    const debugDiv = document.getElementById('debugInfo');
    if (debugDiv.style.display === 'none') {
        updateDebugInfo();
        debugDiv.style.display = 'block';
    } else {
        debugDiv.style.display = 'none';
    }
}

function updateDebugInfo() {
    const debugText = document.getElementById('debugText');
    if (debugText) {
        debugText.textContent = lastOCRText || 'No OCR text available yet';
    }
}

async function testOCRSystem() {
    console.log('=== Testing OCR System ===');
    
    const button = event.target;
    const originalText = button.textContent;
    const originalStyle = button.style.background;
    
    button.textContent = 'Testing...';
    button.disabled = true;
    button.style.background = 'linear-gradient(135deg, var(--secondary), #0891b2)';
    
    try {
        if (!isTesseractAvailable()) {
            throw new Error('Tesseract.js is not loaded. Check the script tag.');
        }
        
        console.log('Testing OCR functionality...');
        const success = await testOCRAvailability();
        
        if (success) {
            console.log('OCR system test: SUCCESS');
            button.textContent = 'OCR Working!';
            button.style.background = 'linear-gradient(135deg, var(--success), #059669)';
            alert('OCR system is working correctly!\n\nYou can now upload and process images.');
        } else {
            throw new Error('OCR test failed - could not recognize test text');
        }
        
    } catch (error) {
        console.error('OCR test error:', error);
        button.textContent = 'OCR Failed';
        button.style.background = 'linear-gradient(135deg, var(--danger), #dc2626)';
        alert('OCR test failed: ' + error.message);
    }
    
    setTimeout(() => {
        button.textContent = originalText;
        button.style.background = originalStyle;
        button.disabled = false;
    }, 3000);
}
		



		
		
		
		
    </script>
</body>
</html>
